var BeaconLiveAdmin = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
  var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);

  // vendor/topbar.js
  var require_topbar = __commonJS({
    "vendor/topbar.js"(exports, module) {
      (function(window2, document3) {
        "use strict";
        (function() {
          var lastTime = 0;
          var vendors = ["ms", "moz", "webkit", "o"];
          for (var x = 0; x < vendors.length && !window2.requestAnimationFrame; ++x) {
            window2.requestAnimationFrame = window2[vendors[x] + "RequestAnimationFrame"];
            window2.cancelAnimationFrame = window2[vendors[x] + "CancelAnimationFrame"] || window2[vendors[x] + "CancelRequestAnimationFrame"];
          }
          if (!window2.requestAnimationFrame)
            window2.requestAnimationFrame = function(callback, element2) {
              var currTime = (/* @__PURE__ */ new Date()).getTime();
              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
              var id = window2.setTimeout(function() {
                callback(currTime + timeToCall);
              }, timeToCall);
              lastTime = currTime + timeToCall;
              return id;
            };
          if (!window2.cancelAnimationFrame)
            window2.cancelAnimationFrame = function(id) {
              clearTimeout(id);
            };
        })();
        var canvas, currentProgress, showing, progressTimerId = null, fadeTimerId = null, delayTimerId = null, addEvent = function(elem, type, handler) {
          if (elem.addEventListener) elem.addEventListener(type, handler, false);
          else if (elem.attachEvent) elem.attachEvent("on" + type, handler);
          else elem["on" + type] = handler;
        }, options = {
          autoRun: true,
          barThickness: 3,
          barColors: {
            0: "rgba(26,  188, 156, .9)",
            ".25": "rgba(52,  152, 219, .9)",
            ".50": "rgba(241, 196, 15,  .9)",
            ".75": "rgba(230, 126, 34,  .9)",
            "1.0": "rgba(211, 84,  0,   .9)"
          },
          shadowBlur: 10,
          shadowColor: "rgba(0,   0,   0,   .6)",
          className: null
        }, repaint = function() {
          canvas.width = window2.innerWidth;
          canvas.height = options.barThickness * 5;
          var ctx = canvas.getContext("2d");
          ctx.shadowBlur = options.shadowBlur;
          ctx.shadowColor = options.shadowColor;
          var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          for (var stop in options.barColors) lineGradient.addColorStop(stop, options.barColors[stop]);
          ctx.lineWidth = options.barThickness;
          ctx.beginPath();
          ctx.moveTo(0, options.barThickness / 2);
          ctx.lineTo(Math.ceil(currentProgress * canvas.width), options.barThickness / 2);
          ctx.strokeStyle = lineGradient;
          ctx.stroke();
        }, createCanvas = function() {
          canvas = document3.createElement("canvas");
          var style = canvas.style;
          style.position = "fixed";
          style.top = style.left = style.right = style.margin = style.padding = 0;
          style.zIndex = 100001;
          style.display = "none";
          if (options.className) canvas.classList.add(options.className);
          document3.body.appendChild(canvas);
          addEvent(window2, "resize", repaint);
        }, topbar2 = {
          config: function(opts) {
            for (var key in opts) if (options.hasOwnProperty(key)) options[key] = opts[key];
          },
          show: function(delay) {
            if (showing) return;
            if (delay) {
              if (delayTimerId) return;
              delayTimerId = setTimeout(() => topbar2.show(), delay);
            } else {
              showing = true;
              if (fadeTimerId !== null) window2.cancelAnimationFrame(fadeTimerId);
              if (!canvas) createCanvas();
              canvas.style.opacity = 1;
              canvas.style.display = "block";
              topbar2.progress(0);
              if (options.autoRun) {
                ;
                (function loop2() {
                  progressTimerId = window2.requestAnimationFrame(loop2);
                  topbar2.progress("+" + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2));
                })();
              }
            }
          },
          progress: function(to) {
            if (typeof to === "undefined") return currentProgress;
            if (typeof to === "string") {
              to = (to.indexOf("+") >= 0 || to.indexOf("-") >= 0 ? currentProgress : 0) + parseFloat(to);
            }
            currentProgress = to > 1 ? 1 : to;
            repaint();
            return currentProgress;
          },
          hide: function() {
            clearTimeout(delayTimerId);
            delayTimerId = null;
            if (!showing) return;
            showing = false;
            if (progressTimerId != null) {
              window2.cancelAnimationFrame(progressTimerId);
              progressTimerId = null;
            }
            ;
            (function loop2() {
              if (topbar2.progress("+.1") >= 1) {
                canvas.style.opacity -= 0.05;
                if (canvas.style.opacity <= 0.05) {
                  canvas.style.display = "none";
                  fadeTimerId = null;
                  return;
                }
              }
              fadeTimerId = window2.requestAnimationFrame(loop2);
            })();
          }
        };
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = topbar2;
        } else if (typeof define === "function" && define.amd) {
          define(function() {
            return topbar2;
          });
        } else {
          this.topbar = topbar2;
        }
      }).call(exports, window, document);
    }
  });

  // node_modules/picocolors/picocolors.browser.js
  var require_picocolors_browser = __commonJS({
    "node_modules/picocolors/picocolors.browser.js"(exports, module) {
      var x = String;
      var create3 = function() {
        return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x, blackBright: x, redBright: x, greenBright: x, yellowBright: x, blueBright: x, magentaBright: x, cyanBright: x, whiteBright: x, bgBlackBright: x, bgRedBright: x, bgGreenBright: x, bgYellowBright: x, bgBlueBright: x, bgMagentaBright: x, bgCyanBright: x, bgWhiteBright: x };
      };
      module.exports = create3();
      module.exports.createColors = create3;
    }
  });

  // (disabled):node_modules/postcss/lib/terminal-highlight
  var require_terminal_highlight = __commonJS({
    "(disabled):node_modules/postcss/lib/terminal-highlight"() {
    }
  });

  // node_modules/postcss/lib/css-syntax-error.js
  var require_css_syntax_error = __commonJS({
    "node_modules/postcss/lib/css-syntax-error.js"(exports, module) {
      "use strict";
      var pico = require_picocolors_browser();
      var terminalHighlight = require_terminal_highlight();
      var CssSyntaxError2 = class _CssSyntaxError extends Error {
        constructor(message, line, column, source2, file, plugin2) {
          super(message);
          this.name = "CssSyntaxError";
          this.reason = message;
          if (file) {
            this.file = file;
          }
          if (source2) {
            this.source = source2;
          }
          if (plugin2) {
            this.plugin = plugin2;
          }
          if (typeof line !== "undefined" && typeof column !== "undefined") {
            if (typeof line === "number") {
              this.line = line;
              this.column = column;
            } else {
              this.line = line.line;
              this.column = line.column;
              this.endLine = column.line;
              this.endColumn = column.column;
            }
          }
          this.setMessage();
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, _CssSyntaxError);
          }
        }
        setMessage() {
          this.message = this.plugin ? this.plugin + ": " : "";
          this.message += this.file ? this.file : "<css input>";
          if (typeof this.line !== "undefined") {
            this.message += ":" + this.line + ":" + this.column;
          }
          this.message += ": " + this.reason;
        }
        showSourceCode(color2) {
          if (!this.source) return "";
          let css = this.source;
          if (color2 == null) color2 = pico.isColorSupported;
          let aside = (text2) => text2;
          let mark = (text2) => text2;
          let highlight = (text2) => text2;
          if (color2) {
            let { bold: bold3, gray, red } = pico.createColors(true);
            mark = (text2) => bold3(red(text2));
            aside = (text2) => gray(text2);
            if (terminalHighlight) {
              highlight = (text2) => terminalHighlight(text2);
            }
          }
          let lines = css.split(/\r?\n/);
          let start = Math.max(this.line - 3, 0);
          let end = Math.min(this.line + 2, lines.length);
          let maxWidth = String(end).length;
          return lines.slice(start, end).map((line, index5) => {
            let number2 = start + 1 + index5;
            let gutter = " " + (" " + number2).slice(-maxWidth) + " | ";
            if (number2 === this.line) {
              if (line.length > 160) {
                let padding = 20;
                let subLineStart = Math.max(0, this.column - padding);
                let subLineEnd = Math.max(
                  this.column + padding,
                  this.endColumn + padding
                );
                let subLine = line.slice(subLineStart, subLineEnd);
                let spacing2 = aside(gutter.replace(/\d/g, " ")) + line.slice(0, Math.min(this.column - 1, padding - 1)).replace(/[^\t]/g, " ");
                return mark(">") + aside(gutter) + highlight(subLine) + "\n " + spacing2 + mark("^");
              }
              let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
              return mark(">") + aside(gutter) + highlight(line) + "\n " + spacing + mark("^");
            }
            return " " + aside(gutter) + highlight(line);
          }).join("\n");
        }
        toString() {
          let code = this.showSourceCode();
          if (code) {
            code = "\n\n" + code + "\n";
          }
          return this.name + ": " + this.message + code;
        }
      };
      module.exports = CssSyntaxError2;
      CssSyntaxError2.default = CssSyntaxError2;
    }
  });

  // node_modules/postcss/lib/stringifier.js
  var require_stringifier = __commonJS({
    "node_modules/postcss/lib/stringifier.js"(exports, module) {
      "use strict";
      var DEFAULT_RAW = {
        after: "\n",
        beforeClose: "\n",
        beforeComment: "\n",
        beforeDecl: "\n",
        beforeOpen: " ",
        beforeRule: "\n",
        colon: ": ",
        commentLeft: " ",
        commentRight: " ",
        emptyBody: "",
        indent: "    ",
        semicolon: false
      };
      function capitalize(str) {
        return str[0].toUpperCase() + str.slice(1);
      }
      var Stringifier = class {
        constructor(builder) {
          this.builder = builder;
        }
        atrule(node, semicolon) {
          let name = "@" + node.name;
          let params = node.params ? this.rawValue(node, "params") : "";
          if (typeof node.raws.afterName !== "undefined") {
            name += node.raws.afterName;
          } else if (params) {
            name += " ";
          }
          if (node.nodes) {
            this.block(node, name + params);
          } else {
            let end = (node.raws.between || "") + (semicolon ? ";" : "");
            this.builder(name + params + end, node);
          }
        }
        beforeAfter(node, detect) {
          let value2;
          if (node.type === "decl") {
            value2 = this.raw(node, null, "beforeDecl");
          } else if (node.type === "comment") {
            value2 = this.raw(node, null, "beforeComment");
          } else if (detect === "before") {
            value2 = this.raw(node, null, "beforeRule");
          } else {
            value2 = this.raw(node, null, "beforeClose");
          }
          let buf = node.parent;
          let depth = 0;
          while (buf && buf.type !== "root") {
            depth += 1;
            buf = buf.parent;
          }
          if (value2.includes("\n")) {
            let indent = this.raw(node, null, "indent");
            if (indent.length) {
              for (let step = 0; step < depth; step++) value2 += indent;
            }
          }
          return value2;
        }
        block(node, start) {
          let between = this.raw(node, "between", "beforeOpen");
          this.builder(start + between + "{", node, "start");
          let after;
          if (node.nodes && node.nodes.length) {
            this.body(node);
            after = this.raw(node, "after");
          } else {
            after = this.raw(node, "after", "emptyBody");
          }
          if (after) this.builder(after);
          this.builder("}", node, "end");
        }
        body(node) {
          let last = node.nodes.length - 1;
          while (last > 0) {
            if (node.nodes[last].type !== "comment") break;
            last -= 1;
          }
          let semicolon = this.raw(node, "semicolon");
          for (let i = 0; i < node.nodes.length; i++) {
            let child2 = node.nodes[i];
            let before = this.raw(child2, "before");
            if (before) this.builder(before);
            this.stringify(child2, last !== i || semicolon);
          }
        }
        comment(node) {
          let left = this.raw(node, "left", "commentLeft");
          let right = this.raw(node, "right", "commentRight");
          this.builder("/*" + left + node.text + right + "*/", node);
        }
        decl(node, semicolon) {
          let between = this.raw(node, "between", "colon");
          let string = node.prop + between + this.rawValue(node, "value");
          if (node.important) {
            string += node.raws.important || " !important";
          }
          if (semicolon) string += ";";
          this.builder(string, node);
        }
        document(node) {
          this.body(node);
        }
        raw(node, own, detect) {
          let value2;
          if (!detect) detect = own;
          if (own) {
            value2 = node.raws[own];
            if (typeof value2 !== "undefined") return value2;
          }
          let parent = node.parent;
          if (detect === "before") {
            if (!parent || parent.type === "root" && parent.first === node) {
              return "";
            }
            if (parent && parent.type === "document") {
              return "";
            }
          }
          if (!parent) return DEFAULT_RAW[detect];
          let root12 = node.root();
          if (!root12.rawCache) root12.rawCache = {};
          if (typeof root12.rawCache[detect] !== "undefined") {
            return root12.rawCache[detect];
          }
          if (detect === "before" || detect === "after") {
            return this.beforeAfter(node, detect);
          } else {
            let method = "raw" + capitalize(detect);
            if (this[method]) {
              value2 = this[method](root12, node);
            } else {
              root12.walk((i) => {
                value2 = i.raws[own];
                if (typeof value2 !== "undefined") return false;
              });
            }
          }
          if (typeof value2 === "undefined") value2 = DEFAULT_RAW[detect];
          root12.rawCache[detect] = value2;
          return value2;
        }
        rawBeforeClose(root12) {
          let value2;
          root12.walk((i) => {
            if (i.nodes && i.nodes.length > 0) {
              if (typeof i.raws.after !== "undefined") {
                value2 = i.raws.after;
                if (value2.includes("\n")) {
                  value2 = value2.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
          if (value2) value2 = value2.replace(/\S/g, "");
          return value2;
        }
        rawBeforeComment(root12, node) {
          let value2;
          root12.walkComments((i) => {
            if (typeof i.raws.before !== "undefined") {
              value2 = i.raws.before;
              if (value2.includes("\n")) {
                value2 = value2.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value2 === "undefined") {
            value2 = this.raw(node, null, "beforeDecl");
          } else if (value2) {
            value2 = value2.replace(/\S/g, "");
          }
          return value2;
        }
        rawBeforeDecl(root12, node) {
          let value2;
          root12.walkDecls((i) => {
            if (typeof i.raws.before !== "undefined") {
              value2 = i.raws.before;
              if (value2.includes("\n")) {
                value2 = value2.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value2 === "undefined") {
            value2 = this.raw(node, null, "beforeRule");
          } else if (value2) {
            value2 = value2.replace(/\S/g, "");
          }
          return value2;
        }
        rawBeforeOpen(root12) {
          let value2;
          root12.walk((i) => {
            if (i.type !== "decl") {
              value2 = i.raws.between;
              if (typeof value2 !== "undefined") return false;
            }
          });
          return value2;
        }
        rawBeforeRule(root12) {
          let value2;
          root12.walk((i) => {
            if (i.nodes && (i.parent !== root12 || root12.first !== i)) {
              if (typeof i.raws.before !== "undefined") {
                value2 = i.raws.before;
                if (value2.includes("\n")) {
                  value2 = value2.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
          if (value2) value2 = value2.replace(/\S/g, "");
          return value2;
        }
        rawColon(root12) {
          let value2;
          root12.walkDecls((i) => {
            if (typeof i.raws.between !== "undefined") {
              value2 = i.raws.between.replace(/[^\s:]/g, "");
              return false;
            }
          });
          return value2;
        }
        rawEmptyBody(root12) {
          let value2;
          root12.walk((i) => {
            if (i.nodes && i.nodes.length === 0) {
              value2 = i.raws.after;
              if (typeof value2 !== "undefined") return false;
            }
          });
          return value2;
        }
        rawIndent(root12) {
          if (root12.raws.indent) return root12.raws.indent;
          let value2;
          root12.walk((i) => {
            let p = i.parent;
            if (p && p !== root12 && p.parent && p.parent === root12) {
              if (typeof i.raws.before !== "undefined") {
                let parts = i.raws.before.split("\n");
                value2 = parts[parts.length - 1];
                value2 = value2.replace(/\S/g, "");
                return false;
              }
            }
          });
          return value2;
        }
        rawSemicolon(root12) {
          let value2;
          root12.walk((i) => {
            if (i.nodes && i.nodes.length && i.last.type === "decl") {
              value2 = i.raws.semicolon;
              if (typeof value2 !== "undefined") return false;
            }
          });
          return value2;
        }
        rawValue(node, prop2) {
          let value2 = node[prop2];
          let raw = node.raws[prop2];
          if (raw && raw.value === value2) {
            return raw.raw;
          }
          return value2;
        }
        root(node) {
          this.body(node);
          if (node.raws.after) this.builder(node.raws.after);
        }
        rule(node) {
          this.block(node, this.rawValue(node, "selector"));
          if (node.raws.ownSemicolon) {
            this.builder(node.raws.ownSemicolon, node, "end");
          }
        }
        stringify(node, semicolon) {
          if (!this[node.type]) {
            throw new Error(
              "Unknown AST node type " + node.type + ". Maybe you need to change PostCSS stringifier."
            );
          }
          this[node.type](node, semicolon);
        }
      };
      module.exports = Stringifier;
      Stringifier.default = Stringifier;
    }
  });

  // node_modules/postcss/lib/stringify.js
  var require_stringify = __commonJS({
    "node_modules/postcss/lib/stringify.js"(exports, module) {
      "use strict";
      var Stringifier = require_stringifier();
      function stringify2(node, builder) {
        let str = new Stringifier(builder);
        str.stringify(node);
      }
      module.exports = stringify2;
      stringify2.default = stringify2;
    }
  });

  // node_modules/postcss/lib/symbols.js
  var require_symbols = __commonJS({
    "node_modules/postcss/lib/symbols.js"(exports, module) {
      "use strict";
      module.exports.isClean = Symbol("isClean");
      module.exports.my = Symbol("my");
    }
  });

  // node_modules/postcss/lib/node.js
  var require_node = __commonJS({
    "node_modules/postcss/lib/node.js"(exports, module) {
      "use strict";
      var CssSyntaxError2 = require_css_syntax_error();
      var Stringifier = require_stringifier();
      var stringify2 = require_stringify();
      var { isClean, my } = require_symbols();
      function cloneNode(obj, parent) {
        let cloned = new obj.constructor();
        for (let i in obj) {
          if (!Object.prototype.hasOwnProperty.call(obj, i)) {
            continue;
          }
          if (i === "proxyCache") continue;
          let value2 = obj[i];
          let type = typeof value2;
          if (i === "parent" && type === "object") {
            if (parent) cloned[i] = parent;
          } else if (i === "source") {
            cloned[i] = value2;
          } else if (Array.isArray(value2)) {
            cloned[i] = value2.map((j) => cloneNode(j, cloned));
          } else {
            if (type === "object" && value2 !== null) value2 = cloneNode(value2);
            cloned[i] = value2;
          }
        }
        return cloned;
      }
      function sourceOffset(inputCSS, position2) {
        if (position2 && typeof position2.offset !== "undefined") {
          return position2.offset;
        }
        let column = 1;
        let line = 1;
        let offset = 0;
        for (let i = 0; i < inputCSS.length; i++) {
          if (line === position2.line && column === position2.column) {
            offset = i;
            break;
          }
          if (inputCSS[i] === "\n") {
            column = 1;
            line += 1;
          } else {
            column += 1;
          }
        }
        return offset;
      }
      var Node3 = class {
        get proxyOf() {
          return this;
        }
        constructor(defaults3 = {}) {
          this.raws = {};
          this[isClean] = false;
          this[my] = true;
          for (let name in defaults3) {
            if (name === "nodes") {
              this.nodes = [];
              for (let node of defaults3[name]) {
                if (typeof node.clone === "function") {
                  this.append(node.clone());
                } else {
                  this.append(node);
                }
              }
            } else {
              this[name] = defaults3[name];
            }
          }
        }
        addToError(error) {
          error.postcssNode = this;
          if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
            let s = this.source;
            error.stack = error.stack.replace(
              /\n\s{4}at /,
              `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
            );
          }
          return error;
        }
        after(add) {
          this.parent.insertAfter(this, add);
          return this;
        }
        assign(overrides = {}) {
          for (let name in overrides) {
            this[name] = overrides[name];
          }
          return this;
        }
        before(add) {
          this.parent.insertBefore(this, add);
          return this;
        }
        cleanRaws(keepBetween) {
          delete this.raws.before;
          delete this.raws.after;
          if (!keepBetween) delete this.raws.between;
        }
        clone(overrides = {}) {
          let cloned = cloneNode(this);
          for (let name in overrides) {
            cloned[name] = overrides[name];
          }
          return cloned;
        }
        cloneAfter(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertAfter(this, cloned);
          return cloned;
        }
        cloneBefore(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertBefore(this, cloned);
          return cloned;
        }
        error(message, opts = {}) {
          if (this.source) {
            let { end, start } = this.rangeBy(opts);
            return this.source.input.error(
              message,
              { column: start.column, line: start.line },
              { column: end.column, line: end.line },
              opts
            );
          }
          return new CssSyntaxError2(message);
        }
        getProxyProcessor() {
          return {
            get(node, prop2) {
              if (prop2 === "proxyOf") {
                return node;
              } else if (prop2 === "root") {
                return () => node.root().toProxy();
              } else {
                return node[prop2];
              }
            },
            set(node, prop2, value2) {
              if (node[prop2] === value2) return true;
              node[prop2] = value2;
              if (prop2 === "prop" || prop2 === "value" || prop2 === "name" || prop2 === "params" || prop2 === "important" || /* c8 ignore next */
              prop2 === "text") {
                node.markDirty();
              }
              return true;
            }
          };
        }
        /* c8 ignore next 3 */
        markClean() {
          this[isClean] = true;
        }
        markDirty() {
          if (this[isClean]) {
            this[isClean] = false;
            let next2 = this;
            while (next2 = next2.parent) {
              next2[isClean] = false;
            }
          }
        }
        next() {
          if (!this.parent) return void 0;
          let index5 = this.parent.index(this);
          return this.parent.nodes[index5 + 1];
        }
        positionBy(opts) {
          let pos = this.source.start;
          if (opts.index) {
            pos = this.positionInside(opts.index);
          } else if (opts.word) {
            let inputString = "document" in this.source.input ? this.source.input.document : this.source.input.css;
            let stringRepresentation = inputString.slice(
              sourceOffset(inputString, this.source.start),
              sourceOffset(inputString, this.source.end)
            );
            let index5 = stringRepresentation.indexOf(opts.word);
            if (index5 !== -1) pos = this.positionInside(index5);
          }
          return pos;
        }
        positionInside(index5) {
          let column = this.source.start.column;
          let line = this.source.start.line;
          let inputString = "document" in this.source.input ? this.source.input.document : this.source.input.css;
          let offset = sourceOffset(inputString, this.source.start);
          let end = offset + index5;
          for (let i = offset; i < end; i++) {
            if (inputString[i] === "\n") {
              column = 1;
              line += 1;
            } else {
              column += 1;
            }
          }
          return { column, line };
        }
        prev() {
          if (!this.parent) return void 0;
          let index5 = this.parent.index(this);
          return this.parent.nodes[index5 - 1];
        }
        rangeBy(opts) {
          let start = {
            column: this.source.start.column,
            line: this.source.start.line
          };
          let end = this.source.end ? {
            column: this.source.end.column + 1,
            line: this.source.end.line
          } : {
            column: start.column + 1,
            line: start.line
          };
          if (opts.word) {
            let inputString = "document" in this.source.input ? this.source.input.document : this.source.input.css;
            let stringRepresentation = inputString.slice(
              sourceOffset(inputString, this.source.start),
              sourceOffset(inputString, this.source.end)
            );
            let index5 = stringRepresentation.indexOf(opts.word);
            if (index5 !== -1) {
              start = this.positionInside(index5);
              end = this.positionInside(
                index5 + opts.word.length
              );
            }
          } else {
            if (opts.start) {
              start = {
                column: opts.start.column,
                line: opts.start.line
              };
            } else if (opts.index) {
              start = this.positionInside(opts.index);
            }
            if (opts.end) {
              end = {
                column: opts.end.column,
                line: opts.end.line
              };
            } else if (typeof opts.endIndex === "number") {
              end = this.positionInside(opts.endIndex);
            } else if (opts.index) {
              end = this.positionInside(opts.index + 1);
            }
          }
          if (end.line < start.line || end.line === start.line && end.column <= start.column) {
            end = { column: start.column + 1, line: start.line };
          }
          return { end, start };
        }
        raw(prop2, defaultType) {
          let str = new Stringifier();
          return str.raw(this, prop2, defaultType);
        }
        remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = void 0;
          return this;
        }
        replaceWith(...nodes) {
          if (this.parent) {
            let bookmark = this;
            let foundSelf = false;
            for (let node of nodes) {
              if (node === this) {
                foundSelf = true;
              } else if (foundSelf) {
                this.parent.insertAfter(bookmark, node);
                bookmark = node;
              } else {
                this.parent.insertBefore(bookmark, node);
              }
            }
            if (!foundSelf) {
              this.remove();
            }
          }
          return this;
        }
        root() {
          let result = this;
          while (result.parent && result.parent.type !== "document") {
            result = result.parent;
          }
          return result;
        }
        toJSON(_, inputs) {
          let fixed = {};
          let emitInputs = inputs == null;
          inputs = inputs || /* @__PURE__ */ new Map();
          let inputsNextIndex = 0;
          for (let name in this) {
            if (!Object.prototype.hasOwnProperty.call(this, name)) {
              continue;
            }
            if (name === "parent" || name === "proxyCache") continue;
            let value2 = this[name];
            if (Array.isArray(value2)) {
              fixed[name] = value2.map((i) => {
                if (typeof i === "object" && i.toJSON) {
                  return i.toJSON(null, inputs);
                } else {
                  return i;
                }
              });
            } else if (typeof value2 === "object" && value2.toJSON) {
              fixed[name] = value2.toJSON(null, inputs);
            } else if (name === "source") {
              let inputId = inputs.get(value2.input);
              if (inputId == null) {
                inputId = inputsNextIndex;
                inputs.set(value2.input, inputsNextIndex);
                inputsNextIndex++;
              }
              fixed[name] = {
                end: value2.end,
                inputId,
                start: value2.start
              };
            } else {
              fixed[name] = value2;
            }
          }
          if (emitInputs) {
            fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
          }
          return fixed;
        }
        toProxy() {
          if (!this.proxyCache) {
            this.proxyCache = new Proxy(this, this.getProxyProcessor());
          }
          return this.proxyCache;
        }
        toString(stringifier = stringify2) {
          if (stringifier.stringify) stringifier = stringifier.stringify;
          let result = "";
          stringifier(this, (i) => {
            result += i;
          });
          return result;
        }
        warn(result, text2, opts) {
          let data = { node: this };
          for (let i in opts) data[i] = opts[i];
          return result.warn(text2, data);
        }
      };
      module.exports = Node3;
      Node3.default = Node3;
    }
  });

  // node_modules/postcss/lib/comment.js
  var require_comment = __commonJS({
    "node_modules/postcss/lib/comment.js"(exports, module) {
      "use strict";
      var Node3 = require_node();
      var Comment3 = class extends Node3 {
        constructor(defaults3) {
          super(defaults3);
          this.type = "comment";
        }
      };
      module.exports = Comment3;
      Comment3.default = Comment3;
    }
  });

  // node_modules/postcss/lib/declaration.js
  var require_declaration = __commonJS({
    "node_modules/postcss/lib/declaration.js"(exports, module) {
      "use strict";
      var Node3 = require_node();
      var Declaration2 = class extends Node3 {
        get variable() {
          return this.prop.startsWith("--") || this.prop[0] === "$";
        }
        constructor(defaults3) {
          if (defaults3 && typeof defaults3.value !== "undefined" && typeof defaults3.value !== "string") {
            defaults3 = { ...defaults3, value: String(defaults3.value) };
          }
          super(defaults3);
          this.type = "decl";
        }
      };
      module.exports = Declaration2;
      Declaration2.default = Declaration2;
    }
  });

  // node_modules/postcss/lib/container.js
  var require_container = __commonJS({
    "node_modules/postcss/lib/container.js"(exports, module) {
      "use strict";
      var Comment3 = require_comment();
      var Declaration2 = require_declaration();
      var Node3 = require_node();
      var { isClean, my } = require_symbols();
      var AtRule2;
      var parse3;
      var Root2;
      var Rule2;
      function cleanSource(nodes) {
        return nodes.map((i) => {
          if (i.nodes) i.nodes = cleanSource(i.nodes);
          delete i.source;
          return i;
        });
      }
      function markTreeDirty(node) {
        node[isClean] = false;
        if (node.proxyOf.nodes) {
          for (let i of node.proxyOf.nodes) {
            markTreeDirty(i);
          }
        }
      }
      var Container2 = class _Container extends Node3 {
        get first() {
          if (!this.proxyOf.nodes) return void 0;
          return this.proxyOf.nodes[0];
        }
        get last() {
          if (!this.proxyOf.nodes) return void 0;
          return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
        }
        append(...children) {
          for (let child2 of children) {
            let nodes = this.normalize(child2, this.last);
            for (let node of nodes) this.proxyOf.nodes.push(node);
          }
          this.markDirty();
          return this;
        }
        cleanRaws(keepBetween) {
          super.cleanRaws(keepBetween);
          if (this.nodes) {
            for (let node of this.nodes) node.cleanRaws(keepBetween);
          }
        }
        each(callback) {
          if (!this.proxyOf.nodes) return void 0;
          let iterator = this.getIterator();
          let index5, result;
          while (this.indexes[iterator] < this.proxyOf.nodes.length) {
            index5 = this.indexes[iterator];
            result = callback(this.proxyOf.nodes[index5], index5);
            if (result === false) break;
            this.indexes[iterator] += 1;
          }
          delete this.indexes[iterator];
          return result;
        }
        every(condition) {
          return this.nodes.every(condition);
        }
        getIterator() {
          if (!this.lastEach) this.lastEach = 0;
          if (!this.indexes) this.indexes = {};
          this.lastEach += 1;
          let iterator = this.lastEach;
          this.indexes[iterator] = 0;
          return iterator;
        }
        getProxyProcessor() {
          return {
            get(node, prop2) {
              if (prop2 === "proxyOf") {
                return node;
              } else if (!node[prop2]) {
                return node[prop2];
              } else if (prop2 === "each" || typeof prop2 === "string" && prop2.startsWith("walk")) {
                return (...args) => {
                  return node[prop2](
                    ...args.map((i) => {
                      if (typeof i === "function") {
                        return (child2, index5) => i(child2.toProxy(), index5);
                      } else {
                        return i;
                      }
                    })
                  );
                };
              } else if (prop2 === "every" || prop2 === "some") {
                return (cb) => {
                  return node[prop2](
                    (child2, ...other) => cb(child2.toProxy(), ...other)
                  );
                };
              } else if (prop2 === "root") {
                return () => node.root().toProxy();
              } else if (prop2 === "nodes") {
                return node.nodes.map((i) => i.toProxy());
              } else if (prop2 === "first" || prop2 === "last") {
                return node[prop2].toProxy();
              } else {
                return node[prop2];
              }
            },
            set(node, prop2, value2) {
              if (node[prop2] === value2) return true;
              node[prop2] = value2;
              if (prop2 === "name" || prop2 === "params" || prop2 === "selector") {
                node.markDirty();
              }
              return true;
            }
          };
        }
        index(child2) {
          if (typeof child2 === "number") return child2;
          if (child2.proxyOf) child2 = child2.proxyOf;
          return this.proxyOf.nodes.indexOf(child2);
        }
        insertAfter(exist, add) {
          let existIndex = this.index(exist);
          let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
          existIndex = this.index(exist);
          for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node);
          let index5;
          for (let id in this.indexes) {
            index5 = this.indexes[id];
            if (existIndex < index5) {
              this.indexes[id] = index5 + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        insertBefore(exist, add) {
          let existIndex = this.index(exist);
          let type = existIndex === 0 ? "prepend" : false;
          let nodes = this.normalize(
            add,
            this.proxyOf.nodes[existIndex],
            type
          ).reverse();
          existIndex = this.index(exist);
          for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node);
          let index5;
          for (let id in this.indexes) {
            index5 = this.indexes[id];
            if (existIndex <= index5) {
              this.indexes[id] = index5 + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        normalize(nodes, sample) {
          if (typeof nodes === "string") {
            nodes = cleanSource(parse3(nodes).nodes);
          } else if (typeof nodes === "undefined") {
            nodes = [];
          } else if (Array.isArray(nodes)) {
            nodes = nodes.slice(0);
            for (let i of nodes) {
              if (i.parent) i.parent.removeChild(i, "ignore");
            }
          } else if (nodes.type === "root" && this.type !== "document") {
            nodes = nodes.nodes.slice(0);
            for (let i of nodes) {
              if (i.parent) i.parent.removeChild(i, "ignore");
            }
          } else if (nodes.type) {
            nodes = [nodes];
          } else if (nodes.prop) {
            if (typeof nodes.value === "undefined") {
              throw new Error("Value field is missed in node creation");
            } else if (typeof nodes.value !== "string") {
              nodes.value = String(nodes.value);
            }
            nodes = [new Declaration2(nodes)];
          } else if (nodes.selector || nodes.selectors) {
            nodes = [new Rule2(nodes)];
          } else if (nodes.name) {
            nodes = [new AtRule2(nodes)];
          } else if (nodes.text) {
            nodes = [new Comment3(nodes)];
          } else {
            throw new Error("Unknown node type in node creation");
          }
          let processed = nodes.map((i) => {
            if (!i[my]) _Container.rebuild(i);
            i = i.proxyOf;
            if (i.parent) i.parent.removeChild(i);
            if (i[isClean]) markTreeDirty(i);
            if (!i.raws) i.raws = {};
            if (typeof i.raws.before === "undefined") {
              if (sample && typeof sample.raws.before !== "undefined") {
                i.raws.before = sample.raws.before.replace(/\S/g, "");
              }
            }
            i.parent = this.proxyOf;
            return i;
          });
          return processed;
        }
        prepend(...children) {
          children = children.reverse();
          for (let child2 of children) {
            let nodes = this.normalize(child2, this.first, "prepend").reverse();
            for (let node of nodes) this.proxyOf.nodes.unshift(node);
            for (let id in this.indexes) {
              this.indexes[id] = this.indexes[id] + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        push(child2) {
          child2.parent = this;
          this.proxyOf.nodes.push(child2);
          return this;
        }
        removeAll() {
          for (let node of this.proxyOf.nodes) node.parent = void 0;
          this.proxyOf.nodes = [];
          this.markDirty();
          return this;
        }
        removeChild(child2) {
          child2 = this.index(child2);
          this.proxyOf.nodes[child2].parent = void 0;
          this.proxyOf.nodes.splice(child2, 1);
          let index5;
          for (let id in this.indexes) {
            index5 = this.indexes[id];
            if (index5 >= child2) {
              this.indexes[id] = index5 - 1;
            }
          }
          this.markDirty();
          return this;
        }
        replaceValues(pattern2, opts, callback) {
          if (!callback) {
            callback = opts;
            opts = {};
          }
          this.walkDecls((decl2) => {
            if (opts.props && !opts.props.includes(decl2.prop)) return;
            if (opts.fast && !decl2.value.includes(opts.fast)) return;
            decl2.value = decl2.value.replace(pattern2, callback);
          });
          this.markDirty();
          return this;
        }
        some(condition) {
          return this.nodes.some(condition);
        }
        walk(callback) {
          return this.each((child2, i) => {
            let result;
            try {
              result = callback(child2, i);
            } catch (e) {
              throw child2.addToError(e);
            }
            if (result !== false && child2.walk) {
              result = child2.walk(callback);
            }
            return result;
          });
        }
        walkAtRules(name, callback) {
          if (!callback) {
            callback = name;
            return this.walk((child2, i) => {
              if (child2.type === "atrule") {
                return callback(child2, i);
              }
            });
          }
          if (name instanceof RegExp) {
            return this.walk((child2, i) => {
              if (child2.type === "atrule" && name.test(child2.name)) {
                return callback(child2, i);
              }
            });
          }
          return this.walk((child2, i) => {
            if (child2.type === "atrule" && child2.name === name) {
              return callback(child2, i);
            }
          });
        }
        walkComments(callback) {
          return this.walk((child2, i) => {
            if (child2.type === "comment") {
              return callback(child2, i);
            }
          });
        }
        walkDecls(prop2, callback) {
          if (!callback) {
            callback = prop2;
            return this.walk((child2, i) => {
              if (child2.type === "decl") {
                return callback(child2, i);
              }
            });
          }
          if (prop2 instanceof RegExp) {
            return this.walk((child2, i) => {
              if (child2.type === "decl" && prop2.test(child2.prop)) {
                return callback(child2, i);
              }
            });
          }
          return this.walk((child2, i) => {
            if (child2.type === "decl" && child2.prop === prop2) {
              return callback(child2, i);
            }
          });
        }
        walkRules(selector, callback) {
          if (!callback) {
            callback = selector;
            return this.walk((child2, i) => {
              if (child2.type === "rule") {
                return callback(child2, i);
              }
            });
          }
          if (selector instanceof RegExp) {
            return this.walk((child2, i) => {
              if (child2.type === "rule" && selector.test(child2.selector)) {
                return callback(child2, i);
              }
            });
          }
          return this.walk((child2, i) => {
            if (child2.type === "rule" && child2.selector === selector) {
              return callback(child2, i);
            }
          });
        }
      };
      Container2.registerParse = (dependant) => {
        parse3 = dependant;
      };
      Container2.registerRule = (dependant) => {
        Rule2 = dependant;
      };
      Container2.registerAtRule = (dependant) => {
        AtRule2 = dependant;
      };
      Container2.registerRoot = (dependant) => {
        Root2 = dependant;
      };
      module.exports = Container2;
      Container2.default = Container2;
      Container2.rebuild = (node) => {
        if (node.type === "atrule") {
          Object.setPrototypeOf(node, AtRule2.prototype);
        } else if (node.type === "rule") {
          Object.setPrototypeOf(node, Rule2.prototype);
        } else if (node.type === "decl") {
          Object.setPrototypeOf(node, Declaration2.prototype);
        } else if (node.type === "comment") {
          Object.setPrototypeOf(node, Comment3.prototype);
        } else if (node.type === "root") {
          Object.setPrototypeOf(node, Root2.prototype);
        }
        node[my] = true;
        if (node.nodes) {
          node.nodes.forEach((child2) => {
            Container2.rebuild(child2);
          });
        }
      };
    }
  });

  // node_modules/postcss/lib/at-rule.js
  var require_at_rule = __commonJS({
    "node_modules/postcss/lib/at-rule.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var AtRule2 = class extends Container2 {
        constructor(defaults3) {
          super(defaults3);
          this.type = "atrule";
        }
        append(...children) {
          if (!this.proxyOf.nodes) this.nodes = [];
          return super.append(...children);
        }
        prepend(...children) {
          if (!this.proxyOf.nodes) this.nodes = [];
          return super.prepend(...children);
        }
      };
      module.exports = AtRule2;
      AtRule2.default = AtRule2;
      Container2.registerAtRule(AtRule2);
    }
  });

  // node_modules/postcss/lib/document.js
  var require_document = __commonJS({
    "node_modules/postcss/lib/document.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var LazyResult;
      var Processor2;
      var Document2 = class extends Container2 {
        constructor(defaults3) {
          super({ type: "document", ...defaults3 });
          if (!this.nodes) {
            this.nodes = [];
          }
        }
        toResult(opts = {}) {
          let lazy = new LazyResult(new Processor2(), this, opts);
          return lazy.stringify();
        }
      };
      Document2.registerLazyResult = (dependant) => {
        LazyResult = dependant;
      };
      Document2.registerProcessor = (dependant) => {
        Processor2 = dependant;
      };
      module.exports = Document2;
      Document2.default = Document2;
    }
  });

  // node_modules/nanoid/non-secure/index.cjs
  var require_non_secure = __commonJS({
    "node_modules/nanoid/non-secure/index.cjs"(exports, module) {
      var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
      var customAlphabet = (alphabet, defaultSize = 21) => {
        return (size = defaultSize) => {
          let id = "";
          let i = size | 0;
          while (i--) {
            id += alphabet[Math.random() * alphabet.length | 0];
          }
          return id;
        };
      };
      var nanoid = (size = 21) => {
        let id = "";
        let i = size | 0;
        while (i--) {
          id += urlAlphabet[Math.random() * 64 | 0];
        }
        return id;
      };
      module.exports = { nanoid, customAlphabet };
    }
  });

  // (disabled):path
  var require_path = __commonJS({
    "(disabled):path"() {
    }
  });

  // (disabled):node_modules/source-map-js/source-map.js
  var require_source_map = __commonJS({
    "(disabled):node_modules/source-map-js/source-map.js"() {
    }
  });

  // (disabled):url
  var require_url = __commonJS({
    "(disabled):url"() {
    }
  });

  // (disabled):fs
  var require_fs = __commonJS({
    "(disabled):fs"() {
    }
  });

  // node_modules/postcss/lib/previous-map.js
  var require_previous_map = __commonJS({
    "node_modules/postcss/lib/previous-map.js"(exports, module) {
      "use strict";
      var { existsSync, readFileSync } = require_fs();
      var { dirname, join: join2 } = require_path();
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      function fromBase64(str) {
        if (Buffer) {
          return Buffer.from(str, "base64").toString();
        } else {
          return window.atob(str);
        }
      }
      var PreviousMap = class {
        constructor(css, opts) {
          if (opts.map === false) return;
          this.loadAnnotation(css);
          this.inline = this.startWith(this.annotation, "data:");
          let prev = opts.map ? opts.map.prev : void 0;
          let text2 = this.loadMap(opts.from, prev);
          if (!this.mapFile && opts.from) {
            this.mapFile = opts.from;
          }
          if (this.mapFile) this.root = dirname(this.mapFile);
          if (text2) this.text = text2;
        }
        consumer() {
          if (!this.consumerCache) {
            this.consumerCache = new SourceMapConsumer(this.text);
          }
          return this.consumerCache;
        }
        decodeInline(text2) {
          let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
          let baseUri = /^data:application\/json;base64,/;
          let charsetUri = /^data:application\/json;charset=utf-?8,/;
          let uri = /^data:application\/json,/;
          let uriMatch = text2.match(charsetUri) || text2.match(uri);
          if (uriMatch) {
            return decodeURIComponent(text2.substr(uriMatch[0].length));
          }
          let baseUriMatch = text2.match(baseCharsetUri) || text2.match(baseUri);
          if (baseUriMatch) {
            return fromBase64(text2.substr(baseUriMatch[0].length));
          }
          let encoding = text2.match(/data:application\/json;([^,]+),/)[1];
          throw new Error("Unsupported source map encoding " + encoding);
        }
        getAnnotationURL(sourceMapString) {
          return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
        }
        isMap(map) {
          if (typeof map !== "object") return false;
          return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
        }
        loadAnnotation(css) {
          let comments = css.match(/\/\*\s*# sourceMappingURL=/g);
          if (!comments) return;
          let start = css.lastIndexOf(comments.pop());
          let end = css.indexOf("*/", start);
          if (start > -1 && end > -1) {
            this.annotation = this.getAnnotationURL(css.substring(start, end));
          }
        }
        loadFile(path) {
          this.root = dirname(path);
          if (existsSync(path)) {
            this.mapFile = path;
            return readFileSync(path, "utf-8").toString().trim();
          }
        }
        loadMap(file, prev) {
          if (prev === false) return false;
          if (prev) {
            if (typeof prev === "string") {
              return prev;
            } else if (typeof prev === "function") {
              let prevPath = prev(file);
              if (prevPath) {
                let map = this.loadFile(prevPath);
                if (!map) {
                  throw new Error(
                    "Unable to load previous source map: " + prevPath.toString()
                  );
                }
                return map;
              }
            } else if (prev instanceof SourceMapConsumer) {
              return SourceMapGenerator.fromSourceMap(prev).toString();
            } else if (prev instanceof SourceMapGenerator) {
              return prev.toString();
            } else if (this.isMap(prev)) {
              return JSON.stringify(prev);
            } else {
              throw new Error(
                "Unsupported previous source map format: " + prev.toString()
              );
            }
          } else if (this.inline) {
            return this.decodeInline(this.annotation);
          } else if (this.annotation) {
            let map = this.annotation;
            if (file) map = join2(dirname(file), map);
            return this.loadFile(map);
          }
        }
        startWith(string, start) {
          if (!string) return false;
          return string.substr(0, start.length) === start;
        }
        withContent() {
          return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
        }
      };
      module.exports = PreviousMap;
      PreviousMap.default = PreviousMap;
    }
  });

  // node_modules/postcss/lib/input.js
  var require_input = __commonJS({
    "node_modules/postcss/lib/input.js"(exports, module) {
      "use strict";
      var { nanoid } = require_non_secure();
      var { isAbsolute, resolve } = require_path();
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { fileURLToPath, pathToFileURL } = require_url();
      var CssSyntaxError2 = require_css_syntax_error();
      var PreviousMap = require_previous_map();
      var terminalHighlight = require_terminal_highlight();
      var fromOffsetCache = Symbol("fromOffsetCache");
      var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
      var pathAvailable = Boolean(resolve && isAbsolute);
      var Input2 = class {
        get from() {
          return this.file || this.id;
        }
        constructor(css, opts = {}) {
          if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
            throw new Error(`PostCSS received ${css} instead of CSS string`);
          }
          this.css = css.toString();
          if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
            this.hasBOM = true;
            this.css = this.css.slice(1);
          } else {
            this.hasBOM = false;
          }
          this.document = this.css;
          if (opts.document) this.document = opts.document.toString();
          if (opts.from) {
            if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
              this.file = opts.from;
            } else {
              this.file = resolve(opts.from);
            }
          }
          if (pathAvailable && sourceMapAvailable) {
            let map = new PreviousMap(this.css, opts);
            if (map.text) {
              this.map = map;
              let file = map.consumer().file;
              if (!this.file && file) this.file = this.mapResolve(file);
            }
          }
          if (!this.file) {
            this.id = "<input css " + nanoid(6) + ">";
          }
          if (this.map) this.map.file = this.from;
        }
        error(message, line, column, opts = {}) {
          let endColumn, endLine, result;
          if (line && typeof line === "object") {
            let start = line;
            let end = column;
            if (typeof start.offset === "number") {
              let pos = this.fromOffset(start.offset);
              line = pos.line;
              column = pos.col;
            } else {
              line = start.line;
              column = start.column;
            }
            if (typeof end.offset === "number") {
              let pos = this.fromOffset(end.offset);
              endLine = pos.line;
              endColumn = pos.col;
            } else {
              endLine = end.line;
              endColumn = end.column;
            }
          } else if (!column) {
            let pos = this.fromOffset(line);
            line = pos.line;
            column = pos.col;
          }
          let origin = this.origin(line, column, endLine, endColumn);
          if (origin) {
            result = new CssSyntaxError2(
              message,
              origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
              origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
              origin.source,
              origin.file,
              opts.plugin
            );
          } else {
            result = new CssSyntaxError2(
              message,
              endLine === void 0 ? line : { column, line },
              endLine === void 0 ? column : { column: endColumn, line: endLine },
              this.css,
              this.file,
              opts.plugin
            );
          }
          result.input = { column, endColumn, endLine, line, source: this.css };
          if (this.file) {
            if (pathToFileURL) {
              result.input.url = pathToFileURL(this.file).toString();
            }
            result.input.file = this.file;
          }
          return result;
        }
        fromOffset(offset) {
          let lastLine, lineToIndex;
          if (!this[fromOffsetCache]) {
            let lines = this.css.split("\n");
            lineToIndex = new Array(lines.length);
            let prevIndex = 0;
            for (let i = 0, l = lines.length; i < l; i++) {
              lineToIndex[i] = prevIndex;
              prevIndex += lines[i].length + 1;
            }
            this[fromOffsetCache] = lineToIndex;
          } else {
            lineToIndex = this[fromOffsetCache];
          }
          lastLine = lineToIndex[lineToIndex.length - 1];
          let min = 0;
          if (offset >= lastLine) {
            min = lineToIndex.length - 1;
          } else {
            let max2 = lineToIndex.length - 2;
            let mid;
            while (min < max2) {
              mid = min + (max2 - min >> 1);
              if (offset < lineToIndex[mid]) {
                max2 = mid - 1;
              } else if (offset >= lineToIndex[mid + 1]) {
                min = mid + 1;
              } else {
                min = mid;
                break;
              }
            }
          }
          return {
            col: offset - lineToIndex[min] + 1,
            line: min + 1
          };
        }
        mapResolve(file) {
          if (/^\w+:\/\//.test(file)) {
            return file;
          }
          return resolve(this.map.consumer().sourceRoot || this.map.root || ".", file);
        }
        origin(line, column, endLine, endColumn) {
          if (!this.map) return false;
          let consumer = this.map.consumer();
          let from = consumer.originalPositionFor({ column, line });
          if (!from.source) return false;
          let to;
          if (typeof endLine === "number") {
            to = consumer.originalPositionFor({ column: endColumn, line: endLine });
          }
          let fromUrl;
          if (isAbsolute(from.source)) {
            fromUrl = pathToFileURL(from.source);
          } else {
            fromUrl = new URL(
              from.source,
              this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
            );
          }
          let result = {
            column: from.column,
            endColumn: to && to.column,
            endLine: to && to.line,
            line: from.line,
            url: fromUrl.toString()
          };
          if (fromUrl.protocol === "file:") {
            if (fileURLToPath) {
              result.file = fileURLToPath(fromUrl);
            } else {
              throw new Error(`file: protocol is not available in this PostCSS build`);
            }
          }
          let source2 = consumer.sourceContentFor(from.source);
          if (source2) result.source = source2;
          return result;
        }
        toJSON() {
          let json = {};
          for (let name of ["hasBOM", "css", "file", "id"]) {
            if (this[name] != null) {
              json[name] = this[name];
            }
          }
          if (this.map) {
            json.map = { ...this.map };
            if (json.map.consumerCache) {
              json.map.consumerCache = void 0;
            }
          }
          return json;
        }
      };
      module.exports = Input2;
      Input2.default = Input2;
      if (terminalHighlight && terminalHighlight.registerInput) {
        terminalHighlight.registerInput(Input2);
      }
    }
  });

  // node_modules/postcss/lib/root.js
  var require_root = __commonJS({
    "node_modules/postcss/lib/root.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var LazyResult;
      var Processor2;
      var Root2 = class extends Container2 {
        constructor(defaults3) {
          super(defaults3);
          this.type = "root";
          if (!this.nodes) this.nodes = [];
        }
        normalize(child2, sample, type) {
          let nodes = super.normalize(child2);
          if (sample) {
            if (type === "prepend") {
              if (this.nodes.length > 1) {
                sample.raws.before = this.nodes[1].raws.before;
              } else {
                delete sample.raws.before;
              }
            } else if (this.first !== sample) {
              for (let node of nodes) {
                node.raws.before = sample.raws.before;
              }
            }
          }
          return nodes;
        }
        removeChild(child2, ignore) {
          let index5 = this.index(child2);
          if (!ignore && index5 === 0 && this.nodes.length > 1) {
            this.nodes[1].raws.before = this.nodes[index5].raws.before;
          }
          return super.removeChild(child2);
        }
        toResult(opts = {}) {
          let lazy = new LazyResult(new Processor2(), this, opts);
          return lazy.stringify();
        }
      };
      Root2.registerLazyResult = (dependant) => {
        LazyResult = dependant;
      };
      Root2.registerProcessor = (dependant) => {
        Processor2 = dependant;
      };
      module.exports = Root2;
      Root2.default = Root2;
      Container2.registerRoot(Root2);
    }
  });

  // node_modules/postcss/lib/list.js
  var require_list = __commonJS({
    "node_modules/postcss/lib/list.js"(exports, module) {
      "use strict";
      var list3 = {
        comma(string) {
          return list3.split(string, [","], true);
        },
        space(string) {
          let spaces = [" ", "\n", "	"];
          return list3.split(string, spaces);
        },
        split(string, separators, last) {
          let array = [];
          let current = "";
          let split = false;
          let func = 0;
          let inQuote = false;
          let prevQuote = "";
          let escape2 = false;
          for (let letter of string) {
            if (escape2) {
              escape2 = false;
            } else if (letter === "\\") {
              escape2 = true;
            } else if (inQuote) {
              if (letter === prevQuote) {
                inQuote = false;
              }
            } else if (letter === '"' || letter === "'") {
              inQuote = true;
              prevQuote = letter;
            } else if (letter === "(") {
              func += 1;
            } else if (letter === ")") {
              if (func > 0) func -= 1;
            } else if (func === 0) {
              if (separators.includes(letter)) split = true;
            }
            if (split) {
              if (current !== "") array.push(current.trim());
              current = "";
              split = false;
            } else {
              current += letter;
            }
          }
          if (last || current !== "") array.push(current.trim());
          return array;
        }
      };
      module.exports = list3;
      list3.default = list3;
    }
  });

  // node_modules/postcss/lib/rule.js
  var require_rule = __commonJS({
    "node_modules/postcss/lib/rule.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var list3 = require_list();
      var Rule2 = class extends Container2 {
        get selectors() {
          return list3.comma(this.selector);
        }
        set selectors(values) {
          let match = this.selector ? this.selector.match(/,\s*/) : null;
          let sep = match ? match[0] : "," + this.raw("between", "beforeOpen");
          this.selector = values.join(sep);
        }
        constructor(defaults3) {
          super(defaults3);
          this.type = "rule";
          if (!this.nodes) this.nodes = [];
        }
      };
      module.exports = Rule2;
      Rule2.default = Rule2;
      Container2.registerRule(Rule2);
    }
  });

  // node_modules/postcss/lib/fromJSON.js
  var require_fromJSON = __commonJS({
    "node_modules/postcss/lib/fromJSON.js"(exports, module) {
      "use strict";
      var AtRule2 = require_at_rule();
      var Comment3 = require_comment();
      var Declaration2 = require_declaration();
      var Input2 = require_input();
      var PreviousMap = require_previous_map();
      var Root2 = require_root();
      var Rule2 = require_rule();
      function fromJSON2(json, inputs) {
        if (Array.isArray(json)) return json.map((n) => fromJSON2(n));
        let { inputs: ownInputs, ...defaults3 } = json;
        if (ownInputs) {
          inputs = [];
          for (let input of ownInputs) {
            let inputHydrated = { ...input, __proto__: Input2.prototype };
            if (inputHydrated.map) {
              inputHydrated.map = {
                ...inputHydrated.map,
                __proto__: PreviousMap.prototype
              };
            }
            inputs.push(inputHydrated);
          }
        }
        if (defaults3.nodes) {
          defaults3.nodes = json.nodes.map((n) => fromJSON2(n, inputs));
        }
        if (defaults3.source) {
          let { inputId, ...source2 } = defaults3.source;
          defaults3.source = source2;
          if (inputId != null) {
            defaults3.source.input = inputs[inputId];
          }
        }
        if (defaults3.type === "root") {
          return new Root2(defaults3);
        } else if (defaults3.type === "decl") {
          return new Declaration2(defaults3);
        } else if (defaults3.type === "rule") {
          return new Rule2(defaults3);
        } else if (defaults3.type === "comment") {
          return new Comment3(defaults3);
        } else if (defaults3.type === "atrule") {
          return new AtRule2(defaults3);
        } else {
          throw new Error("Unknown node type: " + json.type);
        }
      }
      module.exports = fromJSON2;
      fromJSON2.default = fromJSON2;
    }
  });

  // node_modules/postcss/lib/map-generator.js
  var require_map_generator = __commonJS({
    "node_modules/postcss/lib/map-generator.js"(exports, module) {
      "use strict";
      var { dirname, relative, resolve, sep } = require_path();
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { pathToFileURL } = require_url();
      var Input2 = require_input();
      var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
      var pathAvailable = Boolean(dirname && resolve && relative && sep);
      var MapGenerator = class {
        constructor(stringify2, root12, opts, cssString) {
          this.stringify = stringify2;
          this.mapOpts = opts.map || {};
          this.root = root12;
          this.opts = opts;
          this.css = cssString;
          this.originalCSS = cssString;
          this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
          this.memoizedFileURLs = /* @__PURE__ */ new Map();
          this.memoizedPaths = /* @__PURE__ */ new Map();
          this.memoizedURLs = /* @__PURE__ */ new Map();
        }
        addAnnotation() {
          let content;
          if (this.isInline()) {
            content = "data:application/json;base64," + this.toBase64(this.map.toString());
          } else if (typeof this.mapOpts.annotation === "string") {
            content = this.mapOpts.annotation;
          } else if (typeof this.mapOpts.annotation === "function") {
            content = this.mapOpts.annotation(this.opts.to, this.root);
          } else {
            content = this.outputFile() + ".map";
          }
          let eol = "\n";
          if (this.css.includes("\r\n")) eol = "\r\n";
          this.css += eol + "/*# sourceMappingURL=" + content + " */";
        }
        applyPrevMaps() {
          for (let prev of this.previous()) {
            let from = this.toUrl(this.path(prev.file));
            let root12 = prev.root || dirname(prev.file);
            let map;
            if (this.mapOpts.sourcesContent === false) {
              map = new SourceMapConsumer(prev.text);
              if (map.sourcesContent) {
                map.sourcesContent = null;
              }
            } else {
              map = prev.consumer();
            }
            this.map.applySourceMap(map, from, this.toUrl(this.path(root12)));
          }
        }
        clearAnnotation() {
          if (this.mapOpts.annotation === false) return;
          if (this.root) {
            let node;
            for (let i = this.root.nodes.length - 1; i >= 0; i--) {
              node = this.root.nodes[i];
              if (node.type !== "comment") continue;
              if (node.text.startsWith("# sourceMappingURL=")) {
                this.root.removeChild(i);
              }
            }
          } else if (this.css) {
            this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, "");
          }
        }
        generate() {
          this.clearAnnotation();
          if (pathAvailable && sourceMapAvailable && this.isMap()) {
            return this.generateMap();
          } else {
            let result = "";
            this.stringify(this.root, (i) => {
              result += i;
            });
            return [result];
          }
        }
        generateMap() {
          if (this.root) {
            this.generateString();
          } else if (this.previous().length === 1) {
            let prev = this.previous()[0].consumer();
            prev.file = this.outputFile();
            this.map = SourceMapGenerator.fromSourceMap(prev, {
              ignoreInvalidMapping: true
            });
          } else {
            this.map = new SourceMapGenerator({
              file: this.outputFile(),
              ignoreInvalidMapping: true
            });
            this.map.addMapping({
              generated: { column: 0, line: 1 },
              original: { column: 0, line: 1 },
              source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
            });
          }
          if (this.isSourcesContent()) this.setSourcesContent();
          if (this.root && this.previous().length > 0) this.applyPrevMaps();
          if (this.isAnnotation()) this.addAnnotation();
          if (this.isInline()) {
            return [this.css];
          } else {
            return [this.css, this.map];
          }
        }
        generateString() {
          this.css = "";
          this.map = new SourceMapGenerator({
            file: this.outputFile(),
            ignoreInvalidMapping: true
          });
          let line = 1;
          let column = 1;
          let noSource = "<no source>";
          let mapping = {
            generated: { column: 0, line: 0 },
            original: { column: 0, line: 0 },
            source: ""
          };
          let last, lines;
          this.stringify(this.root, (str, node, type) => {
            this.css += str;
            if (node && type !== "end") {
              mapping.generated.line = line;
              mapping.generated.column = column - 1;
              if (node.source && node.source.start) {
                mapping.source = this.sourcePath(node);
                mapping.original.line = node.source.start.line;
                mapping.original.column = node.source.start.column - 1;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                this.map.addMapping(mapping);
              }
            }
            lines = str.match(/\n/g);
            if (lines) {
              line += lines.length;
              last = str.lastIndexOf("\n");
              column = str.length - last;
            } else {
              column += str.length;
            }
            if (node && type !== "start") {
              let p = node.parent || { raws: {} };
              let childless = node.type === "decl" || node.type === "atrule" && !node.nodes;
              if (!childless || node !== p.last || p.raws.semicolon) {
                if (node.source && node.source.end) {
                  mapping.source = this.sourcePath(node);
                  mapping.original.line = node.source.end.line;
                  mapping.original.column = node.source.end.column - 1;
                  mapping.generated.line = line;
                  mapping.generated.column = column - 2;
                  this.map.addMapping(mapping);
                } else {
                  mapping.source = noSource;
                  mapping.original.line = 1;
                  mapping.original.column = 0;
                  mapping.generated.line = line;
                  mapping.generated.column = column - 1;
                  this.map.addMapping(mapping);
                }
              }
            }
          });
        }
        isAnnotation() {
          if (this.isInline()) {
            return true;
          }
          if (typeof this.mapOpts.annotation !== "undefined") {
            return this.mapOpts.annotation;
          }
          if (this.previous().length) {
            return this.previous().some((i) => i.annotation);
          }
          return true;
        }
        isInline() {
          if (typeof this.mapOpts.inline !== "undefined") {
            return this.mapOpts.inline;
          }
          let annotation = this.mapOpts.annotation;
          if (typeof annotation !== "undefined" && annotation !== true) {
            return false;
          }
          if (this.previous().length) {
            return this.previous().some((i) => i.inline);
          }
          return true;
        }
        isMap() {
          if (typeof this.opts.map !== "undefined") {
            return !!this.opts.map;
          }
          return this.previous().length > 0;
        }
        isSourcesContent() {
          if (typeof this.mapOpts.sourcesContent !== "undefined") {
            return this.mapOpts.sourcesContent;
          }
          if (this.previous().length) {
            return this.previous().some((i) => i.withContent());
          }
          return true;
        }
        outputFile() {
          if (this.opts.to) {
            return this.path(this.opts.to);
          } else if (this.opts.from) {
            return this.path(this.opts.from);
          } else {
            return "to.css";
          }
        }
        path(file) {
          if (this.mapOpts.absolute) return file;
          if (file.charCodeAt(0) === 60) return file;
          if (/^\w+:\/\//.test(file)) return file;
          let cached = this.memoizedPaths.get(file);
          if (cached) return cached;
          let from = this.opts.to ? dirname(this.opts.to) : ".";
          if (typeof this.mapOpts.annotation === "string") {
            from = dirname(resolve(from, this.mapOpts.annotation));
          }
          let path = relative(from, file);
          this.memoizedPaths.set(file, path);
          return path;
        }
        previous() {
          if (!this.previousMaps) {
            this.previousMaps = [];
            if (this.root) {
              this.root.walk((node) => {
                if (node.source && node.source.input.map) {
                  let map = node.source.input.map;
                  if (!this.previousMaps.includes(map)) {
                    this.previousMaps.push(map);
                  }
                }
              });
            } else {
              let input = new Input2(this.originalCSS, this.opts);
              if (input.map) this.previousMaps.push(input.map);
            }
          }
          return this.previousMaps;
        }
        setSourcesContent() {
          let already = {};
          if (this.root) {
            this.root.walk((node) => {
              if (node.source) {
                let from = node.source.input.from;
                if (from && !already[from]) {
                  already[from] = true;
                  let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
                  this.map.setSourceContent(fromUrl, node.source.input.css);
                }
              }
            });
          } else if (this.css) {
            let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
            this.map.setSourceContent(from, this.css);
          }
        }
        sourcePath(node) {
          if (this.mapOpts.from) {
            return this.toUrl(this.mapOpts.from);
          } else if (this.usesFileUrls) {
            return this.toFileUrl(node.source.input.from);
          } else {
            return this.toUrl(this.path(node.source.input.from));
          }
        }
        toBase64(str) {
          if (Buffer) {
            return Buffer.from(str).toString("base64");
          } else {
            return window.btoa(unescape(encodeURIComponent(str)));
          }
        }
        toFileUrl(path) {
          let cached = this.memoizedFileURLs.get(path);
          if (cached) return cached;
          if (pathToFileURL) {
            let fileURL = pathToFileURL(path).toString();
            this.memoizedFileURLs.set(path, fileURL);
            return fileURL;
          } else {
            throw new Error(
              "`map.absolute` option is not available in this PostCSS build"
            );
          }
        }
        toUrl(path) {
          let cached = this.memoizedURLs.get(path);
          if (cached) return cached;
          if (sep === "\\") {
            path = path.replace(/\\/g, "/");
          }
          let url2 = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
          this.memoizedURLs.set(path, url2);
          return url2;
        }
      };
      module.exports = MapGenerator;
    }
  });

  // node_modules/postcss/lib/tokenize.js
  var require_tokenize = __commonJS({
    "node_modules/postcss/lib/tokenize.js"(exports, module) {
      "use strict";
      var SINGLE_QUOTE = "'".charCodeAt(0);
      var DOUBLE_QUOTE = '"'.charCodeAt(0);
      var BACKSLASH = "\\".charCodeAt(0);
      var SLASH = "/".charCodeAt(0);
      var NEWLINE = "\n".charCodeAt(0);
      var SPACE3 = " ".charCodeAt(0);
      var FEED = "\f".charCodeAt(0);
      var TAB = "	".charCodeAt(0);
      var CR = "\r".charCodeAt(0);
      var OPEN_SQUARE = "[".charCodeAt(0);
      var CLOSE_SQUARE = "]".charCodeAt(0);
      var OPEN_PARENTHESES = "(".charCodeAt(0);
      var CLOSE_PARENTHESES = ")".charCodeAt(0);
      var OPEN_CURLY = "{".charCodeAt(0);
      var CLOSE_CURLY = "}".charCodeAt(0);
      var SEMICOLON = ";".charCodeAt(0);
      var ASTERISK = "*".charCodeAt(0);
      var COLON = ":".charCodeAt(0);
      var AT = "@".charCodeAt(0);
      var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
      var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
      var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
      var RE_HEX_ESCAPE = /[\da-f]/i;
      module.exports = function tokenizer(input, options = {}) {
        let css = input.css.valueOf();
        let ignore = options.ignoreErrors;
        let code, content, escape2, next2, quote;
        let currentToken, escaped, escapePos, n, prev;
        let length2 = css.length;
        let pos = 0;
        let buffer = [];
        let returned = [];
        function position2() {
          return pos;
        }
        function unclosed(what) {
          throw input.error("Unclosed " + what, pos);
        }
        function endOfFile() {
          return returned.length === 0 && pos >= length2;
        }
        function nextToken(opts) {
          if (returned.length) return returned.pop();
          if (pos >= length2) return;
          let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
          code = css.charCodeAt(pos);
          switch (code) {
            case NEWLINE:
            case SPACE3:
            case TAB:
            case CR:
            case FEED: {
              next2 = pos;
              do {
                next2 += 1;
                code = css.charCodeAt(next2);
              } while (code === SPACE3 || code === NEWLINE || code === TAB || code === CR || code === FEED);
              currentToken = ["space", css.slice(pos, next2)];
              pos = next2 - 1;
              break;
            }
            case OPEN_SQUARE:
            case CLOSE_SQUARE:
            case OPEN_CURLY:
            case CLOSE_CURLY:
            case COLON:
            case SEMICOLON:
            case CLOSE_PARENTHESES: {
              let controlChar = String.fromCharCode(code);
              currentToken = [controlChar, controlChar, pos];
              break;
            }
            case OPEN_PARENTHESES: {
              prev = buffer.length ? buffer.pop()[1] : "";
              n = css.charCodeAt(pos + 1);
              if (prev === "url" && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE3 && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
                next2 = pos;
                do {
                  escaped = false;
                  next2 = css.indexOf(")", next2 + 1);
                  if (next2 === -1) {
                    if (ignore || ignoreUnclosed) {
                      next2 = pos;
                      break;
                    } else {
                      unclosed("bracket");
                    }
                  }
                  escapePos = next2;
                  while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                    escapePos -= 1;
                    escaped = !escaped;
                  }
                } while (escaped);
                currentToken = ["brackets", css.slice(pos, next2 + 1), pos, next2];
                pos = next2;
              } else {
                next2 = css.indexOf(")", pos + 1);
                content = css.slice(pos, next2 + 1);
                if (next2 === -1 || RE_BAD_BRACKET.test(content)) {
                  currentToken = ["(", "(", pos];
                } else {
                  currentToken = ["brackets", content, pos, next2];
                  pos = next2;
                }
              }
              break;
            }
            case SINGLE_QUOTE:
            case DOUBLE_QUOTE: {
              quote = code === SINGLE_QUOTE ? "'" : '"';
              next2 = pos;
              do {
                escaped = false;
                next2 = css.indexOf(quote, next2 + 1);
                if (next2 === -1) {
                  if (ignore || ignoreUnclosed) {
                    next2 = pos + 1;
                    break;
                  } else {
                    unclosed("string");
                  }
                }
                escapePos = next2;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              currentToken = ["string", css.slice(pos, next2 + 1), pos, next2];
              pos = next2;
              break;
            }
            case AT: {
              RE_AT_END.lastIndex = pos + 1;
              RE_AT_END.test(css);
              if (RE_AT_END.lastIndex === 0) {
                next2 = css.length - 1;
              } else {
                next2 = RE_AT_END.lastIndex - 2;
              }
              currentToken = ["at-word", css.slice(pos, next2 + 1), pos, next2];
              pos = next2;
              break;
            }
            case BACKSLASH: {
              next2 = pos;
              escape2 = true;
              while (css.charCodeAt(next2 + 1) === BACKSLASH) {
                next2 += 1;
                escape2 = !escape2;
              }
              code = css.charCodeAt(next2 + 1);
              if (escape2 && code !== SLASH && code !== SPACE3 && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
                next2 += 1;
                if (RE_HEX_ESCAPE.test(css.charAt(next2))) {
                  while (RE_HEX_ESCAPE.test(css.charAt(next2 + 1))) {
                    next2 += 1;
                  }
                  if (css.charCodeAt(next2 + 1) === SPACE3) {
                    next2 += 1;
                  }
                }
              }
              currentToken = ["word", css.slice(pos, next2 + 1), pos, next2];
              pos = next2;
              break;
            }
            default: {
              if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
                next2 = css.indexOf("*/", pos + 2) + 1;
                if (next2 === 0) {
                  if (ignore || ignoreUnclosed) {
                    next2 = css.length;
                  } else {
                    unclosed("comment");
                  }
                }
                currentToken = ["comment", css.slice(pos, next2 + 1), pos, next2];
                pos = next2;
              } else {
                RE_WORD_END.lastIndex = pos + 1;
                RE_WORD_END.test(css);
                if (RE_WORD_END.lastIndex === 0) {
                  next2 = css.length - 1;
                } else {
                  next2 = RE_WORD_END.lastIndex - 2;
                }
                currentToken = ["word", css.slice(pos, next2 + 1), pos, next2];
                buffer.push(currentToken);
                pos = next2;
              }
              break;
            }
          }
          pos++;
          return currentToken;
        }
        function back(token) {
          returned.push(token);
        }
        return {
          back,
          endOfFile,
          nextToken,
          position: position2
        };
      };
    }
  });

  // node_modules/postcss/lib/parser.js
  var require_parser = __commonJS({
    "node_modules/postcss/lib/parser.js"(exports, module) {
      "use strict";
      var AtRule2 = require_at_rule();
      var Comment3 = require_comment();
      var Declaration2 = require_declaration();
      var Root2 = require_root();
      var Rule2 = require_rule();
      var tokenizer = require_tokenize();
      var SAFE_COMMENT_NEIGHBOR = {
        empty: true,
        space: true
      };
      function findLastWithPosition(tokens) {
        for (let i = tokens.length - 1; i >= 0; i--) {
          let token = tokens[i];
          let pos = token[3] || token[2];
          if (pos) return pos;
        }
      }
      var Parser = class {
        constructor(input) {
          this.input = input;
          this.root = new Root2();
          this.current = this.root;
          this.spaces = "";
          this.semicolon = false;
          this.createTokenizer();
          this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
        }
        atrule(token) {
          let node = new AtRule2();
          node.name = token[1].slice(1);
          if (node.name === "") {
            this.unnamedAtrule(node, token);
          }
          this.init(node, token[2]);
          let type;
          let prev;
          let shift;
          let last = false;
          let open = false;
          let params = [];
          let brackets = [];
          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();
            type = token[0];
            if (type === "(" || type === "[") {
              brackets.push(type === "(" ? ")" : "]");
            } else if (type === "{" && brackets.length > 0) {
              brackets.push("}");
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
            }
            if (brackets.length === 0) {
              if (type === ";") {
                node.source.end = this.getPosition(token[2]);
                node.source.end.offset++;
                this.semicolon = true;
                break;
              } else if (type === "{") {
                open = true;
                break;
              } else if (type === "}") {
                if (params.length > 0) {
                  shift = params.length - 1;
                  prev = params[shift];
                  while (prev && prev[0] === "space") {
                    prev = params[--shift];
                  }
                  if (prev) {
                    node.source.end = this.getPosition(prev[3] || prev[2]);
                    node.source.end.offset++;
                  }
                }
                this.end(token);
                break;
              } else {
                params.push(token);
              }
            } else {
              params.push(token);
            }
            if (this.tokenizer.endOfFile()) {
              last = true;
              break;
            }
          }
          node.raws.between = this.spacesAndCommentsFromEnd(params);
          if (params.length) {
            node.raws.afterName = this.spacesAndCommentsFromStart(params);
            this.raw(node, "params", params);
            if (last) {
              token = params[params.length - 1];
              node.source.end = this.getPosition(token[3] || token[2]);
              node.source.end.offset++;
              this.spaces = node.raws.between;
              node.raws.between = "";
            }
          } else {
            node.raws.afterName = "";
            node.params = "";
          }
          if (open) {
            node.nodes = [];
            this.current = node;
          }
        }
        checkMissedSemicolon(tokens) {
          let colon = this.colon(tokens);
          if (colon === false) return;
          let founded = 0;
          let token;
          for (let j = colon - 1; j >= 0; j--) {
            token = tokens[j];
            if (token[0] !== "space") {
              founded += 1;
              if (founded === 2) break;
            }
          }
          throw this.input.error(
            "Missed semicolon",
            token[0] === "word" ? token[3] + 1 : token[2]
          );
        }
        colon(tokens) {
          let brackets = 0;
          let prev, token, type;
          for (let [i, element2] of tokens.entries()) {
            token = element2;
            type = token[0];
            if (type === "(") {
              brackets += 1;
            }
            if (type === ")") {
              brackets -= 1;
            }
            if (brackets === 0 && type === ":") {
              if (!prev) {
                this.doubleColon(token);
              } else if (prev[0] === "word" && prev[1] === "progid") {
                continue;
              } else {
                return i;
              }
            }
            prev = token;
          }
          return false;
        }
        comment(token) {
          let node = new Comment3();
          this.init(node, token[2]);
          node.source.end = this.getPosition(token[3] || token[2]);
          node.source.end.offset++;
          let text2 = token[1].slice(2, -2);
          if (/^\s*$/.test(text2)) {
            node.text = "";
            node.raws.left = text2;
            node.raws.right = "";
          } else {
            let match = text2.match(/^(\s*)([^]*\S)(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
          }
        }
        createTokenizer() {
          this.tokenizer = tokenizer(this.input);
        }
        decl(tokens, customProperty) {
          let node = new Declaration2();
          this.init(node, tokens[0][2]);
          let last = tokens[tokens.length - 1];
          if (last[0] === ";") {
            this.semicolon = true;
            tokens.pop();
          }
          node.source.end = this.getPosition(
            last[3] || last[2] || findLastWithPosition(tokens)
          );
          node.source.end.offset++;
          while (tokens[0][0] !== "word") {
            if (tokens.length === 1) this.unknownWord(tokens);
            node.raws.before += tokens.shift()[1];
          }
          node.source.start = this.getPosition(tokens[0][2]);
          node.prop = "";
          while (tokens.length) {
            let type = tokens[0][0];
            if (type === ":" || type === "space" || type === "comment") {
              break;
            }
            node.prop += tokens.shift()[1];
          }
          node.raws.between = "";
          let token;
          while (tokens.length) {
            token = tokens.shift();
            if (token[0] === ":") {
              node.raws.between += token[1];
              break;
            } else {
              if (token[0] === "word" && /\w/.test(token[1])) {
                this.unknownWord([token]);
              }
              node.raws.between += token[1];
            }
          }
          if (node.prop[0] === "_" || node.prop[0] === "*") {
            node.raws.before += node.prop[0];
            node.prop = node.prop.slice(1);
          }
          let firstSpaces = [];
          let next2;
          while (tokens.length) {
            next2 = tokens[0][0];
            if (next2 !== "space" && next2 !== "comment") break;
            firstSpaces.push(tokens.shift());
          }
          this.precheckMissedSemicolon(tokens);
          for (let i = tokens.length - 1; i >= 0; i--) {
            token = tokens[i];
            if (token[1].toLowerCase() === "!important") {
              node.important = true;
              let string = this.stringFrom(tokens, i);
              string = this.spacesFromEnd(tokens) + string;
              if (string !== " !important") node.raws.important = string;
              break;
            } else if (token[1].toLowerCase() === "important") {
              let cache2 = tokens.slice(0);
              let str = "";
              for (let j = i; j > 0; j--) {
                let type = cache2[j][0];
                if (str.trim().startsWith("!") && type !== "space") {
                  break;
                }
                str = cache2.pop()[1] + str;
              }
              if (str.trim().startsWith("!")) {
                node.important = true;
                node.raws.important = str;
                tokens = cache2;
              }
            }
            if (token[0] !== "space" && token[0] !== "comment") {
              break;
            }
          }
          let hasWord = tokens.some((i) => i[0] !== "space" && i[0] !== "comment");
          if (hasWord) {
            node.raws.between += firstSpaces.map((i) => i[1]).join("");
            firstSpaces = [];
          }
          this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
          if (node.value.includes(":") && !customProperty) {
            this.checkMissedSemicolon(tokens);
          }
        }
        doubleColon(token) {
          throw this.input.error(
            "Double colon",
            { offset: token[2] },
            { offset: token[2] + token[1].length }
          );
        }
        emptyRule(token) {
          let node = new Rule2();
          this.init(node, token[2]);
          node.selector = "";
          node.raws.between = "";
          this.current = node;
        }
        end(token) {
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.semicolon = false;
          this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          this.spaces = "";
          if (this.current.parent) {
            this.current.source.end = this.getPosition(token[2]);
            this.current.source.end.offset++;
            this.current = this.current.parent;
          } else {
            this.unexpectedClose(token);
          }
        }
        endFile() {
          if (this.current.parent) this.unclosedBlock();
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          this.root.source.end = this.getPosition(this.tokenizer.position());
        }
        freeSemicolon(token) {
          this.spaces += token[1];
          if (this.current.nodes) {
            let prev = this.current.nodes[this.current.nodes.length - 1];
            if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
              prev.raws.ownSemicolon = this.spaces;
              this.spaces = "";
              prev.source.end = this.getPosition(token[2]);
              prev.source.end.offset += prev.raws.ownSemicolon.length;
            }
          }
        }
        // Helpers
        getPosition(offset) {
          let pos = this.input.fromOffset(offset);
          return {
            column: pos.col,
            line: pos.line,
            offset
          };
        }
        init(node, offset) {
          this.current.push(node);
          node.source = {
            input: this.input,
            start: this.getPosition(offset)
          };
          node.raws.before = this.spaces;
          this.spaces = "";
          if (node.type !== "comment") this.semicolon = false;
        }
        other(start) {
          let end = false;
          let type = null;
          let colon = false;
          let bracket = null;
          let brackets = [];
          let customProperty = start[1].startsWith("--");
          let tokens = [];
          let token = start;
          while (token) {
            type = token[0];
            tokens.push(token);
            if (type === "(" || type === "[") {
              if (!bracket) bracket = token;
              brackets.push(type === "(" ? ")" : "]");
            } else if (customProperty && colon && type === "{") {
              if (!bracket) bracket = token;
              brackets.push("}");
            } else if (brackets.length === 0) {
              if (type === ";") {
                if (colon) {
                  this.decl(tokens, customProperty);
                  return;
                } else {
                  break;
                }
              } else if (type === "{") {
                this.rule(tokens);
                return;
              } else if (type === "}") {
                this.tokenizer.back(tokens.pop());
                end = true;
                break;
              } else if (type === ":") {
                colon = true;
              }
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
              if (brackets.length === 0) bracket = null;
            }
            token = this.tokenizer.nextToken();
          }
          if (this.tokenizer.endOfFile()) end = true;
          if (brackets.length > 0) this.unclosedBracket(bracket);
          if (end && colon) {
            if (!customProperty) {
              while (tokens.length) {
                token = tokens[tokens.length - 1][0];
                if (token !== "space" && token !== "comment") break;
                this.tokenizer.back(tokens.pop());
              }
            }
            this.decl(tokens, customProperty);
          } else {
            this.unknownWord(tokens);
          }
        }
        parse() {
          let token;
          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();
            switch (token[0]) {
              case "space":
                this.spaces += token[1];
                break;
              case ";":
                this.freeSemicolon(token);
                break;
              case "}":
                this.end(token);
                break;
              case "comment":
                this.comment(token);
                break;
              case "at-word":
                this.atrule(token);
                break;
              case "{":
                this.emptyRule(token);
                break;
              default:
                this.other(token);
                break;
            }
          }
          this.endFile();
        }
        precheckMissedSemicolon() {
        }
        raw(node, prop2, tokens, customProperty) {
          let token, type;
          let length2 = tokens.length;
          let value2 = "";
          let clean = true;
          let next2, prev;
          for (let i = 0; i < length2; i += 1) {
            token = tokens[i];
            type = token[0];
            if (type === "space" && i === length2 - 1 && !customProperty) {
              clean = false;
            } else if (type === "comment") {
              prev = tokens[i - 1] ? tokens[i - 1][0] : "empty";
              next2 = tokens[i + 1] ? tokens[i + 1][0] : "empty";
              if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next2]) {
                if (value2.slice(-1) === ",") {
                  clean = false;
                } else {
                  value2 += token[1];
                }
              } else {
                clean = false;
              }
            } else {
              value2 += token[1];
            }
          }
          if (!clean) {
            let raw = tokens.reduce((all, i) => all + i[1], "");
            node.raws[prop2] = { raw, value: value2 };
          }
          node[prop2] = value2;
        }
        rule(tokens) {
          tokens.pop();
          let node = new Rule2();
          this.init(node, tokens[0][2]);
          node.raws.between = this.spacesAndCommentsFromEnd(tokens);
          this.raw(node, "selector", tokens);
          this.current = node;
        }
        spacesAndCommentsFromEnd(tokens) {
          let lastTokenType;
          let spaces = "";
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== "space" && lastTokenType !== "comment") break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }
        // Errors
        spacesAndCommentsFromStart(tokens) {
          let next2;
          let spaces = "";
          while (tokens.length) {
            next2 = tokens[0][0];
            if (next2 !== "space" && next2 !== "comment") break;
            spaces += tokens.shift()[1];
          }
          return spaces;
        }
        spacesFromEnd(tokens) {
          let lastTokenType;
          let spaces = "";
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== "space") break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }
        stringFrom(tokens, from) {
          let result = "";
          for (let i = from; i < tokens.length; i++) {
            result += tokens[i][1];
          }
          tokens.splice(from, tokens.length - from);
          return result;
        }
        unclosedBlock() {
          let pos = this.current.source.start;
          throw this.input.error("Unclosed block", pos.line, pos.column);
        }
        unclosedBracket(bracket) {
          throw this.input.error(
            "Unclosed bracket",
            { offset: bracket[2] },
            { offset: bracket[2] + 1 }
          );
        }
        unexpectedClose(token) {
          throw this.input.error(
            "Unexpected }",
            { offset: token[2] },
            { offset: token[2] + 1 }
          );
        }
        unknownWord(tokens) {
          throw this.input.error(
            "Unknown word " + tokens[0][1],
            { offset: tokens[0][2] },
            { offset: tokens[0][2] + tokens[0][1].length }
          );
        }
        unnamedAtrule(node, token) {
          throw this.input.error(
            "At-rule without name",
            { offset: token[2] },
            { offset: token[2] + token[1].length }
          );
        }
      };
      module.exports = Parser;
    }
  });

  // node_modules/postcss/lib/parse.js
  var require_parse = __commonJS({
    "node_modules/postcss/lib/parse.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var Input2 = require_input();
      var Parser = require_parser();
      function parse3(css, opts) {
        let input = new Input2(css, opts);
        let parser5 = new Parser(input);
        try {
          parser5.parse();
        } catch (e) {
          if (true) {
            if (e.name === "CssSyntaxError" && opts && opts.from) {
              if (/\.scss$/i.test(opts.from)) {
                e.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
              } else if (/\.sass/i.test(opts.from)) {
                e.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
              } else if (/\.less$/i.test(opts.from)) {
                e.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
              }
            }
          }
          throw e;
        }
        return parser5.root;
      }
      module.exports = parse3;
      parse3.default = parse3;
      Container2.registerParse(parse3);
    }
  });

  // node_modules/postcss/lib/warning.js
  var require_warning = __commonJS({
    "node_modules/postcss/lib/warning.js"(exports, module) {
      "use strict";
      var Warning2 = class {
        constructor(text2, opts = {}) {
          this.type = "warning";
          this.text = text2;
          if (opts.node && opts.node.source) {
            let range = opts.node.rangeBy(opts);
            this.line = range.start.line;
            this.column = range.start.column;
            this.endLine = range.end.line;
            this.endColumn = range.end.column;
          }
          for (let opt in opts) this[opt] = opts[opt];
        }
        toString() {
          if (this.node) {
            return this.node.error(this.text, {
              index: this.index,
              plugin: this.plugin,
              word: this.word
            }).message;
          }
          if (this.plugin) {
            return this.plugin + ": " + this.text;
          }
          return this.text;
        }
      };
      module.exports = Warning2;
      Warning2.default = Warning2;
    }
  });

  // node_modules/postcss/lib/result.js
  var require_result = __commonJS({
    "node_modules/postcss/lib/result.js"(exports, module) {
      "use strict";
      var Warning2 = require_warning();
      var Result2 = class {
        get content() {
          return this.css;
        }
        constructor(processor, root12, opts) {
          this.processor = processor;
          this.messages = [];
          this.root = root12;
          this.opts = opts;
          this.css = void 0;
          this.map = void 0;
        }
        toString() {
          return this.css;
        }
        warn(text2, opts = {}) {
          if (!opts.plugin) {
            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
              opts.plugin = this.lastPlugin.postcssPlugin;
            }
          }
          let warning = new Warning2(text2, opts);
          this.messages.push(warning);
          return warning;
        }
        warnings() {
          return this.messages.filter((i) => i.type === "warning");
        }
      };
      module.exports = Result2;
      Result2.default = Result2;
    }
  });

  // node_modules/postcss/lib/warn-once.js
  var require_warn_once = __commonJS({
    "node_modules/postcss/lib/warn-once.js"(exports, module) {
      "use strict";
      var printed = {};
      module.exports = function warnOnce(message) {
        if (printed[message]) return;
        printed[message] = true;
        if (typeof console !== "undefined" && console.warn) {
          console.warn(message);
        }
      };
    }
  });

  // node_modules/postcss/lib/lazy-result.js
  var require_lazy_result = __commonJS({
    "node_modules/postcss/lib/lazy-result.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var Document2 = require_document();
      var MapGenerator = require_map_generator();
      var parse3 = require_parse();
      var Result2 = require_result();
      var Root2 = require_root();
      var stringify2 = require_stringify();
      var { isClean, my } = require_symbols();
      var warnOnce = require_warn_once();
      var TYPE_TO_CLASS_NAME = {
        atrule: "AtRule",
        comment: "Comment",
        decl: "Declaration",
        document: "Document",
        root: "Root",
        rule: "Rule"
      };
      var PLUGIN_PROPS = {
        AtRule: true,
        AtRuleExit: true,
        Comment: true,
        CommentExit: true,
        Declaration: true,
        DeclarationExit: true,
        Document: true,
        DocumentExit: true,
        Once: true,
        OnceExit: true,
        postcssPlugin: true,
        prepare: true,
        Root: true,
        RootExit: true,
        Rule: true,
        RuleExit: true
      };
      var NOT_VISITORS = {
        Once: true,
        postcssPlugin: true,
        prepare: true
      };
      var CHILDREN = 0;
      function isPromise(obj) {
        return typeof obj === "object" && typeof obj.then === "function";
      }
      function getEvents(node) {
        let key = false;
        let type = TYPE_TO_CLASS_NAME[node.type];
        if (node.type === "decl") {
          key = node.prop.toLowerCase();
        } else if (node.type === "atrule") {
          key = node.name.toLowerCase();
        }
        if (key && node.append) {
          return [
            type,
            type + "-" + key,
            CHILDREN,
            type + "Exit",
            type + "Exit-" + key
          ];
        } else if (key) {
          return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
        } else if (node.append) {
          return [type, CHILDREN, type + "Exit"];
        } else {
          return [type, type + "Exit"];
        }
      }
      function toStack(node) {
        let events;
        if (node.type === "document") {
          events = ["Document", CHILDREN, "DocumentExit"];
        } else if (node.type === "root") {
          events = ["Root", CHILDREN, "RootExit"];
        } else {
          events = getEvents(node);
        }
        return {
          eventIndex: 0,
          events,
          iterator: 0,
          node,
          visitorIndex: 0,
          visitors: []
        };
      }
      function cleanMarks(node) {
        node[isClean] = false;
        if (node.nodes) node.nodes.forEach((i) => cleanMarks(i));
        return node;
      }
      var postcss2 = {};
      var LazyResult = class _LazyResult {
        get content() {
          return this.stringify().content;
        }
        get css() {
          return this.stringify().css;
        }
        get map() {
          return this.stringify().map;
        }
        get messages() {
          return this.sync().messages;
        }
        get opts() {
          return this.result.opts;
        }
        get processor() {
          return this.result.processor;
        }
        get root() {
          return this.sync().root;
        }
        get [Symbol.toStringTag]() {
          return "LazyResult";
        }
        constructor(processor, css, opts) {
          this.stringified = false;
          this.processed = false;
          let root12;
          if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
            root12 = cleanMarks(css);
          } else if (css instanceof _LazyResult || css instanceof Result2) {
            root12 = cleanMarks(css.root);
            if (css.map) {
              if (typeof opts.map === "undefined") opts.map = {};
              if (!opts.map.inline) opts.map.inline = false;
              opts.map.prev = css.map;
            }
          } else {
            let parser5 = parse3;
            if (opts.syntax) parser5 = opts.syntax.parse;
            if (opts.parser) parser5 = opts.parser;
            if (parser5.parse) parser5 = parser5.parse;
            try {
              root12 = parser5(css, opts);
            } catch (error) {
              this.processed = true;
              this.error = error;
            }
            if (root12 && !root12[my]) {
              Container2.rebuild(root12);
            }
          }
          this.result = new Result2(processor, root12, opts);
          this.helpers = { ...postcss2, postcss: postcss2, result: this.result };
          this.plugins = this.processor.plugins.map((plugin2) => {
            if (typeof plugin2 === "object" && plugin2.prepare) {
              return { ...plugin2, ...plugin2.prepare(this.result) };
            } else {
              return plugin2;
            }
          });
        }
        async() {
          if (this.error) return Promise.reject(this.error);
          if (this.processed) return Promise.resolve(this.result);
          if (!this.processing) {
            this.processing = this.runAsync();
          }
          return this.processing;
        }
        catch(onRejected) {
          return this.async().catch(onRejected);
        }
        finally(onFinally) {
          return this.async().then(onFinally, onFinally);
        }
        getAsyncError() {
          throw new Error("Use process(css).then(cb) to work with async plugins");
        }
        handleError(error, node) {
          let plugin2 = this.result.lastPlugin;
          try {
            if (node) node.addToError(error);
            this.error = error;
            if (error.name === "CssSyntaxError" && !error.plugin) {
              error.plugin = plugin2.postcssPlugin;
              error.setMessage();
            } else if (plugin2.postcssVersion) {
              if (true) {
                let pluginName = plugin2.postcssPlugin;
                let pluginVer = plugin2.postcssVersion;
                let runtimeVer = this.result.processor.version;
                let a = pluginVer.split(".");
                let b = runtimeVer.split(".");
                if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                  console.error(
                    "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
                  );
                }
              }
            }
          } catch (err) {
            if (console && console.error) console.error(err);
          }
          return error;
        }
        prepareVisitors() {
          this.listeners = {};
          let add = (plugin2, type, cb) => {
            if (!this.listeners[type]) this.listeners[type] = [];
            this.listeners[type].push([plugin2, cb]);
          };
          for (let plugin2 of this.plugins) {
            if (typeof plugin2 === "object") {
              for (let event2 in plugin2) {
                if (!PLUGIN_PROPS[event2] && /^[A-Z]/.test(event2)) {
                  throw new Error(
                    `Unknown event ${event2} in ${plugin2.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
                  );
                }
                if (!NOT_VISITORS[event2]) {
                  if (typeof plugin2[event2] === "object") {
                    for (let filter in plugin2[event2]) {
                      if (filter === "*") {
                        add(plugin2, event2, plugin2[event2][filter]);
                      } else {
                        add(
                          plugin2,
                          event2 + "-" + filter.toLowerCase(),
                          plugin2[event2][filter]
                        );
                      }
                    }
                  } else if (typeof plugin2[event2] === "function") {
                    add(plugin2, event2, plugin2[event2]);
                  }
                }
              }
            }
          }
          this.hasListener = Object.keys(this.listeners).length > 0;
        }
        async runAsync() {
          this.plugin = 0;
          for (let i = 0; i < this.plugins.length; i++) {
            let plugin2 = this.plugins[i];
            let promise = this.runOnRoot(plugin2);
            if (isPromise(promise)) {
              try {
                await promise;
              } catch (error) {
                throw this.handleError(error);
              }
            }
          }
          this.prepareVisitors();
          if (this.hasListener) {
            let root12 = this.result.root;
            while (!root12[isClean]) {
              root12[isClean] = true;
              let stack2 = [toStack(root12)];
              while (stack2.length > 0) {
                let promise = this.visitTick(stack2);
                if (isPromise(promise)) {
                  try {
                    await promise;
                  } catch (e) {
                    let node = stack2[stack2.length - 1].node;
                    throw this.handleError(e, node);
                  }
                }
              }
            }
            if (this.listeners.OnceExit) {
              for (let [plugin2, visitor] of this.listeners.OnceExit) {
                this.result.lastPlugin = plugin2;
                try {
                  if (root12.type === "document") {
                    let roots = root12.nodes.map(
                      (subRoot) => visitor(subRoot, this.helpers)
                    );
                    await Promise.all(roots);
                  } else {
                    await visitor(root12, this.helpers);
                  }
                } catch (e) {
                  throw this.handleError(e);
                }
              }
            }
          }
          this.processed = true;
          return this.stringify();
        }
        runOnRoot(plugin2) {
          this.result.lastPlugin = plugin2;
          try {
            if (typeof plugin2 === "object" && plugin2.Once) {
              if (this.result.root.type === "document") {
                let roots = this.result.root.nodes.map(
                  (root12) => plugin2.Once(root12, this.helpers)
                );
                if (isPromise(roots[0])) {
                  return Promise.all(roots);
                }
                return roots;
              }
              return plugin2.Once(this.result.root, this.helpers);
            } else if (typeof plugin2 === "function") {
              return plugin2(this.result.root, this.result);
            }
          } catch (error) {
            throw this.handleError(error);
          }
        }
        stringify() {
          if (this.error) throw this.error;
          if (this.stringified) return this.result;
          this.stringified = true;
          this.sync();
          let opts = this.result.opts;
          let str = stringify2;
          if (opts.syntax) str = opts.syntax.stringify;
          if (opts.stringifier) str = opts.stringifier;
          if (str.stringify) str = str.stringify;
          let map = new MapGenerator(str, this.result.root, this.result.opts);
          let data = map.generate();
          this.result.css = data[0];
          this.result.map = data[1];
          return this.result;
        }
        sync() {
          if (this.error) throw this.error;
          if (this.processed) return this.result;
          this.processed = true;
          if (this.processing) {
            throw this.getAsyncError();
          }
          for (let plugin2 of this.plugins) {
            let promise = this.runOnRoot(plugin2);
            if (isPromise(promise)) {
              throw this.getAsyncError();
            }
          }
          this.prepareVisitors();
          if (this.hasListener) {
            let root12 = this.result.root;
            while (!root12[isClean]) {
              root12[isClean] = true;
              this.walkSync(root12);
            }
            if (this.listeners.OnceExit) {
              if (root12.type === "document") {
                for (let subRoot of root12.nodes) {
                  this.visitSync(this.listeners.OnceExit, subRoot);
                }
              } else {
                this.visitSync(this.listeners.OnceExit, root12);
              }
            }
          }
          return this.result;
        }
        then(onFulfilled, onRejected) {
          if (true) {
            if (!("from" in this.opts)) {
              warnOnce(
                "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
              );
            }
          }
          return this.async().then(onFulfilled, onRejected);
        }
        toString() {
          return this.css;
        }
        visitSync(visitors, node) {
          for (let [plugin2, visitor] of visitors) {
            this.result.lastPlugin = plugin2;
            let promise;
            try {
              promise = visitor(node, this.helpers);
            } catch (e) {
              throw this.handleError(e, node.proxyOf);
            }
            if (node.type !== "root" && node.type !== "document" && !node.parent) {
              return true;
            }
            if (isPromise(promise)) {
              throw this.getAsyncError();
            }
          }
        }
        visitTick(stack2) {
          let visit = stack2[stack2.length - 1];
          let { node, visitors } = visit;
          if (node.type !== "root" && node.type !== "document" && !node.parent) {
            stack2.pop();
            return;
          }
          if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
            let [plugin2, visitor] = visitors[visit.visitorIndex];
            visit.visitorIndex += 1;
            if (visit.visitorIndex === visitors.length) {
              visit.visitors = [];
              visit.visitorIndex = 0;
            }
            this.result.lastPlugin = plugin2;
            try {
              return visitor(node.toProxy(), this.helpers);
            } catch (e) {
              throw this.handleError(e, node);
            }
          }
          if (visit.iterator !== 0) {
            let iterator = visit.iterator;
            let child2;
            while (child2 = node.nodes[node.indexes[iterator]]) {
              node.indexes[iterator] += 1;
              if (!child2[isClean]) {
                child2[isClean] = true;
                stack2.push(toStack(child2));
                return;
              }
            }
            visit.iterator = 0;
            delete node.indexes[iterator];
          }
          let events = visit.events;
          while (visit.eventIndex < events.length) {
            let event2 = events[visit.eventIndex];
            visit.eventIndex += 1;
            if (event2 === CHILDREN) {
              if (node.nodes && node.nodes.length) {
                node[isClean] = true;
                visit.iterator = node.getIterator();
              }
              return;
            } else if (this.listeners[event2]) {
              visit.visitors = this.listeners[event2];
              return;
            }
          }
          stack2.pop();
        }
        walkSync(node) {
          node[isClean] = true;
          let events = getEvents(node);
          for (let event2 of events) {
            if (event2 === CHILDREN) {
              if (node.nodes) {
                node.each((child2) => {
                  if (!child2[isClean]) this.walkSync(child2);
                });
              }
            } else {
              let visitors = this.listeners[event2];
              if (visitors) {
                if (this.visitSync(visitors, node.toProxy())) return;
              }
            }
          }
        }
        warnings() {
          return this.sync().warnings();
        }
      };
      LazyResult.registerPostcss = (dependant) => {
        postcss2 = dependant;
      };
      module.exports = LazyResult;
      LazyResult.default = LazyResult;
      Root2.registerLazyResult(LazyResult);
      Document2.registerLazyResult(LazyResult);
    }
  });

  // node_modules/postcss/lib/no-work-result.js
  var require_no_work_result = __commonJS({
    "node_modules/postcss/lib/no-work-result.js"(exports, module) {
      "use strict";
      var MapGenerator = require_map_generator();
      var parse3 = require_parse();
      var Result2 = require_result();
      var stringify2 = require_stringify();
      var warnOnce = require_warn_once();
      var NoWorkResult = class {
        get content() {
          return this.result.css;
        }
        get css() {
          return this.result.css;
        }
        get map() {
          return this.result.map;
        }
        get messages() {
          return [];
        }
        get opts() {
          return this.result.opts;
        }
        get processor() {
          return this.result.processor;
        }
        get root() {
          if (this._root) {
            return this._root;
          }
          let root12;
          let parser5 = parse3;
          try {
            root12 = parser5(this._css, this._opts);
          } catch (error) {
            this.error = error;
          }
          if (this.error) {
            throw this.error;
          } else {
            this._root = root12;
            return root12;
          }
        }
        get [Symbol.toStringTag]() {
          return "NoWorkResult";
        }
        constructor(processor, css, opts) {
          css = css.toString();
          this.stringified = false;
          this._processor = processor;
          this._css = css;
          this._opts = opts;
          this._map = void 0;
          let root12;
          let str = stringify2;
          this.result = new Result2(this._processor, root12, this._opts);
          this.result.css = css;
          let self2 = this;
          Object.defineProperty(this.result, "root", {
            get() {
              return self2.root;
            }
          });
          let map = new MapGenerator(str, root12, this._opts, css);
          if (map.isMap()) {
            let [generatedCSS, generatedMap] = map.generate();
            if (generatedCSS) {
              this.result.css = generatedCSS;
            }
            if (generatedMap) {
              this.result.map = generatedMap;
            }
          } else {
            map.clearAnnotation();
            this.result.css = map.css;
          }
        }
        async() {
          if (this.error) return Promise.reject(this.error);
          return Promise.resolve(this.result);
        }
        catch(onRejected) {
          return this.async().catch(onRejected);
        }
        finally(onFinally) {
          return this.async().then(onFinally, onFinally);
        }
        sync() {
          if (this.error) throw this.error;
          return this.result;
        }
        then(onFulfilled, onRejected) {
          if (true) {
            if (!("from" in this._opts)) {
              warnOnce(
                "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
              );
            }
          }
          return this.async().then(onFulfilled, onRejected);
        }
        toString() {
          return this._css;
        }
        warnings() {
          return [];
        }
      };
      module.exports = NoWorkResult;
      NoWorkResult.default = NoWorkResult;
    }
  });

  // node_modules/postcss/lib/processor.js
  var require_processor = __commonJS({
    "node_modules/postcss/lib/processor.js"(exports, module) {
      "use strict";
      var Document2 = require_document();
      var LazyResult = require_lazy_result();
      var NoWorkResult = require_no_work_result();
      var Root2 = require_root();
      var Processor2 = class {
        constructor(plugins = []) {
          this.version = "8.5.3";
          this.plugins = this.normalize(plugins);
        }
        normalize(plugins) {
          let normalized = [];
          for (let i of plugins) {
            if (i.postcss === true) {
              i = i();
            } else if (i.postcss) {
              i = i.postcss;
            }
            if (typeof i === "object" && Array.isArray(i.plugins)) {
              normalized = normalized.concat(i.plugins);
            } else if (typeof i === "object" && i.postcssPlugin) {
              normalized.push(i);
            } else if (typeof i === "function") {
              normalized.push(i);
            } else if (typeof i === "object" && (i.parse || i.stringify)) {
              if (true) {
                throw new Error(
                  "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
                );
              }
            } else {
              throw new Error(i + " is not a PostCSS plugin");
            }
          }
          return normalized;
        }
        process(css, opts = {}) {
          if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
            return new NoWorkResult(this, css, opts);
          } else {
            return new LazyResult(this, css, opts);
          }
        }
        use(plugin2) {
          this.plugins = this.plugins.concat(this.normalize([plugin2]));
          return this;
        }
      };
      module.exports = Processor2;
      Processor2.default = Processor2;
      Root2.registerProcessor(Processor2);
      Document2.registerProcessor(Processor2);
    }
  });

  // node_modules/postcss/lib/postcss.js
  var require_postcss = __commonJS({
    "node_modules/postcss/lib/postcss.js"(exports, module) {
      "use strict";
      var AtRule2 = require_at_rule();
      var Comment3 = require_comment();
      var Container2 = require_container();
      var CssSyntaxError2 = require_css_syntax_error();
      var Declaration2 = require_declaration();
      var Document2 = require_document();
      var fromJSON2 = require_fromJSON();
      var Input2 = require_input();
      var LazyResult = require_lazy_result();
      var list3 = require_list();
      var Node3 = require_node();
      var parse3 = require_parse();
      var Processor2 = require_processor();
      var Result2 = require_result();
      var Root2 = require_root();
      var Rule2 = require_rule();
      var stringify2 = require_stringify();
      var Warning2 = require_warning();
      function postcss2(...plugins) {
        if (plugins.length === 1 && Array.isArray(plugins[0])) {
          plugins = plugins[0];
        }
        return new Processor2(plugins);
      }
      postcss2.plugin = function plugin2(name, initializer) {
        let warningPrinted = false;
        function creator(...args) {
          if (console && console.warn && !warningPrinted) {
            warningPrinted = true;
            console.warn(
              name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
            );
            if (process.env.LANG && process.env.LANG.startsWith("cn")) {
              console.warn(
                name + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226"
              );
            }
          }
          let transformer = initializer(...args);
          transformer.postcssPlugin = name;
          transformer.postcssVersion = new Processor2().version;
          return transformer;
        }
        let cache2;
        Object.defineProperty(creator, "postcss", {
          get() {
            if (!cache2) cache2 = creator();
            return cache2;
          }
        });
        creator.process = function(css, processOpts, pluginOpts) {
          return postcss2([creator(pluginOpts)]).process(css, processOpts);
        };
        return creator;
      };
      postcss2.stringify = stringify2;
      postcss2.parse = parse3;
      postcss2.fromJSON = fromJSON2;
      postcss2.list = list3;
      postcss2.comment = (defaults3) => new Comment3(defaults3);
      postcss2.atRule = (defaults3) => new AtRule2(defaults3);
      postcss2.decl = (defaults3) => new Declaration2(defaults3);
      postcss2.rule = (defaults3) => new Rule2(defaults3);
      postcss2.root = (defaults3) => new Root2(defaults3);
      postcss2.document = (defaults3) => new Document2(defaults3);
      postcss2.CssSyntaxError = CssSyntaxError2;
      postcss2.Declaration = Declaration2;
      postcss2.Container = Container2;
      postcss2.Processor = Processor2;
      postcss2.Document = Document2;
      postcss2.Comment = Comment3;
      postcss2.Warning = Warning2;
      postcss2.AtRule = AtRule2;
      postcss2.Result = Result2;
      postcss2.Input = Input2;
      postcss2.Rule = Rule2;
      postcss2.Root = Root2;
      postcss2.Node = Node3;
      LazyResult.registerPostcss(postcss2);
      module.exports = postcss2;
      postcss2.default = postcss2;
    }
  });

  // node_modules/postcss-selector-parser/dist/util/unesc.js
  var require_unesc = __commonJS({
    "node_modules/postcss-selector-parser/dist/util/unesc.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = unesc;
      function gobbleHex(str) {
        var lower = str.toLowerCase();
        var hex = "";
        var spaceTerminated = false;
        for (var i = 0; i < 6 && lower[i] !== void 0; i++) {
          var code = lower.charCodeAt(i);
          var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
          spaceTerminated = code === 32;
          if (!valid) {
            break;
          }
          hex += lower[i];
        }
        if (hex.length === 0) {
          return void 0;
        }
        var codePoint = parseInt(hex, 16);
        var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
        if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
          return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
        }
        return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
      }
      var CONTAINS_ESCAPE = /\\/;
      function unesc(str) {
        var needToProcess = CONTAINS_ESCAPE.test(str);
        if (!needToProcess) {
          return str;
        }
        var ret = "";
        for (var i = 0; i < str.length; i++) {
          if (str[i] === "\\") {
            var gobbled = gobbleHex(str.slice(i + 1, i + 7));
            if (gobbled !== void 0) {
              ret += gobbled[0];
              i += gobbled[1];
              continue;
            }
            if (str[i + 1] === "\\") {
              ret += "\\";
              i++;
              continue;
            }
            if (str.length === i + 1) {
              ret += str[i];
            }
            continue;
          }
          ret += str[i];
        }
        return ret;
      }
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/util/getProp.js
  var require_getProp = __commonJS({
    "node_modules/postcss-selector-parser/dist/util/getProp.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = getProp;
      function getProp(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }
        while (props.length > 0) {
          var prop2 = props.shift();
          if (!obj[prop2]) {
            return void 0;
          }
          obj = obj[prop2];
        }
        return obj;
      }
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/util/ensureObject.js
  var require_ensureObject = __commonJS({
    "node_modules/postcss-selector-parser/dist/util/ensureObject.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = ensureObject;
      function ensureObject(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }
        while (props.length > 0) {
          var prop2 = props.shift();
          if (!obj[prop2]) {
            obj[prop2] = {};
          }
          obj = obj[prop2];
        }
      }
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/util/stripComments.js
  var require_stripComments = __commonJS({
    "node_modules/postcss-selector-parser/dist/util/stripComments.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = stripComments;
      function stripComments(str) {
        var s = "";
        var commentStart = str.indexOf("/*");
        var lastEnd = 0;
        while (commentStart >= 0) {
          s = s + str.slice(lastEnd, commentStart);
          var commentEnd = str.indexOf("*/", commentStart + 2);
          if (commentEnd < 0) {
            return s;
          }
          lastEnd = commentEnd + 2;
          commentStart = str.indexOf("/*", lastEnd);
        }
        s = s + str.slice(lastEnd);
        return s;
      }
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/util/index.js
  var require_util = __commonJS({
    "node_modules/postcss-selector-parser/dist/util/index.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.unesc = exports.stripComments = exports.getProp = exports.ensureObject = void 0;
      var _unesc = _interopRequireDefault(require_unesc());
      exports.unesc = _unesc["default"];
      var _getProp = _interopRequireDefault(require_getProp());
      exports.getProp = _getProp["default"];
      var _ensureObject = _interopRequireDefault(require_ensureObject());
      exports.ensureObject = _ensureObject["default"];
      var _stripComments = _interopRequireDefault(require_stripComments());
      exports.stripComments = _stripComments["default"];
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/node.js
  var require_node2 = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/node.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _util = require_util();
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var cloneNode = function cloneNode2(obj, parent) {
        if (typeof obj !== "object" || obj === null) {
          return obj;
        }
        var cloned = new obj.constructor();
        for (var i in obj) {
          if (!obj.hasOwnProperty(i)) {
            continue;
          }
          var value2 = obj[i];
          var type = typeof value2;
          if (i === "parent" && type === "object") {
            if (parent) {
              cloned[i] = parent;
            }
          } else if (value2 instanceof Array) {
            cloned[i] = value2.map(function(j) {
              return cloneNode2(j, cloned);
            });
          } else {
            cloned[i] = cloneNode2(value2, cloned);
          }
        }
        return cloned;
      };
      var Node3 = /* @__PURE__ */ function() {
        function Node4(opts) {
          if (opts === void 0) {
            opts = {};
          }
          Object.assign(this, opts);
          this.spaces = this.spaces || {};
          this.spaces.before = this.spaces.before || "";
          this.spaces.after = this.spaces.after || "";
        }
        var _proto = Node4.prototype;
        _proto.remove = function remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = void 0;
          return this;
        };
        _proto.replaceWith = function replaceWith() {
          if (this.parent) {
            for (var index5 in arguments) {
              this.parent.insertBefore(this, arguments[index5]);
            }
            this.remove();
          }
          return this;
        };
        _proto.next = function next2() {
          return this.parent.at(this.parent.index(this) + 1);
        };
        _proto.prev = function prev() {
          return this.parent.at(this.parent.index(this) - 1);
        };
        _proto.clone = function clone(overrides) {
          if (overrides === void 0) {
            overrides = {};
          }
          var cloned = cloneNode(this);
          for (var name in overrides) {
            cloned[name] = overrides[name];
          }
          return cloned;
        };
        _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value2, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }
          var originalValue = this[name];
          var originalEscaped = this.raws[name];
          this[name] = originalValue + value2;
          if (originalEscaped || valueEscaped !== value2) {
            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
          } else {
            delete this.raws[name];
          }
        };
        _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value2, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }
          this[name] = value2;
          this.raws[name] = valueEscaped;
        };
        _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value2) {
          this[name] = value2;
          if (this.raws) {
            delete this.raws[name];
          }
        };
        _proto.isAtPosition = function isAtPosition(line, column) {
          if (this.source && this.source.start && this.source.end) {
            if (this.source.start.line > line) {
              return false;
            }
            if (this.source.end.line < line) {
              return false;
            }
            if (this.source.start.line === line && this.source.start.column > column) {
              return false;
            }
            if (this.source.end.line === line && this.source.end.column < column) {
              return false;
            }
            return true;
          }
          return void 0;
        };
        _proto.stringifyProperty = function stringifyProperty(name) {
          return this.raws && this.raws[name] || this[name];
        };
        _proto.valueToString = function valueToString() {
          return String(this.stringifyProperty("value"));
        };
        _proto.toString = function toString() {
          return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
        };
        _createClass(Node4, [{
          key: "rawSpaceBefore",
          get: function get3() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
            if (rawSpace === void 0) {
              rawSpace = this.spaces && this.spaces.before;
            }
            return rawSpace || "";
          },
          set: function set2(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.before = raw;
          }
        }, {
          key: "rawSpaceAfter",
          get: function get3() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
            if (rawSpace === void 0) {
              rawSpace = this.spaces.after;
            }
            return rawSpace || "";
          },
          set: function set2(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.after = raw;
          }
        }]);
        return Node4;
      }();
      exports["default"] = Node3;
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/types.js
  var require_types = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/types.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.UNIVERSAL = exports.TAG = exports.STRING = exports.SELECTOR = exports.ROOT = exports.PSEUDO = exports.NESTING = exports.ID = exports.COMMENT = exports.COMBINATOR = exports.CLASS = exports.ATTRIBUTE = void 0;
      var TAG = "tag";
      exports.TAG = TAG;
      var STRING = "string";
      exports.STRING = STRING;
      var SELECTOR = "selector";
      exports.SELECTOR = SELECTOR;
      var ROOT = "root";
      exports.ROOT = ROOT;
      var PSEUDO = "pseudo";
      exports.PSEUDO = PSEUDO;
      var NESTING = "nesting";
      exports.NESTING = NESTING;
      var ID = "id";
      exports.ID = ID;
      var COMMENT = "comment";
      exports.COMMENT = COMMENT;
      var COMBINATOR = "combinator";
      exports.COMBINATOR = COMBINATOR;
      var CLASS2 = "class";
      exports.CLASS = CLASS2;
      var ATTRIBUTE = "attribute";
      exports.ATTRIBUTE = ATTRIBUTE;
      var UNIVERSAL = "universal";
      exports.UNIVERSAL = UNIVERSAL;
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/container.js
  var require_container2 = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/container.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var types2 = _interopRequireWildcard(require_types());
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (it) return (it = it.call(o)).next.bind(it);
        if (Array.isArray(o) || (it = _unsupportedIterableToArray3(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          return function() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray3(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray3(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray3(o, minLen);
      }
      function _arrayLikeToArray3(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Container2 = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Container3, _Node);
        function Container3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          if (!_this.nodes) {
            _this.nodes = [];
          }
          return _this;
        }
        var _proto = Container3.prototype;
        _proto.append = function append2(selector) {
          selector.parent = this;
          this.nodes.push(selector);
          return this;
        };
        _proto.prepend = function prepend(selector) {
          selector.parent = this;
          this.nodes.unshift(selector);
          return this;
        };
        _proto.at = function at(index5) {
          return this.nodes[index5];
        };
        _proto.index = function index5(child2) {
          if (typeof child2 === "number") {
            return child2;
          }
          return this.nodes.indexOf(child2);
        };
        _proto.removeChild = function removeChild(child2) {
          child2 = this.index(child2);
          this.at(child2).parent = void 0;
          this.nodes.splice(child2, 1);
          var index5;
          for (var id in this.indexes) {
            index5 = this.indexes[id];
            if (index5 >= child2) {
              this.indexes[id] = index5 - 1;
            }
          }
          return this;
        };
        _proto.removeAll = function removeAll() {
          for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
            var node = _step.value;
            node.parent = void 0;
          }
          this.nodes = [];
          return this;
        };
        _proto.empty = function empty() {
          return this.removeAll();
        };
        _proto.insertAfter = function insertAfter(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex + 1, 0, newNode);
          newNode.parent = this;
          var index5;
          for (var id in this.indexes) {
            index5 = this.indexes[id];
            if (oldIndex <= index5) {
              this.indexes[id] = index5 + 1;
            }
          }
          return this;
        };
        _proto.insertBefore = function insertBefore(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex, 0, newNode);
          newNode.parent = this;
          var index5;
          for (var id in this.indexes) {
            index5 = this.indexes[id];
            if (index5 <= oldIndex) {
              this.indexes[id] = index5 + 1;
            }
          }
          return this;
        };
        _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
          var found = void 0;
          this.each(function(node) {
            if (node.atPosition) {
              var foundChild = node.atPosition(line, col);
              if (foundChild) {
                found = foundChild;
                return false;
              }
            } else if (node.isAtPosition(line, col)) {
              found = node;
              return false;
            }
          });
          return found;
        };
        _proto.atPosition = function atPosition(line, col) {
          if (this.isAtPosition(line, col)) {
            return this._findChildAtPosition(line, col) || this;
          } else {
            return void 0;
          }
        };
        _proto._inferEndPosition = function _inferEndPosition() {
          if (this.last && this.last.source && this.last.source.end) {
            this.source = this.source || {};
            this.source.end = this.source.end || {};
            Object.assign(this.source.end, this.last.source.end);
          }
        };
        _proto.each = function each2(callback) {
          if (!this.lastEach) {
            this.lastEach = 0;
          }
          if (!this.indexes) {
            this.indexes = {};
          }
          this.lastEach++;
          var id = this.lastEach;
          this.indexes[id] = 0;
          if (!this.length) {
            return void 0;
          }
          var index5, result;
          while (this.indexes[id] < this.length) {
            index5 = this.indexes[id];
            result = callback(this.at(index5), index5);
            if (result === false) {
              break;
            }
            this.indexes[id] += 1;
          }
          delete this.indexes[id];
          if (result === false) {
            return false;
          }
        };
        _proto.walk = function walk(callback) {
          return this.each(function(node, i) {
            var result = callback(node, i);
            if (result !== false && node.length) {
              result = node.walk(callback);
            }
            if (result === false) {
              return false;
            }
          });
        };
        _proto.walkAttributes = function walkAttributes(callback) {
          var _this2 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.ATTRIBUTE) {
              return callback.call(_this2, selector);
            }
          });
        };
        _proto.walkClasses = function walkClasses(callback) {
          var _this3 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.CLASS) {
              return callback.call(_this3, selector);
            }
          });
        };
        _proto.walkCombinators = function walkCombinators(callback) {
          var _this4 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.COMBINATOR) {
              return callback.call(_this4, selector);
            }
          });
        };
        _proto.walkComments = function walkComments(callback) {
          var _this5 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.COMMENT) {
              return callback.call(_this5, selector);
            }
          });
        };
        _proto.walkIds = function walkIds(callback) {
          var _this6 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.ID) {
              return callback.call(_this6, selector);
            }
          });
        };
        _proto.walkNesting = function walkNesting(callback) {
          var _this7 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.NESTING) {
              return callback.call(_this7, selector);
            }
          });
        };
        _proto.walkPseudos = function walkPseudos(callback) {
          var _this8 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.PSEUDO) {
              return callback.call(_this8, selector);
            }
          });
        };
        _proto.walkTags = function walkTags(callback) {
          var _this9 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.TAG) {
              return callback.call(_this9, selector);
            }
          });
        };
        _proto.walkUniversals = function walkUniversals(callback) {
          var _this10 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.UNIVERSAL) {
              return callback.call(_this10, selector);
            }
          });
        };
        _proto.split = function split(callback) {
          var _this11 = this;
          var current = [];
          return this.reduce(function(memo, node, index5) {
            var split2 = callback.call(_this11, node);
            current.push(node);
            if (split2) {
              memo.push(current);
              current = [];
            } else if (index5 === _this11.length - 1) {
              memo.push(current);
            }
            return memo;
          }, []);
        };
        _proto.map = function map(callback) {
          return this.nodes.map(callback);
        };
        _proto.reduce = function reduce(callback, memo) {
          return this.nodes.reduce(callback, memo);
        };
        _proto.every = function every(callback) {
          return this.nodes.every(callback);
        };
        _proto.some = function some(callback) {
          return this.nodes.some(callback);
        };
        _proto.filter = function filter(callback) {
          return this.nodes.filter(callback);
        };
        _proto.sort = function sort(callback) {
          return this.nodes.sort(callback);
        };
        _proto.toString = function toString() {
          return this.map(String).join("");
        };
        _createClass(Container3, [{
          key: "first",
          get: function get3() {
            return this.at(0);
          }
        }, {
          key: "last",
          get: function get3() {
            return this.at(this.length - 1);
          }
        }, {
          key: "length",
          get: function get3() {
            return this.nodes.length;
          }
        }]);
        return Container3;
      }(_node["default"]);
      exports["default"] = Container2;
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/root.js
  var require_root2 = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/root.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _container = _interopRequireDefault(require_container2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Root2 = /* @__PURE__ */ function(_Container) {
        _inheritsLoose(Root3, _Container);
        function Root3(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types.ROOT;
          return _this;
        }
        var _proto = Root3.prototype;
        _proto.toString = function toString() {
          var str = this.reduce(function(memo, selector) {
            memo.push(String(selector));
            return memo;
          }, []).join(",");
          return this.trailingComma ? str + "," : str;
        };
        _proto.error = function error(message, options) {
          if (this._error) {
            return this._error(message, options);
          } else {
            return new Error(message);
          }
        };
        _createClass(Root3, [{
          key: "errorGenerator",
          set: function set2(handler) {
            this._error = handler;
          }
        }]);
        return Root3;
      }(_container["default"]);
      exports["default"] = Root2;
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/selector.js
  var require_selector = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/selector.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _container = _interopRequireDefault(require_container2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Selector = /* @__PURE__ */ function(_Container) {
        _inheritsLoose(Selector2, _Container);
        function Selector2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types.SELECTOR;
          return _this;
        }
        return Selector2;
      }(_container["default"]);
      exports["default"] = Selector;
      module.exports = exports.default;
    }
  });

  // node_modules/cssesc/cssesc.js
  var require_cssesc = __commonJS({
    "node_modules/cssesc/cssesc.js"(exports, module) {
      "use strict";
      var object = {};
      var hasOwnProperty3 = object.hasOwnProperty;
      var merge3 = function merge4(options, defaults3) {
        if (!options) {
          return defaults3;
        }
        var result = {};
        for (var key in defaults3) {
          result[key] = hasOwnProperty3.call(options, key) ? options[key] : defaults3[key];
        }
        return result;
      };
      var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
      var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
      var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
      var cssesc = function cssesc2(string, options) {
        options = merge3(options, cssesc2.options);
        if (options.quotes != "single" && options.quotes != "double") {
          options.quotes = "single";
        }
        var quote = options.quotes == "double" ? '"' : "'";
        var isIdentifier = options.isIdentifier;
        var firstChar = string.charAt(0);
        var output = "";
        var counter = 0;
        var length2 = string.length;
        while (counter < length2) {
          var character = string.charAt(counter++);
          var codePoint = character.charCodeAt();
          var value2 = void 0;
          if (codePoint < 32 || codePoint > 126) {
            if (codePoint >= 55296 && codePoint <= 56319 && counter < length2) {
              var extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
              } else {
                counter--;
              }
            }
            value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else {
            if (options.escapeEverything) {
              if (regexAnySingleEscape.test(character)) {
                value2 = "\\" + character;
              } else {
                value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
              }
            } else if (/[\t\n\f\r\x0B]/.test(character)) {
              value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
            } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
              value2 = "\\" + character;
            } else {
              value2 = character;
            }
          }
          output += value2;
        }
        if (isIdentifier) {
          if (/^-[-\d]/.test(output)) {
            output = "\\-" + output.slice(1);
          } else if (/\d/.test(firstChar)) {
            output = "\\3" + firstChar + " " + output.slice(1);
          }
        }
        output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
          if ($1 && $1.length % 2) {
            return $0;
          }
          return ($1 || "") + $2;
        });
        if (!isIdentifier && options.wrap) {
          return quote + output + quote;
        }
        return output;
      };
      cssesc.options = {
        "escapeEverything": false,
        "isIdentifier": false,
        "quotes": "single",
        "wrap": false
      };
      cssesc.version = "3.0.0";
      module.exports = cssesc;
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/className.js
  var require_className = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/className.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _cssesc = _interopRequireDefault(require_cssesc());
      var _util = require_util();
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var ClassName = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(ClassName2, _Node);
        function ClassName2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.CLASS;
          _this._constructed = true;
          return _this;
        }
        var _proto = ClassName2.prototype;
        _proto.valueToString = function valueToString() {
          return "." + _Node.prototype.valueToString.call(this);
        };
        _createClass(ClassName2, [{
          key: "value",
          get: function get3() {
            return this._value;
          },
          set: function set2(v) {
            if (this._constructed) {
              var escaped = (0, _cssesc["default"])(v, {
                isIdentifier: true
              });
              if (escaped !== v) {
                (0, _util.ensureObject)(this, "raws");
                this.raws.value = escaped;
              } else if (this.raws) {
                delete this.raws.value;
              }
            }
            this._value = v;
          }
        }]);
        return ClassName2;
      }(_node["default"]);
      exports["default"] = ClassName;
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/comment.js
  var require_comment2 = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/comment.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Comment3 = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Comment4, _Node);
        function Comment4(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.COMMENT;
          return _this;
        }
        return Comment4;
      }(_node["default"]);
      exports["default"] = Comment3;
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/id.js
  var require_id = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/id.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var ID = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(ID2, _Node);
        function ID2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.ID;
          return _this;
        }
        var _proto = ID2.prototype;
        _proto.valueToString = function valueToString() {
          return "#" + _Node.prototype.valueToString.call(this);
        };
        return ID2;
      }(_node["default"]);
      exports["default"] = ID;
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/namespace.js
  var require_namespace = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/namespace.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _cssesc = _interopRequireDefault(require_cssesc());
      var _util = require_util();
      var _node = _interopRequireDefault(require_node2());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Namespace = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Namespace2, _Node);
        function Namespace2() {
          return _Node.apply(this, arguments) || this;
        }
        var _proto = Namespace2.prototype;
        _proto.qualifiedName = function qualifiedName(value2) {
          if (this.namespace) {
            return this.namespaceString + "|" + value2;
          } else {
            return value2;
          }
        };
        _proto.valueToString = function valueToString() {
          return this.qualifiedName(_Node.prototype.valueToString.call(this));
        };
        _createClass(Namespace2, [{
          key: "namespace",
          get: function get3() {
            return this._namespace;
          },
          set: function set2(namespace) {
            if (namespace === true || namespace === "*" || namespace === "&") {
              this._namespace = namespace;
              if (this.raws) {
                delete this.raws.namespace;
              }
              return;
            }
            var escaped = (0, _cssesc["default"])(namespace, {
              isIdentifier: true
            });
            this._namespace = namespace;
            if (escaped !== namespace) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.namespace = escaped;
            } else if (this.raws) {
              delete this.raws.namespace;
            }
          }
        }, {
          key: "ns",
          get: function get3() {
            return this._namespace;
          },
          set: function set2(namespace) {
            this.namespace = namespace;
          }
        }, {
          key: "namespaceString",
          get: function get3() {
            if (this.namespace) {
              var ns = this.stringifyProperty("namespace");
              if (ns === true) {
                return "";
              } else {
                return ns;
              }
            } else {
              return "";
            }
          }
        }]);
        return Namespace2;
      }(_node["default"]);
      exports["default"] = Namespace;
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/tag.js
  var require_tag = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/tag.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _namespace = _interopRequireDefault(require_namespace());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Tag = /* @__PURE__ */ function(_Namespace) {
        _inheritsLoose(Tag2, _Namespace);
        function Tag2(opts) {
          var _this;
          _this = _Namespace.call(this, opts) || this;
          _this.type = _types.TAG;
          return _this;
        }
        return Tag2;
      }(_namespace["default"]);
      exports["default"] = Tag;
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/string.js
  var require_string = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/string.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var String2 = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(String3, _Node);
        function String3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.STRING;
          return _this;
        }
        return String3;
      }(_node["default"]);
      exports["default"] = String2;
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/pseudo.js
  var require_pseudo = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _container = _interopRequireDefault(require_container2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Pseudo = /* @__PURE__ */ function(_Container) {
        _inheritsLoose(Pseudo2, _Container);
        function Pseudo2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types.PSEUDO;
          return _this;
        }
        var _proto = Pseudo2.prototype;
        _proto.toString = function toString() {
          var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
          return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
        };
        return Pseudo2;
      }(_container["default"]);
      exports["default"] = Pseudo;
      module.exports = exports.default;
    }
  });

  // node_modules/util-deprecate/browser.js
  var require_browser = __commonJS({
    "node_modules/util-deprecate/browser.js"(exports, module) {
      module.exports = deprecate;
      function deprecate(fn, msg) {
        if (config5("noDeprecation")) {
          return fn;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (config5("throwDeprecation")) {
              throw new Error(msg);
            } else if (config5("traceDeprecation")) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      function config5(name) {
        try {
          if (!global.localStorage) return false;
        } catch (_) {
          return false;
        }
        var val = global.localStorage[name];
        if (null == val) return false;
        return String(val).toLowerCase() === "true";
      }
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/attribute.js
  var require_attribute = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/attribute.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      exports.unescapeValue = unescapeValue;
      var _cssesc = _interopRequireDefault(require_cssesc());
      var _unesc = _interopRequireDefault(require_unesc());
      var _namespace = _interopRequireDefault(require_namespace());
      var _types = require_types();
      var _CSSESC_QUOTE_OPTIONS;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var deprecate = require_browser();
      var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
      var warnOfDeprecatedValueAssignment = deprecate(function() {
      }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
      var warnOfDeprecatedQuotedAssignment = deprecate(function() {
      }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
      var warnOfDeprecatedConstructor = deprecate(function() {
      }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
      function unescapeValue(value2) {
        var deprecatedUsage = false;
        var quoteMark = null;
        var unescaped = value2;
        var m = unescaped.match(WRAPPED_IN_QUOTES);
        if (m) {
          quoteMark = m[1];
          unescaped = m[2];
        }
        unescaped = (0, _unesc["default"])(unescaped);
        if (unescaped !== value2) {
          deprecatedUsage = true;
        }
        return {
          deprecatedUsage,
          unescaped,
          quoteMark
        };
      }
      function handleDeprecatedContructorOpts(opts) {
        if (opts.quoteMark !== void 0) {
          return opts;
        }
        if (opts.value === void 0) {
          return opts;
        }
        warnOfDeprecatedConstructor();
        var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
        if (!opts.raws) {
          opts.raws = {};
        }
        if (opts.raws.value === void 0) {
          opts.raws.value = opts.value;
        }
        opts.value = unescaped;
        opts.quoteMark = quoteMark;
        return opts;
      }
      var Attribute = /* @__PURE__ */ function(_Namespace) {
        _inheritsLoose(Attribute2, _Namespace);
        function Attribute2(opts) {
          var _this;
          if (opts === void 0) {
            opts = {};
          }
          _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
          _this.type = _types.ATTRIBUTE;
          _this.raws = _this.raws || {};
          Object.defineProperty(_this.raws, "unquoted", {
            get: deprecate(function() {
              return _this.value;
            }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
            set: deprecate(function() {
              return _this.value;
            }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
          });
          _this._constructed = true;
          return _this;
        }
        var _proto = Attribute2.prototype;
        _proto.getQuotedValue = function getQuotedValue(options) {
          if (options === void 0) {
            options = {};
          }
          var quoteMark = this._determineQuoteMark(options);
          var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
          var escaped = (0, _cssesc["default"])(this._value, cssescopts);
          return escaped;
        };
        _proto._determineQuoteMark = function _determineQuoteMark(options) {
          return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
        };
        _proto.setValue = function setValue(value2, options) {
          if (options === void 0) {
            options = {};
          }
          this._value = value2;
          this._quoteMark = this._determineQuoteMark(options);
          this._syncRawValue();
        };
        _proto.smartQuoteMark = function smartQuoteMark(options) {
          var v = this.value;
          var numSingleQuotes = v.replace(/[^']/g, "").length;
          var numDoubleQuotes = v.replace(/[^"]/g, "").length;
          if (numSingleQuotes + numDoubleQuotes === 0) {
            var escaped = (0, _cssesc["default"])(v, {
              isIdentifier: true
            });
            if (escaped === v) {
              return Attribute2.NO_QUOTE;
            } else {
              var pref = this.preferredQuoteMark(options);
              if (pref === Attribute2.NO_QUOTE) {
                var quote = this.quoteMark || options.quoteMark || Attribute2.DOUBLE_QUOTE;
                var opts = CSSESC_QUOTE_OPTIONS[quote];
                var quoteValue = (0, _cssesc["default"])(v, opts);
                if (quoteValue.length < escaped.length) {
                  return quote;
                }
              }
              return pref;
            }
          } else if (numDoubleQuotes === numSingleQuotes) {
            return this.preferredQuoteMark(options);
          } else if (numDoubleQuotes < numSingleQuotes) {
            return Attribute2.DOUBLE_QUOTE;
          } else {
            return Attribute2.SINGLE_QUOTE;
          }
        };
        _proto.preferredQuoteMark = function preferredQuoteMark(options) {
          var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;
          if (quoteMark === void 0) {
            quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
          }
          if (quoteMark === void 0) {
            quoteMark = Attribute2.DOUBLE_QUOTE;
          }
          return quoteMark;
        };
        _proto._syncRawValue = function _syncRawValue() {
          var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
          if (rawValue === this._value) {
            if (this.raws) {
              delete this.raws.value;
            }
          } else {
            this.raws.value = rawValue;
          }
        };
        _proto._handleEscapes = function _handleEscapes(prop2, value2) {
          if (this._constructed) {
            var escaped = (0, _cssesc["default"])(value2, {
              isIdentifier: true
            });
            if (escaped !== value2) {
              this.raws[prop2] = escaped;
            } else {
              delete this.raws[prop2];
            }
          }
        };
        _proto._spacesFor = function _spacesFor(name) {
          var attrSpaces = {
            before: "",
            after: ""
          };
          var spaces = this.spaces[name] || {};
          var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
          return Object.assign(attrSpaces, spaces, rawSpaces);
        };
        _proto._stringFor = function _stringFor(name, spaceName, concat) {
          if (spaceName === void 0) {
            spaceName = name;
          }
          if (concat === void 0) {
            concat = defaultAttrConcat;
          }
          var attrSpaces = this._spacesFor(spaceName);
          return concat(this.stringifyProperty(name), attrSpaces);
        };
        _proto.offsetOf = function offsetOf(name) {
          var count = 1;
          var attributeSpaces = this._spacesFor("attribute");
          count += attributeSpaces.before.length;
          if (name === "namespace" || name === "ns") {
            return this.namespace ? count : -1;
          }
          if (name === "attributeNS") {
            return count;
          }
          count += this.namespaceString.length;
          if (this.namespace) {
            count += 1;
          }
          if (name === "attribute") {
            return count;
          }
          count += this.stringifyProperty("attribute").length;
          count += attributeSpaces.after.length;
          var operatorSpaces = this._spacesFor("operator");
          count += operatorSpaces.before.length;
          var operator = this.stringifyProperty("operator");
          if (name === "operator") {
            return operator ? count : -1;
          }
          count += operator.length;
          count += operatorSpaces.after.length;
          var valueSpaces = this._spacesFor("value");
          count += valueSpaces.before.length;
          var value2 = this.stringifyProperty("value");
          if (name === "value") {
            return value2 ? count : -1;
          }
          count += value2.length;
          count += valueSpaces.after.length;
          var insensitiveSpaces = this._spacesFor("insensitive");
          count += insensitiveSpaces.before.length;
          if (name === "insensitive") {
            return this.insensitive ? count : -1;
          }
          return -1;
        };
        _proto.toString = function toString() {
          var _this2 = this;
          var selector = [this.rawSpaceBefore, "["];
          selector.push(this._stringFor("qualifiedAttribute", "attribute"));
          if (this.operator && (this.value || this.value === "")) {
            selector.push(this._stringFor("operator"));
            selector.push(this._stringFor("value"));
            selector.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
              if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
                attrSpaces.before = " ";
              }
              return defaultAttrConcat(attrValue, attrSpaces);
            }));
          }
          selector.push("]");
          selector.push(this.rawSpaceAfter);
          return selector.join("");
        };
        _createClass(Attribute2, [{
          key: "quoted",
          get: function get3() {
            var qm = this.quoteMark;
            return qm === "'" || qm === '"';
          },
          set: function set2(value2) {
            warnOfDeprecatedQuotedAssignment();
          }
          /**
           * returns a single (`'`) or double (`"`) quote character if the value is quoted.
           * returns `null` if the value is not quoted.
           * returns `undefined` if the quotation state is unknown (this can happen when
           * the attribute is constructed without specifying a quote mark.)
           */
        }, {
          key: "quoteMark",
          get: function get3() {
            return this._quoteMark;
          },
          set: function set2(quoteMark) {
            if (!this._constructed) {
              this._quoteMark = quoteMark;
              return;
            }
            if (this._quoteMark !== quoteMark) {
              this._quoteMark = quoteMark;
              this._syncRawValue();
            }
          }
        }, {
          key: "qualifiedAttribute",
          get: function get3() {
            return this.qualifiedName(this.raws.attribute || this.attribute);
          }
        }, {
          key: "insensitiveFlag",
          get: function get3() {
            return this.insensitive ? "i" : "";
          }
        }, {
          key: "value",
          get: function get3() {
            return this._value;
          },
          set: (
            /**
             * Before 3.0, the value had to be set to an escaped value including any wrapped
             * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
             * is unescaped during parsing and any quote marks are removed.
             *
             * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
             * a deprecation warning is raised when the new value contains any characters that would
             * require escaping (including if it contains wrapped quotes).
             *
             * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
             * how the new value is quoted.
             */
            function set2(v) {
              if (this._constructed) {
                var _unescapeValue2 = unescapeValue(v), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
                if (deprecatedUsage) {
                  warnOfDeprecatedValueAssignment();
                }
                if (unescaped === this._value && quoteMark === this._quoteMark) {
                  return;
                }
                this._value = unescaped;
                this._quoteMark = quoteMark;
                this._syncRawValue();
              } else {
                this._value = v;
              }
            }
          )
        }, {
          key: "insensitive",
          get: function get3() {
            return this._insensitive;
          },
          set: function set2(insensitive) {
            if (!insensitive) {
              this._insensitive = false;
              if (this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i")) {
                this.raws.insensitiveFlag = void 0;
              }
            }
            this._insensitive = insensitive;
          }
        }, {
          key: "attribute",
          get: function get3() {
            return this._attribute;
          },
          set: function set2(name) {
            this._handleEscapes("attribute", name);
            this._attribute = name;
          }
        }]);
        return Attribute2;
      }(_namespace["default"]);
      exports["default"] = Attribute;
      Attribute.NO_QUOTE = null;
      Attribute.SINGLE_QUOTE = "'";
      Attribute.DOUBLE_QUOTE = '"';
      var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
        "'": {
          quotes: "single",
          wrap: true
        },
        '"': {
          quotes: "double",
          wrap: true
        }
      }, _CSSESC_QUOTE_OPTIONS[null] = {
        isIdentifier: true
      }, _CSSESC_QUOTE_OPTIONS);
      function defaultAttrConcat(attrValue, attrSpaces) {
        return "" + attrSpaces.before + attrValue + attrSpaces.after;
      }
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/universal.js
  var require_universal = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/universal.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _namespace = _interopRequireDefault(require_namespace());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Universal = /* @__PURE__ */ function(_Namespace) {
        _inheritsLoose(Universal2, _Namespace);
        function Universal2(opts) {
          var _this;
          _this = _Namespace.call(this, opts) || this;
          _this.type = _types.UNIVERSAL;
          _this.value = "*";
          return _this;
        }
        return Universal2;
      }(_namespace["default"]);
      exports["default"] = Universal;
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/combinator.js
  var require_combinator = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/combinator.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Combinator = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Combinator2, _Node);
        function Combinator2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.COMBINATOR;
          return _this;
        }
        return Combinator2;
      }(_node["default"]);
      exports["default"] = Combinator;
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/nesting.js
  var require_nesting = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/nesting.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Nesting = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Nesting2, _Node);
        function Nesting2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.NESTING;
          _this.value = "&";
          return _this;
        }
        return Nesting2;
      }(_node["default"]);
      exports["default"] = Nesting;
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/sortAscending.js
  var require_sortAscending = __commonJS({
    "node_modules/postcss-selector-parser/dist/sortAscending.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = sortAscending;
      function sortAscending(list3) {
        return list3.sort(function(a, b) {
          return a - b;
        });
      }
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/tokenTypes.js
  var require_tokenTypes = __commonJS({
    "node_modules/postcss-selector-parser/dist/tokenTypes.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.word = exports.tilde = exports.tab = exports.str = exports.space = exports.slash = exports.singleQuote = exports.semicolon = exports.plus = exports.pipe = exports.openSquare = exports.openParenthesis = exports.newline = exports.greaterThan = exports.feed = exports.equals = exports.doubleQuote = exports.dollar = exports.cr = exports.comment = exports.comma = exports.combinator = exports.colon = exports.closeSquare = exports.closeParenthesis = exports.caret = exports.bang = exports.backslash = exports.at = exports.asterisk = exports.ampersand = void 0;
      var ampersand = 38;
      exports.ampersand = ampersand;
      var asterisk = 42;
      exports.asterisk = asterisk;
      var at = 64;
      exports.at = at;
      var comma = 44;
      exports.comma = comma;
      var colon = 58;
      exports.colon = colon;
      var semicolon = 59;
      exports.semicolon = semicolon;
      var openParenthesis = 40;
      exports.openParenthesis = openParenthesis;
      var closeParenthesis = 41;
      exports.closeParenthesis = closeParenthesis;
      var openSquare = 91;
      exports.openSquare = openSquare;
      var closeSquare = 93;
      exports.closeSquare = closeSquare;
      var dollar = 36;
      exports.dollar = dollar;
      var tilde = 126;
      exports.tilde = tilde;
      var caret = 94;
      exports.caret = caret;
      var plus = 43;
      exports.plus = plus;
      var equals3 = 61;
      exports.equals = equals3;
      var pipe = 124;
      exports.pipe = pipe;
      var greaterThan = 62;
      exports.greaterThan = greaterThan;
      var space = 32;
      exports.space = space;
      var singleQuote = 39;
      exports.singleQuote = singleQuote;
      var doubleQuote = 34;
      exports.doubleQuote = doubleQuote;
      var slash = 47;
      exports.slash = slash;
      var bang = 33;
      exports.bang = bang;
      var backslash = 92;
      exports.backslash = backslash;
      var cr = 13;
      exports.cr = cr;
      var feed = 12;
      exports.feed = feed;
      var newline = 10;
      exports.newline = newline;
      var tab = 9;
      exports.tab = tab;
      var str = singleQuote;
      exports.str = str;
      var comment3 = -1;
      exports.comment = comment3;
      var word = -2;
      exports.word = word;
      var combinator = -3;
      exports.combinator = combinator;
    }
  });

  // node_modules/postcss-selector-parser/dist/tokenize.js
  var require_tokenize2 = __commonJS({
    "node_modules/postcss-selector-parser/dist/tokenize.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.FIELDS = void 0;
      exports["default"] = tokenize;
      var t = _interopRequireWildcard(require_tokenTypes());
      var _unescapable;
      var _wordDelimiters;
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
      var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
      var hex = {};
      var hexChars = "0123456789abcdefABCDEF";
      for (i = 0; i < hexChars.length; i++) {
        hex[hexChars.charCodeAt(i)] = true;
      }
      var i;
      function consumeWord(css, start) {
        var next2 = start;
        var code;
        do {
          code = css.charCodeAt(next2);
          if (wordDelimiters[code]) {
            return next2 - 1;
          } else if (code === t.backslash) {
            next2 = consumeEscape(css, next2) + 1;
          } else {
            next2++;
          }
        } while (next2 < css.length);
        return next2 - 1;
      }
      function consumeEscape(css, start) {
        var next2 = start;
        var code = css.charCodeAt(next2 + 1);
        if (unescapable[code]) {
        } else if (hex[code]) {
          var hexDigits = 0;
          do {
            next2++;
            hexDigits++;
            code = css.charCodeAt(next2 + 1);
          } while (hex[code] && hexDigits < 6);
          if (hexDigits < 6 && code === t.space) {
            next2++;
          }
        } else {
          next2++;
        }
        return next2;
      }
      var FIELDS = {
        TYPE: 0,
        START_LINE: 1,
        START_COL: 2,
        END_LINE: 3,
        END_COL: 4,
        START_POS: 5,
        END_POS: 6
      };
      exports.FIELDS = FIELDS;
      function tokenize(input) {
        var tokens = [];
        var css = input.css.valueOf();
        var _css = css, length2 = _css.length;
        var offset = -1;
        var line = 1;
        var start = 0;
        var end = 0;
        var code, content, endColumn, endLine, escaped, escapePos, last, lines, next2, nextLine, nextOffset, quote, tokenType;
        function unclosed(what, fix) {
          if (input.safe) {
            css += fix;
            next2 = css.length - 1;
          } else {
            throw input.error("Unclosed " + what, line, start - offset, start);
          }
        }
        while (start < length2) {
          code = css.charCodeAt(start);
          if (code === t.newline) {
            offset = start;
            line += 1;
          }
          switch (code) {
            case t.space:
            case t.tab:
            case t.newline:
            case t.cr:
            case t.feed:
              next2 = start;
              do {
                next2 += 1;
                code = css.charCodeAt(next2);
                if (code === t.newline) {
                  offset = next2;
                  line += 1;
                }
              } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);
              tokenType = t.space;
              endLine = line;
              endColumn = next2 - offset - 1;
              end = next2;
              break;
            case t.plus:
            case t.greaterThan:
            case t.tilde:
            case t.pipe:
              next2 = start;
              do {
                next2 += 1;
                code = css.charCodeAt(next2);
              } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);
              tokenType = t.combinator;
              endLine = line;
              endColumn = start - offset;
              end = next2;
              break;
            // Consume these characters as single tokens.
            case t.asterisk:
            case t.ampersand:
            case t.bang:
            case t.comma:
            case t.equals:
            case t.dollar:
            case t.caret:
            case t.openSquare:
            case t.closeSquare:
            case t.colon:
            case t.semicolon:
            case t.openParenthesis:
            case t.closeParenthesis:
              next2 = start;
              tokenType = code;
              endLine = line;
              endColumn = start - offset;
              end = next2 + 1;
              break;
            case t.singleQuote:
            case t.doubleQuote:
              quote = code === t.singleQuote ? "'" : '"';
              next2 = start;
              do {
                escaped = false;
                next2 = css.indexOf(quote, next2 + 1);
                if (next2 === -1) {
                  unclosed("quote", quote);
                }
                escapePos = next2;
                while (css.charCodeAt(escapePos - 1) === t.backslash) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              tokenType = t.str;
              endLine = line;
              endColumn = start - offset;
              end = next2 + 1;
              break;
            default:
              if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
                next2 = css.indexOf("*/", start + 2) + 1;
                if (next2 === 0) {
                  unclosed("comment", "*/");
                }
                content = css.slice(start, next2 + 1);
                lines = content.split("\n");
                last = lines.length - 1;
                if (last > 0) {
                  nextLine = line + last;
                  nextOffset = next2 - lines[last].length;
                } else {
                  nextLine = line;
                  nextOffset = offset;
                }
                tokenType = t.comment;
                line = nextLine;
                endLine = nextLine;
                endColumn = next2 - nextOffset;
              } else if (code === t.slash) {
                next2 = start;
                tokenType = code;
                endLine = line;
                endColumn = start - offset;
                end = next2 + 1;
              } else {
                next2 = consumeWord(css, start);
                tokenType = t.word;
                endLine = line;
                endColumn = next2 - offset;
              }
              end = next2 + 1;
              break;
          }
          tokens.push([
            tokenType,
            // [0] Token type
            line,
            // [1] Starting line
            start - offset,
            // [2] Starting column
            endLine,
            // [3] Ending line
            endColumn,
            // [4] Ending column
            start,
            // [5] Start position / Source index
            end
            // [6] End position
          ]);
          if (nextOffset) {
            offset = nextOffset;
            nextOffset = null;
          }
          start = end;
        }
        return tokens;
      }
    }
  });

  // node_modules/postcss-selector-parser/dist/parser.js
  var require_parser2 = __commonJS({
    "node_modules/postcss-selector-parser/dist/parser.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _root = _interopRequireDefault(require_root2());
      var _selector = _interopRequireDefault(require_selector());
      var _className = _interopRequireDefault(require_className());
      var _comment = _interopRequireDefault(require_comment2());
      var _id = _interopRequireDefault(require_id());
      var _tag = _interopRequireDefault(require_tag());
      var _string = _interopRequireDefault(require_string());
      var _pseudo = _interopRequireDefault(require_pseudo());
      var _attribute = _interopRequireWildcard(require_attribute());
      var _universal = _interopRequireDefault(require_universal());
      var _combinator = _interopRequireDefault(require_combinator());
      var _nesting = _interopRequireDefault(require_nesting());
      var _sortAscending = _interopRequireDefault(require_sortAscending());
      var _tokenize = _interopRequireWildcard(require_tokenize2());
      var tokens = _interopRequireWildcard(require_tokenTypes());
      var types2 = _interopRequireWildcard(require_types());
      var _util = require_util();
      var _WHITESPACE_TOKENS;
      var _Object$assign;
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
      var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
      function tokenStart(token) {
        return {
          line: token[_tokenize.FIELDS.START_LINE],
          column: token[_tokenize.FIELDS.START_COL]
        };
      }
      function tokenEnd(token) {
        return {
          line: token[_tokenize.FIELDS.END_LINE],
          column: token[_tokenize.FIELDS.END_COL]
        };
      }
      function getSource(startLine, startColumn, endLine, endColumn) {
        return {
          start: {
            line: startLine,
            column: startColumn
          },
          end: {
            line: endLine,
            column: endColumn
          }
        };
      }
      function getTokenSource(token) {
        return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
      }
      function getTokenSourceSpan(startToken, endToken) {
        if (!startToken) {
          return void 0;
        }
        return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
      }
      function unescapeProp(node, prop2) {
        var value2 = node[prop2];
        if (typeof value2 !== "string") {
          return;
        }
        if (value2.indexOf("\\") !== -1) {
          (0, _util.ensureObject)(node, "raws");
          node[prop2] = (0, _util.unesc)(value2);
          if (node.raws[prop2] === void 0) {
            node.raws[prop2] = value2;
          }
        }
        return node;
      }
      function indexesOf(array, item) {
        var i = -1;
        var indexes = [];
        while ((i = array.indexOf(item, i + 1)) !== -1) {
          indexes.push(i);
        }
        return indexes;
      }
      function uniqs() {
        var list3 = Array.prototype.concat.apply([], arguments);
        return list3.filter(function(item, i) {
          return i === list3.indexOf(item);
        });
      }
      var Parser = /* @__PURE__ */ function() {
        function Parser2(rule2, options) {
          if (options === void 0) {
            options = {};
          }
          this.rule = rule2;
          this.options = Object.assign({
            lossy: false,
            safe: false
          }, options);
          this.position = 0;
          this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
          this.tokens = (0, _tokenize["default"])({
            css: this.css,
            error: this._errorGenerator(),
            safe: this.options.safe
          });
          var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
          this.root = new _root["default"]({
            source: rootSource
          });
          this.root.errorGenerator = this._errorGenerator();
          var selector = new _selector["default"]({
            source: {
              start: {
                line: 1,
                column: 1
              }
            },
            sourceIndex: 0
          });
          this.root.append(selector);
          this.current = selector;
          this.loop();
        }
        var _proto = Parser2.prototype;
        _proto._errorGenerator = function _errorGenerator() {
          var _this = this;
          return function(message, errorOptions) {
            if (typeof _this.rule === "string") {
              return new Error(message);
            }
            return _this.rule.error(message, errorOptions);
          };
        };
        _proto.attribute = function attribute() {
          var attr2 = [];
          var startingToken = this.currToken;
          this.position++;
          while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            attr2.push(this.currToken);
            this.position++;
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
          }
          var len = attr2.length;
          var node = {
            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
            sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
          };
          if (len === 1 && !~[tokens.word].indexOf(attr2[0][_tokenize.FIELDS.TYPE])) {
            return this.expected("attribute", attr2[0][_tokenize.FIELDS.START_POS]);
          }
          var pos = 0;
          var spaceBefore = "";
          var commentBefore = "";
          var lastAdded = null;
          var spaceAfterMeaningfulToken = false;
          while (pos < len) {
            var token = attr2[pos];
            var content = this.content(token);
            var next2 = attr2[pos + 1];
            switch (token[_tokenize.FIELDS.TYPE]) {
              case tokens.space:
                spaceAfterMeaningfulToken = true;
                if (this.options.lossy) {
                  break;
                }
                if (lastAdded) {
                  (0, _util.ensureObject)(node, "spaces", lastAdded);
                  var prevContent = node.spaces[lastAdded].after || "";
                  node.spaces[lastAdded].after = prevContent + content;
                  var existingComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || null;
                  if (existingComment) {
                    node.raws.spaces[lastAdded].after = existingComment + content;
                  }
                } else {
                  spaceBefore = spaceBefore + content;
                  commentBefore = commentBefore + content;
                }
                break;
              case tokens.asterisk:
                if (next2[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = "operator";
                } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next2) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, "spaces", "attribute");
                    node.spaces.attribute.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                    node.raws.spaces.attribute.before = spaceBefore;
                    commentBefore = "";
                  }
                  node.namespace = (node.namespace || "") + content;
                  var rawValue = (0, _util.getProp)(node, "raws", "namespace") || null;
                  if (rawValue) {
                    node.raws.namespace += content;
                  }
                  lastAdded = "namespace";
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.dollar:
                if (lastAdded === "value") {
                  var oldRawValue = (0, _util.getProp)(node, "raws", "value");
                  node.value += "$";
                  if (oldRawValue) {
                    node.raws.value = oldRawValue + "$";
                  }
                  break;
                }
              // Falls through
              case tokens.caret:
                if (next2[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = "operator";
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.combinator:
                if (content === "~" && next2[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = "operator";
                }
                if (content !== "|") {
                  spaceAfterMeaningfulToken = false;
                  break;
                }
                if (next2[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = "operator";
                } else if (!node.namespace && !node.attribute) {
                  node.namespace = true;
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.word:
                if (next2 && this.content(next2) === "|" && attr2[pos + 2] && attr2[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
                !node.operator && !node.namespace) {
                  node.namespace = content;
                  lastAdded = "namespace";
                } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, "spaces", "attribute");
                    node.spaces.attribute.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                    node.raws.spaces.attribute.before = commentBefore;
                    commentBefore = "";
                  }
                  node.attribute = (node.attribute || "") + content;
                  var _rawValue = (0, _util.getProp)(node, "raws", "attribute") || null;
                  if (_rawValue) {
                    node.raws.attribute += content;
                  }
                  lastAdded = "attribute";
                } else if (!node.value && node.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node.quoteMark)) {
                  var _unescaped = (0, _util.unesc)(content);
                  var _oldRawValue = (0, _util.getProp)(node, "raws", "value") || "";
                  var oldValue = node.value || "";
                  node.value = oldValue + _unescaped;
                  node.quoteMark = null;
                  if (_unescaped !== content || _oldRawValue) {
                    (0, _util.ensureObject)(node, "raws");
                    node.raws.value = (_oldRawValue || oldValue) + content;
                  }
                  lastAdded = "value";
                } else {
                  var insensitive = content === "i" || content === "I";
                  if ((node.value || node.value === "") && (node.quoteMark || spaceAfterMeaningfulToken)) {
                    node.insensitive = insensitive;
                    if (!insensitive || content === "I") {
                      (0, _util.ensureObject)(node, "raws");
                      node.raws.insensitiveFlag = content;
                    }
                    lastAdded = "insensitive";
                    if (spaceBefore) {
                      (0, _util.ensureObject)(node, "spaces", "insensitive");
                      node.spaces.insensitive.before = spaceBefore;
                      spaceBefore = "";
                    }
                    if (commentBefore) {
                      (0, _util.ensureObject)(node, "raws", "spaces", "insensitive");
                      node.raws.spaces.insensitive.before = commentBefore;
                      commentBefore = "";
                    }
                  } else if (node.value || node.value === "") {
                    lastAdded = "value";
                    node.value += content;
                    if (node.raws.value) {
                      node.raws.value += content;
                    }
                  }
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.str:
                if (!node.attribute || !node.operator) {
                  return this.error("Expected an attribute followed by an operator preceding the string.", {
                    index: token[_tokenize.FIELDS.START_POS]
                  });
                }
                var _unescapeValue = (0, _attribute.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
                node.value = unescaped;
                node.quoteMark = quoteMark;
                lastAdded = "value";
                (0, _util.ensureObject)(node, "raws");
                node.raws.value = content;
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.equals:
                if (!node.attribute) {
                  return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content);
                }
                if (node.value) {
                  return this.error('Unexpected "=" found; an operator was already defined.', {
                    index: token[_tokenize.FIELDS.START_POS]
                  });
                }
                node.operator = node.operator ? node.operator + content : content;
                lastAdded = "operator";
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.comment:
                if (lastAdded) {
                  if (spaceAfterMeaningfulToken || next2 && next2[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                    var lastComment = (0, _util.getProp)(node, "spaces", lastAdded, "after") || "";
                    var rawLastComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || lastComment;
                    (0, _util.ensureObject)(node, "raws", "spaces", lastAdded);
                    node.raws.spaces[lastAdded].after = rawLastComment + content;
                  } else {
                    var lastValue = node[lastAdded] || "";
                    var rawLastValue = (0, _util.getProp)(node, "raws", lastAdded) || lastValue;
                    (0, _util.ensureObject)(node, "raws");
                    node.raws[lastAdded] = rawLastValue + content;
                  }
                } else {
                  commentBefore = commentBefore + content;
                }
                break;
              default:
                return this.error('Unexpected "' + content + '" found.', {
                  index: token[_tokenize.FIELDS.START_POS]
                });
            }
            pos++;
          }
          unescapeProp(node, "attribute");
          unescapeProp(node, "namespace");
          this.newNode(new _attribute["default"](node));
          this.position++;
        };
        _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
          if (stopPosition < 0) {
            stopPosition = this.tokens.length;
          }
          var startPosition = this.position;
          var nodes = [];
          var space = "";
          var lastComment = void 0;
          do {
            if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
              if (!this.options.lossy) {
                space += this.content();
              }
            } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
              var spaces = {};
              if (space) {
                spaces.before = space;
                space = "";
              }
              lastComment = new _comment["default"]({
                value: this.content(),
                source: getTokenSource(this.currToken),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                spaces
              });
              nodes.push(lastComment);
            }
          } while (++this.position < stopPosition);
          if (space) {
            if (lastComment) {
              lastComment.spaces.after = space;
            } else if (!this.options.lossy) {
              var firstToken = this.tokens[startPosition];
              var lastToken = this.tokens[this.position - 1];
              nodes.push(new _string["default"]({
                value: "",
                source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                spaces: {
                  before: space,
                  after: ""
                }
              }));
            }
          }
          return nodes;
        };
        _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
          var _this2 = this;
          if (requiredSpace === void 0) {
            requiredSpace = false;
          }
          var space = "";
          var rawSpace = "";
          nodes.forEach(function(n) {
            var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);
            var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);
            space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
            rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
          });
          if (rawSpace === space) {
            rawSpace = void 0;
          }
          var result = {
            space,
            rawSpace
          };
          return result;
        };
        _proto.isNamedCombinator = function isNamedCombinator(position2) {
          if (position2 === void 0) {
            position2 = this.position;
          }
          return this.tokens[position2 + 0] && this.tokens[position2 + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position2 + 1] && this.tokens[position2 + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position2 + 2] && this.tokens[position2 + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
        };
        _proto.namedCombinator = function namedCombinator() {
          if (this.isNamedCombinator()) {
            var nameRaw = this.content(this.tokens[this.position + 1]);
            var name = (0, _util.unesc)(nameRaw).toLowerCase();
            var raws = {};
            if (name !== nameRaw) {
              raws.value = "/" + nameRaw + "/";
            }
            var node = new _combinator["default"]({
              value: "/" + name + "/",
              source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              raws
            });
            this.position = this.position + 3;
            return node;
          } else {
            this.unexpected();
          }
        };
        _proto.combinator = function combinator() {
          var _this3 = this;
          if (this.content() === "|") {
            return this.namespace();
          }
          var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
          if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
            if (nodes.length > 0) {
              var last = this.current.last;
              if (last) {
                var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
                if (rawSpace !== void 0) {
                  last.rawSpaceAfter += rawSpace;
                }
                last.spaces.after += space;
              } else {
                nodes.forEach(function(n) {
                  return _this3.newNode(n);
                });
              }
            }
            return;
          }
          var firstToken = this.currToken;
          var spaceOrDescendantSelectorNodes = void 0;
          if (nextSigTokenPos > this.position) {
            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          }
          var node;
          if (this.isNamedCombinator()) {
            node = this.namedCombinator();
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
            node = new _combinator["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
            });
            this.position++;
          } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
          } else if (!spaceOrDescendantSelectorNodes) {
            this.unexpected();
          }
          if (node) {
            if (spaceOrDescendantSelectorNodes) {
              var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
              node.spaces.before = _space;
              node.rawSpaceBefore = _rawSpace;
            }
          } else {
            var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
            if (!_rawSpace2) {
              _rawSpace2 = _space2;
            }
            var spaces = {};
            var raws = {
              spaces: {}
            };
            if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
              spaces.before = _space2.slice(0, _space2.length - 1);
              raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
            } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
              spaces.after = _space2.slice(1);
              raws.spaces.after = _rawSpace2.slice(1);
            } else {
              raws.value = _rawSpace2;
            }
            node = new _combinator["default"]({
              value: " ",
              source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces,
              raws
            });
          }
          if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
            node.spaces.after = this.optionalSpace(this.content());
            this.position++;
          }
          return this.newNode(node);
        };
        _proto.comma = function comma() {
          if (this.position === this.tokens.length - 1) {
            this.root.trailingComma = true;
            this.position++;
            return;
          }
          this.current._inferEndPosition();
          var selector = new _selector["default"]({
            source: {
              start: tokenStart(this.tokens[this.position + 1])
            },
            sourceIndex: this.tokens[this.position + 1][_tokenize.FIELDS.START_POS]
          });
          this.current.parent.append(selector);
          this.current = selector;
          this.position++;
        };
        _proto.comment = function comment3() {
          var current = this.currToken;
          this.newNode(new _comment["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.error = function error(message, opts) {
          throw this.root.error(message, opts);
        };
        _proto.missingBackslash = function missingBackslash() {
          return this.error("Expected a backslash preceding the semicolon.", {
            index: this.currToken[_tokenize.FIELDS.START_POS]
          });
        };
        _proto.missingParenthesis = function missingParenthesis() {
          return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.missingSquareBracket = function missingSquareBracket() {
          return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.unexpected = function unexpected() {
          return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.unexpectedPipe = function unexpectedPipe() {
          return this.error("Unexpected '|'.", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.namespace = function namespace() {
          var before = this.prevToken && this.content(this.prevToken) || true;
          if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.position++;
            return this.word(before);
          } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
            this.position++;
            return this.universal(before);
          }
          this.unexpectedPipe();
        };
        _proto.nesting = function nesting() {
          if (this.nextToken) {
            var nextContent = this.content(this.nextToken);
            if (nextContent === "|") {
              this.position++;
              return;
            }
          }
          var current = this.currToken;
          this.newNode(new _nesting["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.parentheses = function parentheses() {
          var last = this.current.last;
          var unbalanced = 1;
          this.position++;
          if (last && last.type === types2.PSEUDO) {
            var selector = new _selector["default"]({
              source: {
                start: tokenStart(this.tokens[this.position])
              },
              sourceIndex: this.tokens[this.position][_tokenize.FIELDS.START_POS]
            });
            var cache2 = this.current;
            last.append(selector);
            this.current = selector;
            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }
              if (unbalanced) {
                this.parse();
              } else {
                this.current.source.end = tokenEnd(this.currToken);
                this.current.parent.source.end = tokenEnd(this.currToken);
                this.position++;
              }
            }
            this.current = cache2;
          } else {
            var parenStart = this.currToken;
            var parenValue = "(";
            var parenEnd;
            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }
              parenEnd = this.currToken;
              parenValue += this.parseParenthesisToken(this.currToken);
              this.position++;
            }
            if (last) {
              last.appendToPropertyAndEscape("value", parenValue, parenValue);
            } else {
              this.newNode(new _string["default"]({
                value: parenValue,
                source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
                sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
              }));
            }
          }
          if (unbalanced) {
            return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };
        _proto.pseudo = function pseudo() {
          var _this4 = this;
          var pseudoStr = "";
          var startingToken = this.currToken;
          while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
            pseudoStr += this.content();
            this.position++;
          }
          if (!this.currToken) {
            return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.splitWord(false, function(first, length2) {
              pseudoStr += first;
              _this4.newNode(new _pseudo["default"]({
                value: pseudoStr,
                source: getTokenSourceSpan(startingToken, _this4.currToken),
                sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
              }));
              if (length2 > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                _this4.error("Misplaced parenthesis.", {
                  index: _this4.nextToken[_tokenize.FIELDS.START_POS]
                });
              }
            });
          } else {
            return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };
        _proto.space = function space() {
          var content = this.content();
          if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node) {
            return node.type === "comment";
          })) {
            this.spaces = this.optionalSpace(content);
            this.position++;
          } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            this.current.last.spaces.after = this.optionalSpace(content);
            this.position++;
          } else {
            this.combinator();
          }
        };
        _proto.string = function string() {
          var current = this.currToken;
          this.newNode(new _string["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.universal = function universal(namespace) {
          var nextToken = this.nextToken;
          if (nextToken && this.content(nextToken) === "|") {
            this.position++;
            return this.namespace();
          }
          var current = this.currToken;
          this.newNode(new _universal["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }), namespace);
          this.position++;
        };
        _proto.splitWord = function splitWord(namespace, firstCallback) {
          var _this5 = this;
          var nextToken = this.nextToken;
          var word = this.content();
          while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
            this.position++;
            var current = this.content();
            word += current;
            if (current.lastIndexOf("\\") === current.length - 1) {
              var next2 = this.nextToken;
              if (next2 && next2[_tokenize.FIELDS.TYPE] === tokens.space) {
                word += this.requiredSpace(this.content(next2));
                this.position++;
              }
            }
            nextToken = this.nextToken;
          }
          var hasClass = indexesOf(word, ".").filter(function(i) {
            var escapedDot = word[i - 1] === "\\";
            var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
            return !escapedDot && !isKeyframesPercent;
          });
          var hasId = indexesOf(word, "#").filter(function(i) {
            return word[i - 1] !== "\\";
          });
          var interpolations = indexesOf(word, "#{");
          if (interpolations.length) {
            hasId = hasId.filter(function(hashIndex) {
              return !~interpolations.indexOf(hashIndex);
            });
          }
          var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
          indices.forEach(function(ind, i) {
            var index5 = indices[i + 1] || word.length;
            var value2 = word.slice(ind, index5);
            if (i === 0 && firstCallback) {
              return firstCallback.call(_this5, value2, indices.length);
            }
            var node;
            var current2 = _this5.currToken;
            var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i];
            var source2 = getSource(current2[1], current2[2] + ind, current2[3], current2[2] + (index5 - 1));
            if (~hasClass.indexOf(ind)) {
              var classNameOpts = {
                value: value2.slice(1),
                source: source2,
                sourceIndex
              };
              node = new _className["default"](unescapeProp(classNameOpts, "value"));
            } else if (~hasId.indexOf(ind)) {
              var idOpts = {
                value: value2.slice(1),
                source: source2,
                sourceIndex
              };
              node = new _id["default"](unescapeProp(idOpts, "value"));
            } else {
              var tagOpts = {
                value: value2,
                source: source2,
                sourceIndex
              };
              unescapeProp(tagOpts, "value");
              node = new _tag["default"](tagOpts);
            }
            _this5.newNode(node, namespace);
            namespace = null;
          });
          this.position++;
        };
        _proto.word = function word(namespace) {
          var nextToken = this.nextToken;
          if (nextToken && this.content(nextToken) === "|") {
            this.position++;
            return this.namespace();
          }
          return this.splitWord(namespace);
        };
        _proto.loop = function loop2() {
          while (this.position < this.tokens.length) {
            this.parse(true);
          }
          this.current._inferEndPosition();
          return this.root;
        };
        _proto.parse = function parse3(throwOnParenthesis) {
          switch (this.currToken[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              this.space();
              break;
            case tokens.comment:
              this.comment();
              break;
            case tokens.openParenthesis:
              this.parentheses();
              break;
            case tokens.closeParenthesis:
              if (throwOnParenthesis) {
                this.missingParenthesis();
              }
              break;
            case tokens.openSquare:
              this.attribute();
              break;
            case tokens.dollar:
            case tokens.caret:
            case tokens.equals:
            case tokens.word:
              this.word();
              break;
            case tokens.colon:
              this.pseudo();
              break;
            case tokens.comma:
              this.comma();
              break;
            case tokens.asterisk:
              this.universal();
              break;
            case tokens.ampersand:
              this.nesting();
              break;
            case tokens.slash:
            case tokens.combinator:
              this.combinator();
              break;
            case tokens.str:
              this.string();
              break;
            // These cases throw; no break needed.
            case tokens.closeSquare:
              this.missingSquareBracket();
            case tokens.semicolon:
              this.missingBackslash();
            default:
              this.unexpected();
          }
        };
        _proto.expected = function expected(description, index5, found) {
          if (Array.isArray(description)) {
            var last = description.pop();
            description = description.join(", ") + " or " + last;
          }
          var an = /^[aeiou]/.test(description[0]) ? "an" : "a";
          if (!found) {
            return this.error("Expected " + an + " " + description + ".", {
              index: index5
            });
          }
          return this.error("Expected " + an + " " + description + ', found "' + found + '" instead.', {
            index: index5
          });
        };
        _proto.requiredSpace = function requiredSpace(space) {
          return this.options.lossy ? " " : space;
        };
        _proto.optionalSpace = function optionalSpace(space) {
          return this.options.lossy ? "" : space;
        };
        _proto.lossySpace = function lossySpace(space, required) {
          if (this.options.lossy) {
            return required ? " " : "";
          } else {
            return space;
          }
        };
        _proto.parseParenthesisToken = function parseParenthesisToken(token) {
          var content = this.content(token);
          if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
            return this.requiredSpace(content);
          } else {
            return content;
          }
        };
        _proto.newNode = function newNode(node, namespace) {
          if (namespace) {
            if (/^ +$/.test(namespace)) {
              if (!this.options.lossy) {
                this.spaces = (this.spaces || "") + namespace;
              }
              namespace = true;
            }
            node.namespace = namespace;
            unescapeProp(node, "namespace");
          }
          if (this.spaces) {
            node.spaces.before = this.spaces;
            this.spaces = "";
          }
          return this.current.append(node);
        };
        _proto.content = function content(token) {
          if (token === void 0) {
            token = this.currToken;
          }
          return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
        };
        _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
          if (startPosition === void 0) {
            startPosition = this.position + 1;
          }
          var searchPosition = startPosition;
          while (searchPosition < this.tokens.length) {
            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
              searchPosition++;
              continue;
            } else {
              return searchPosition;
            }
          }
          return -1;
        };
        _createClass(Parser2, [{
          key: "currToken",
          get: function get3() {
            return this.tokens[this.position];
          }
        }, {
          key: "nextToken",
          get: function get3() {
            return this.tokens[this.position + 1];
          }
        }, {
          key: "prevToken",
          get: function get3() {
            return this.tokens[this.position - 1];
          }
        }]);
        return Parser2;
      }();
      exports["default"] = Parser;
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/processor.js
  var require_processor2 = __commonJS({
    "node_modules/postcss-selector-parser/dist/processor.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _parser = _interopRequireDefault(require_parser2());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var Processor2 = /* @__PURE__ */ function() {
        function Processor3(func, options) {
          this.func = func || function noop2() {
          };
          this.funcRes = null;
          this.options = options;
        }
        var _proto = Processor3.prototype;
        _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule2, options) {
          if (options === void 0) {
            options = {};
          }
          var merged = Object.assign({}, this.options, options);
          if (merged.updateSelector === false) {
            return false;
          } else {
            return typeof rule2 !== "string";
          }
        };
        _proto._isLossy = function _isLossy(options) {
          if (options === void 0) {
            options = {};
          }
          var merged = Object.assign({}, this.options, options);
          if (merged.lossless === false) {
            return true;
          } else {
            return false;
          }
        };
        _proto._root = function _root(rule2, options) {
          if (options === void 0) {
            options = {};
          }
          var parser5 = new _parser["default"](rule2, this._parseOptions(options));
          return parser5.root;
        };
        _proto._parseOptions = function _parseOptions(options) {
          return {
            lossy: this._isLossy(options)
          };
        };
        _proto._run = function _run(rule2, options) {
          var _this = this;
          if (options === void 0) {
            options = {};
          }
          return new Promise(function(resolve, reject) {
            try {
              var root12 = _this._root(rule2, options);
              Promise.resolve(_this.func(root12)).then(function(transform) {
                var string = void 0;
                if (_this._shouldUpdateSelector(rule2, options)) {
                  string = root12.toString();
                  rule2.selector = string;
                }
                return {
                  transform,
                  root: root12,
                  string
                };
              }).then(resolve, reject);
            } catch (e) {
              reject(e);
              return;
            }
          });
        };
        _proto._runSync = function _runSync(rule2, options) {
          if (options === void 0) {
            options = {};
          }
          var root12 = this._root(rule2, options);
          var transform = this.func(root12);
          if (transform && typeof transform.then === "function") {
            throw new Error("Selector processor returned a promise to a synchronous call.");
          }
          var string = void 0;
          if (options.updateSelector && typeof rule2 !== "string") {
            string = root12.toString();
            rule2.selector = string;
          }
          return {
            transform,
            root: root12,
            string
          };
        };
        _proto.ast = function ast(rule2, options) {
          return this._run(rule2, options).then(function(result) {
            return result.root;
          });
        };
        _proto.astSync = function astSync(rule2, options) {
          return this._runSync(rule2, options).root;
        };
        _proto.transform = function transform(rule2, options) {
          return this._run(rule2, options).then(function(result) {
            return result.transform;
          });
        };
        _proto.transformSync = function transformSync(rule2, options) {
          return this._runSync(rule2, options).transform;
        };
        _proto.process = function process2(rule2, options) {
          return this._run(rule2, options).then(function(result) {
            return result.string || result.root.toString();
          });
        };
        _proto.processSync = function processSync(rule2, options) {
          var result = this._runSync(rule2, options);
          return result.string || result.root.toString();
        };
        return Processor3;
      }();
      exports["default"] = Processor2;
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/constructors.js
  var require_constructors = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/constructors.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;
      var _attribute = _interopRequireDefault(require_attribute());
      var _className = _interopRequireDefault(require_className());
      var _combinator = _interopRequireDefault(require_combinator());
      var _comment = _interopRequireDefault(require_comment2());
      var _id = _interopRequireDefault(require_id());
      var _nesting = _interopRequireDefault(require_nesting());
      var _pseudo = _interopRequireDefault(require_pseudo());
      var _root = _interopRequireDefault(require_root2());
      var _selector = _interopRequireDefault(require_selector());
      var _string = _interopRequireDefault(require_string());
      var _tag = _interopRequireDefault(require_tag());
      var _universal = _interopRequireDefault(require_universal());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var attribute = function attribute2(opts) {
        return new _attribute["default"](opts);
      };
      exports.attribute = attribute;
      var className = function className2(opts) {
        return new _className["default"](opts);
      };
      exports.className = className;
      var combinator = function combinator2(opts) {
        return new _combinator["default"](opts);
      };
      exports.combinator = combinator;
      var comment3 = function comment4(opts) {
        return new _comment["default"](opts);
      };
      exports.comment = comment3;
      var id = function id2(opts) {
        return new _id["default"](opts);
      };
      exports.id = id;
      var nesting = function nesting2(opts) {
        return new _nesting["default"](opts);
      };
      exports.nesting = nesting;
      var pseudo = function pseudo2(opts) {
        return new _pseudo["default"](opts);
      };
      exports.pseudo = pseudo;
      var root12 = function root13(opts) {
        return new _root["default"](opts);
      };
      exports.root = root12;
      var selector = function selector2(opts) {
        return new _selector["default"](opts);
      };
      exports.selector = selector;
      var string = function string2(opts) {
        return new _string["default"](opts);
      };
      exports.string = string;
      var tag = function tag2(opts) {
        return new _tag["default"](opts);
      };
      exports.tag = tag;
      var universal = function universal2(opts) {
        return new _universal["default"](opts);
      };
      exports.universal = universal;
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/guards.js
  var require_guards = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/guards.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;
      exports.isContainer = isContainer;
      exports.isIdentifier = void 0;
      exports.isNamespace = isNamespace;
      exports.isNesting = void 0;
      exports.isNode = isNode;
      exports.isPseudo = void 0;
      exports.isPseudoClass = isPseudoClass;
      exports.isPseudoElement = isPseudoElement2;
      exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = void 0;
      var _types = require_types();
      var _IS_TYPE;
      var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
      function isNode(node) {
        return typeof node === "object" && IS_TYPE[node.type];
      }
      function isNodeType(type, node) {
        return isNode(node) && node.type === type;
      }
      var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
      exports.isAttribute = isAttribute;
      var isClassName = isNodeType.bind(null, _types.CLASS);
      exports.isClassName = isClassName;
      var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
      exports.isCombinator = isCombinator;
      var isComment = isNodeType.bind(null, _types.COMMENT);
      exports.isComment = isComment;
      var isIdentifier = isNodeType.bind(null, _types.ID);
      exports.isIdentifier = isIdentifier;
      var isNesting = isNodeType.bind(null, _types.NESTING);
      exports.isNesting = isNesting;
      var isPseudo = isNodeType.bind(null, _types.PSEUDO);
      exports.isPseudo = isPseudo;
      var isRoot2 = isNodeType.bind(null, _types.ROOT);
      exports.isRoot = isRoot2;
      var isSelector = isNodeType.bind(null, _types.SELECTOR);
      exports.isSelector = isSelector;
      var isString = isNodeType.bind(null, _types.STRING);
      exports.isString = isString;
      var isTag = isNodeType.bind(null, _types.TAG);
      exports.isTag = isTag;
      var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
      exports.isUniversal = isUniversal;
      function isPseudoElement2(node) {
        return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after" || node.value.toLowerCase() === ":first-letter" || node.value.toLowerCase() === ":first-line");
      }
      function isPseudoClass(node) {
        return isPseudo(node) && !isPseudoElement2(node);
      }
      function isContainer(node) {
        return !!(isNode(node) && node.walk);
      }
      function isNamespace(node) {
        return isAttribute(node) || isTag(node);
      }
    }
  });

  // node_modules/postcss-selector-parser/dist/selectors/index.js
  var require_selectors = __commonJS({
    "node_modules/postcss-selector-parser/dist/selectors/index.js"(exports) {
      "use strict";
      exports.__esModule = true;
      var _types = require_types();
      Object.keys(_types).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _types[key]) return;
        exports[key] = _types[key];
      });
      var _constructors = require_constructors();
      Object.keys(_constructors).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _constructors[key]) return;
        exports[key] = _constructors[key];
      });
      var _guards = require_guards();
      Object.keys(_guards).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _guards[key]) return;
        exports[key] = _guards[key];
      });
    }
  });

  // node_modules/postcss-selector-parser/dist/index.js
  var require_dist = __commonJS({
    "node_modules/postcss-selector-parser/dist/index.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _processor = _interopRequireDefault(require_processor2());
      var selectors = _interopRequireWildcard(require_selectors());
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var parser5 = function parser6(processor) {
        return new _processor["default"](processor);
      };
      Object.assign(parser5, selectors);
      delete parser5.__esModule;
      var _default = parser5;
      exports["default"] = _default;
      module.exports = exports.default;
    }
  });

  // node_modules/postcss-nested/index.js
  var require_postcss_nested = __commonJS({
    "node_modules/postcss-nested/index.js"(exports, module) {
      var parser5 = require_dist();
      function parse3(str, rule2) {
        let nodes;
        let saver = parser5((parsed) => {
          nodes = parsed;
        });
        try {
          saver.processSync(str);
        } catch (e) {
          if (str.includes(":")) {
            throw rule2 ? rule2.error("Missed semicolon") : e;
          } else {
            throw rule2 ? rule2.error(e.message) : e;
          }
        }
        return nodes.at(0);
      }
      function replace(nodes, parent) {
        let replaced = false;
        nodes.each((i) => {
          if (i.type === "nesting") {
            let clonedParent = parent.clone();
            if (i.value !== "&") {
              i.replaceWith(parse3(i.value.replace("&", clonedParent.toString())));
            } else {
              i.replaceWith(clonedParent);
            }
            replaced = true;
          } else if (i.nodes) {
            if (replace(i, parent)) {
              replaced = true;
            }
          }
        });
        return replaced;
      }
      function selectors(parent, child2) {
        let result = [];
        parent.selectors.forEach((i) => {
          let parentNode = parse3(i, parent);
          child2.selectors.forEach((j) => {
            if (j.length) {
              let node = parse3(j, child2);
              let replaced = replace(node, parentNode);
              if (!replaced) {
                node.prepend(parser5.combinator({ value: " " }));
                node.prepend(parentNode.clone());
              }
              result.push(node.toString());
            }
          });
        });
        return result;
      }
      function pickComment(comment3, after) {
        if (comment3 && comment3.type === "comment") {
          after.after(comment3);
          return comment3;
        } else {
          return after;
        }
      }
      function createFnAtruleChilds(bubble) {
        return function atruleChilds(rule2, atrule, bubbling) {
          let children = [];
          atrule.each((child2) => {
            if (child2.type === "comment") {
              children.push(child2);
            } else if (child2.type === "decl") {
              children.push(child2);
            } else if (child2.type === "rule" && bubbling) {
              child2.selectors = selectors(rule2, child2);
            } else if (child2.type === "atrule") {
              if (child2.nodes && bubble[child2.name]) {
                atruleChilds(rule2, child2, true);
              } else {
                children.push(child2);
              }
            }
          });
          if (bubbling) {
            if (children.length) {
              let clone = rule2.clone({ nodes: [] });
              for (let child2 of children) {
                clone.append(child2);
              }
              atrule.prepend(clone);
            }
          }
        };
      }
      function pickDeclarations(selector, declarations, after, Rule2) {
        let parent = new Rule2({
          selector,
          nodes: []
        });
        for (let declaration of declarations) {
          parent.append(declaration);
        }
        after.after(parent);
        return parent;
      }
      function atruleNames(defaults3, custom) {
        let list3 = {};
        for (let i of defaults3) {
          list3[i] = true;
        }
        if (custom) {
          for (let i of custom) {
            let name = i.replace(/^@/, "");
            list3[name] = true;
          }
        }
        return list3;
      }
      module.exports = (opts = {}) => {
        let bubble = atruleNames(["media", "supports"], opts.bubble);
        let atruleChilds = createFnAtruleChilds(bubble);
        let unwrap = atruleNames(
          [
            "document",
            "font-face",
            "keyframes",
            "-webkit-keyframes",
            "-moz-keyframes"
          ],
          opts.unwrap
        );
        let preserveEmpty = opts.preserveEmpty;
        return {
          postcssPlugin: "postcss-nested",
          Rule(rule2, { Rule: Rule2 }) {
            let unwrapped = false;
            let after = rule2;
            let copyDeclarations = false;
            let declarations = [];
            rule2.each((child2) => {
              if (child2.type === "rule") {
                if (declarations.length) {
                  after = pickDeclarations(rule2.selector, declarations, after, Rule2);
                  declarations = [];
                }
                copyDeclarations = true;
                unwrapped = true;
                child2.selectors = selectors(rule2, child2);
                after = pickComment(child2.prev(), after);
                after.after(child2);
                after = child2;
              } else if (child2.type === "atrule") {
                if (declarations.length) {
                  after = pickDeclarations(rule2.selector, declarations, after, Rule2);
                  declarations = [];
                }
                if (child2.name === "at-root") {
                  unwrapped = true;
                  atruleChilds(rule2, child2, false);
                  let nodes = child2.nodes;
                  if (child2.params) {
                    nodes = new Rule2({ selector: child2.params, nodes });
                  }
                  after.after(nodes);
                  after = nodes;
                  child2.remove();
                } else if (bubble[child2.name]) {
                  copyDeclarations = true;
                  unwrapped = true;
                  atruleChilds(rule2, child2, true);
                  after = pickComment(child2.prev(), after);
                  after.after(child2);
                  after = child2;
                } else if (unwrap[child2.name]) {
                  copyDeclarations = true;
                  unwrapped = true;
                  atruleChilds(rule2, child2, false);
                  after = pickComment(child2.prev(), after);
                  after.after(child2);
                  after = child2;
                } else if (copyDeclarations) {
                  declarations.push(child2);
                }
              } else if (child2.type === "decl" && copyDeclarations) {
                declarations.push(child2);
              }
            });
            if (declarations.length) {
              after = pickDeclarations(rule2.selector, declarations, after, Rule2);
            }
            if (unwrapped && preserveEmpty !== true) {
              rule2.raws.semicolon = true;
              if (rule2.nodes.length === 0) rule2.remove();
            }
          }
        };
      };
      module.exports.postcss = true;
    }
  });

  // node_modules/camelcase-css/index-es5.js
  var require_index_es5 = __commonJS({
    "node_modules/camelcase-css/index-es5.js"(exports, module) {
      "use strict";
      var pattern2 = /-(\w|$)/g;
      var callback = function callback2(dashChar, char) {
        return char.toUpperCase();
      };
      var camelCaseCSS = function camelCaseCSS2(property) {
        property = property.toLowerCase();
        if (property === "float") {
          return "cssFloat";
        } else if (property.charCodeAt(0) === 45 && property.charCodeAt(1) === 109 && property.charCodeAt(2) === 115 && property.charCodeAt(3) === 45) {
          return property.substr(1).replace(pattern2, callback);
        } else {
          return property.replace(pattern2, callback);
        }
      };
      module.exports = camelCaseCSS;
    }
  });

  // node_modules/postcss-js/objectifier.js
  var require_objectifier = __commonJS({
    "node_modules/postcss-js/objectifier.js"(exports, module) {
      var camelcase = require_index_es5();
      var UNITLESS = {
        boxFlex: true,
        boxFlexGroup: true,
        columnCount: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        strokeDashoffset: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      function atRule2(node) {
        if (typeof node.nodes === "undefined") {
          return true;
        } else {
          return process2(node);
        }
      }
      function process2(node) {
        let name;
        let result = {};
        node.each((child2) => {
          if (child2.type === "atrule") {
            name = "@" + child2.name;
            if (child2.params) name += " " + child2.params;
            if (typeof result[name] === "undefined") {
              result[name] = atRule2(child2);
            } else if (Array.isArray(result[name])) {
              result[name].push(atRule2(child2));
            } else {
              result[name] = [result[name], atRule2(child2)];
            }
          } else if (child2.type === "rule") {
            let body = process2(child2);
            if (result[child2.selector]) {
              for (let i in body) {
                result[child2.selector][i] = body[i];
              }
            } else {
              result[child2.selector] = body;
            }
          } else if (child2.type === "decl") {
            if (child2.prop[0] === "-" && child2.prop[1] === "-") {
              name = child2.prop;
            } else if (child2.parent && child2.parent.selector === ":export") {
              name = child2.prop;
            } else {
              name = camelcase(child2.prop);
            }
            let value2 = child2.value;
            if (!isNaN(child2.value) && UNITLESS[name]) {
              value2 = parseFloat(child2.value);
            }
            if (child2.important) value2 += " !important";
            if (typeof result[name] === "undefined") {
              result[name] = value2;
            } else if (Array.isArray(result[name])) {
              result[name].push(value2);
            } else {
              result[name] = [result[name], value2];
            }
          }
        });
        return result;
      }
      module.exports = process2;
    }
  });

  // node_modules/postcss-js/parser.js
  var require_parser3 = __commonJS({
    "node_modules/postcss-js/parser.js"(exports, module) {
      var postcss2 = require_postcss();
      var IMPORTANT = /\s*!important\s*$/i;
      var UNITLESS = {
        "box-flex": true,
        "box-flex-group": true,
        "column-count": true,
        "flex": true,
        "flex-grow": true,
        "flex-positive": true,
        "flex-shrink": true,
        "flex-negative": true,
        "font-weight": true,
        "line-clamp": true,
        "line-height": true,
        "opacity": true,
        "order": true,
        "orphans": true,
        "tab-size": true,
        "widows": true,
        "z-index": true,
        "zoom": true,
        "fill-opacity": true,
        "stroke-dashoffset": true,
        "stroke-opacity": true,
        "stroke-width": true
      };
      function dashify(str) {
        return str.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
      }
      function decl2(parent, name, value2) {
        if (value2 === false || value2 === null) return;
        if (!name.startsWith("--")) {
          name = dashify(name);
        }
        if (typeof value2 === "number") {
          if (value2 === 0 || UNITLESS[name]) {
            value2 = value2.toString();
          } else {
            value2 += "px";
          }
        }
        if (name === "css-float") name = "float";
        if (IMPORTANT.test(value2)) {
          value2 = value2.replace(IMPORTANT, "");
          parent.push(postcss2.decl({ prop: name, value: value2, important: true }));
        } else {
          parent.push(postcss2.decl({ prop: name, value: value2 }));
        }
      }
      function atRule2(parent, parts, value2) {
        let node = postcss2.atRule({ name: parts[1], params: parts[3] || "" });
        if (typeof value2 === "object") {
          node.nodes = [];
          parse3(value2, node);
        }
        parent.push(node);
      }
      function parse3(obj, parent) {
        let name, value2, node;
        for (name in obj) {
          value2 = obj[name];
          if (value2 === null || typeof value2 === "undefined") {
            continue;
          } else if (name[0] === "@") {
            let parts = name.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
            if (Array.isArray(value2)) {
              for (let i of value2) {
                atRule2(parent, parts, i);
              }
            } else {
              atRule2(parent, parts, value2);
            }
          } else if (Array.isArray(value2)) {
            for (let i of value2) {
              decl2(parent, name, i);
            }
          } else if (typeof value2 === "object") {
            node = postcss2.rule({ selector: name });
            parse3(value2, node);
            parent.push(node);
          } else {
            decl2(parent, name, value2);
          }
        }
      }
      module.exports = function(obj) {
        let root12 = postcss2.root();
        parse3(obj, root12);
        return root12;
      };
    }
  });

  // node_modules/postcss-js/process-result.js
  var require_process_result = __commonJS({
    "node_modules/postcss-js/process-result.js"(exports, module) {
      var objectify2 = require_objectifier();
      module.exports = function processResult(result) {
        if (console && console.warn) {
          result.warnings().forEach((warn2) => {
            let source2 = warn2.plugin || "PostCSS";
            console.warn(source2 + ": " + warn2.text);
          });
        }
        return objectify2(result.root);
      };
    }
  });

  // node_modules/postcss-js/async.js
  var require_async = __commonJS({
    "node_modules/postcss-js/async.js"(exports, module) {
      var postcss2 = require_postcss();
      var processResult = require_process_result();
      var parse3 = require_parser3();
      module.exports = function async2(plugins) {
        let processor = postcss2(plugins);
        return async (input) => {
          let result = await processor.process(input, {
            parser: parse3,
            from: void 0
          });
          return processResult(result);
        };
      };
    }
  });

  // node_modules/postcss-js/sync.js
  var require_sync = __commonJS({
    "node_modules/postcss-js/sync.js"(exports, module) {
      var postcss2 = require_postcss();
      var processResult = require_process_result();
      var parse3 = require_parser3();
      module.exports = function(plugins) {
        let processor = postcss2(plugins);
        return (input) => {
          let result = processor.process(input, { parser: parse3, from: void 0 });
          return processResult(result);
        };
      };
    }
  });

  // node_modules/postcss-js/index.js
  var require_postcss_js = __commonJS({
    "node_modules/postcss-js/index.js"(exports, module) {
      var objectify2 = require_objectifier();
      var parse3 = require_parser3();
      var async2 = require_async();
      var sync2 = require_sync();
      module.exports = {
        objectify: objectify2,
        parse: parse3,
        async: async2,
        sync: sync2
      };
    }
  });

  // node_modules/dlv/dist/dlv.umd.js
  var require_dlv_umd = __commonJS({
    "node_modules/dlv/dist/dlv.umd.js"(exports, module) {
      !function(t, n) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = function(t2, n2, e, i, o) {
          for (n2 = n2.split ? n2.split(".") : n2, i = 0; i < n2.length; i++) t2 = t2 ? t2[n2[i]] : o;
          return t2 === o ? e : t2;
        } : "function" == typeof define && define.amd ? define(function() {
          return function(t2, n2, e, i, o) {
            for (n2 = n2.split ? n2.split(".") : n2, i = 0; i < n2.length; i++) t2 = t2 ? t2[n2[i]] : o;
            return t2 === o ? e : t2;
          };
        }) : t.dlv = function(t2, n2, e, i, o) {
          for (n2 = n2.split ? n2.split(".") : n2, i = 0; i < n2.length; i++) t2 = t2 ? t2[n2[i]] : o;
          return t2 === o ? e : t2;
        };
      }(exports);
    }
  });

  // node_modules/didyoumean/didYouMean-1.2.1.js
  var require_didYouMean_1_2_1 = __commonJS({
    "node_modules/didyoumean/didYouMean-1.2.1.js"(exports, module) {
      (function() {
        "use strict";
        function didYouMean2(str, list3, key) {
          if (!str) return null;
          if (!didYouMean2.caseSensitive) {
            str = str.toLowerCase();
          }
          var thresholdRelative = didYouMean2.threshold === null ? null : didYouMean2.threshold * str.length, thresholdAbsolute = didYouMean2.thresholdAbsolute, winningVal;
          if (thresholdRelative !== null && thresholdAbsolute !== null) winningVal = Math.min(thresholdRelative, thresholdAbsolute);
          else if (thresholdRelative !== null) winningVal = thresholdRelative;
          else if (thresholdAbsolute !== null) winningVal = thresholdAbsolute;
          else winningVal = null;
          var winner, candidate, testCandidate, val, i, len = list3.length;
          for (i = 0; i < len; i++) {
            candidate = list3[i];
            if (key) {
              candidate = candidate[key];
            }
            if (!candidate) {
              continue;
            }
            if (!didYouMean2.caseSensitive) {
              testCandidate = candidate.toLowerCase();
            } else {
              testCandidate = candidate;
            }
            val = getEditDistance(str, testCandidate, winningVal);
            if (winningVal === null || val < winningVal) {
              winningVal = val;
              if (key && didYouMean2.returnWinningObject) winner = list3[i];
              else winner = candidate;
              if (didYouMean2.returnFirstMatch) return winner;
            }
          }
          return winner || didYouMean2.nullResultValue;
        }
        didYouMean2.threshold = 0.4;
        didYouMean2.thresholdAbsolute = 20;
        didYouMean2.caseSensitive = false;
        didYouMean2.nullResultValue = null;
        didYouMean2.returnWinningObject = null;
        didYouMean2.returnFirstMatch = false;
        if (typeof module !== "undefined" && module.exports) {
          module.exports = didYouMean2;
        } else {
          window.didYouMean = didYouMean2;
        }
        var MAX_INT = Math.pow(2, 32) - 1;
        function getEditDistance(a, b, max2) {
          max2 = max2 || max2 === 0 ? max2 : MAX_INT;
          var lena = a.length;
          var lenb = b.length;
          if (lena === 0) return Math.min(max2 + 1, lenb);
          if (lenb === 0) return Math.min(max2 + 1, lena);
          if (Math.abs(lena - lenb) > max2) return max2 + 1;
          var matrix = [], i, j, colMin, minJ, maxJ;
          for (i = 0; i <= lenb; i++) {
            matrix[i] = [i];
          }
          for (j = 0; j <= lena; j++) {
            matrix[0][j] = j;
          }
          for (i = 1; i <= lenb; i++) {
            colMin = MAX_INT;
            minJ = 1;
            if (i > max2) minJ = i - max2;
            maxJ = lenb + 1;
            if (maxJ > max2 + i) maxJ = max2 + i;
            for (j = 1; j <= lena; j++) {
              if (j < minJ || j > maxJ) {
                matrix[i][j] = max2 + 1;
              } else {
                if (b.charAt(i - 1) === a.charAt(j - 1)) {
                  matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                  matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1,
                    // Substitute
                    Math.min(
                      matrix[i][j - 1] + 1,
                      // Insert
                      matrix[i - 1][j] + 1
                    )
                  );
                }
              }
              if (matrix[i][j] < colMin) colMin = matrix[i][j];
            }
            if (colMin > max2) return max2 + 1;
          }
          return matrix[lenb][lena];
        }
      })();
    }
  });

  // node_modules/html-entities/lib/named-references.js
  var require_named_references = __commonJS({
    "node_modules/html-entities/lib/named-references.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bodyRegExps = { xml: /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g, html4: /&notin;|&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g, html5: /&centerdot;|&copysr;|&divideontimes;|&gtcc;|&gtcir;|&gtdot;|&gtlPar;|&gtquest;|&gtrapprox;|&gtrarr;|&gtrdot;|&gtreqless;|&gtreqqless;|&gtrless;|&gtrsim;|&ltcc;|&ltcir;|&ltdot;|&lthree;|&ltimes;|&ltlarr;|&ltquest;|&ltrPar;|&ltri;|&ltrie;|&ltrif;|&notin;|&notinE;|&notindot;|&notinva;|&notinvb;|&notinvc;|&notni;|&notniva;|&notnivb;|&notnivc;|&parallel;|&timesb;|&timesbar;|&timesd;|&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g };
      exports.namedReferences = { xml: { entities: { "&lt;": "<", "&gt;": ">", "&quot;": '"', "&apos;": "'", "&amp;": "&" }, characters: { "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&apos;", "&": "&amp;" } }, html4: { entities: { "&apos;": "'", "&nbsp": "\xA0", "&nbsp;": "\xA0", "&iexcl": "\xA1", "&iexcl;": "\xA1", "&cent": "\xA2", "&cent;": "\xA2", "&pound": "\xA3", "&pound;": "\xA3", "&curren": "\xA4", "&curren;": "\xA4", "&yen": "\xA5", "&yen;": "\xA5", "&brvbar": "\xA6", "&brvbar;": "\xA6", "&sect": "\xA7", "&sect;": "\xA7", "&uml": "\xA8", "&uml;": "\xA8", "&copy": "\xA9", "&copy;": "\xA9", "&ordf": "\xAA", "&ordf;": "\xAA", "&laquo": "\xAB", "&laquo;": "\xAB", "&not": "\xAC", "&not;": "\xAC", "&shy": "\xAD", "&shy;": "\xAD", "&reg": "\xAE", "&reg;": "\xAE", "&macr": "\xAF", "&macr;": "\xAF", "&deg": "\xB0", "&deg;": "\xB0", "&plusmn": "\xB1", "&plusmn;": "\xB1", "&sup2": "\xB2", "&sup2;": "\xB2", "&sup3": "\xB3", "&sup3;": "\xB3", "&acute": "\xB4", "&acute;": "\xB4", "&micro": "\xB5", "&micro;": "\xB5", "&para": "\xB6", "&para;": "\xB6", "&middot": "\xB7", "&middot;": "\xB7", "&cedil": "\xB8", "&cedil;": "\xB8", "&sup1": "\xB9", "&sup1;": "\xB9", "&ordm": "\xBA", "&ordm;": "\xBA", "&raquo": "\xBB", "&raquo;": "\xBB", "&frac14": "\xBC", "&frac14;": "\xBC", "&frac12": "\xBD", "&frac12;": "\xBD", "&frac34": "\xBE", "&frac34;": "\xBE", "&iquest": "\xBF", "&iquest;": "\xBF", "&Agrave": "\xC0", "&Agrave;": "\xC0", "&Aacute": "\xC1", "&Aacute;": "\xC1", "&Acirc": "\xC2", "&Acirc;": "\xC2", "&Atilde": "\xC3", "&Atilde;": "\xC3", "&Auml": "\xC4", "&Auml;": "\xC4", "&Aring": "\xC5", "&Aring;": "\xC5", "&AElig": "\xC6", "&AElig;": "\xC6", "&Ccedil": "\xC7", "&Ccedil;": "\xC7", "&Egrave": "\xC8", "&Egrave;": "\xC8", "&Eacute": "\xC9", "&Eacute;": "\xC9", "&Ecirc": "\xCA", "&Ecirc;": "\xCA", "&Euml": "\xCB", "&Euml;": "\xCB", "&Igrave": "\xCC", "&Igrave;": "\xCC", "&Iacute": "\xCD", "&Iacute;": "\xCD", "&Icirc": "\xCE", "&Icirc;": "\xCE", "&Iuml": "\xCF", "&Iuml;": "\xCF", "&ETH": "\xD0", "&ETH;": "\xD0", "&Ntilde": "\xD1", "&Ntilde;": "\xD1", "&Ograve": "\xD2", "&Ograve;": "\xD2", "&Oacute": "\xD3", "&Oacute;": "\xD3", "&Ocirc": "\xD4", "&Ocirc;": "\xD4", "&Otilde": "\xD5", "&Otilde;": "\xD5", "&Ouml": "\xD6", "&Ouml;": "\xD6", "&times": "\xD7", "&times;": "\xD7", "&Oslash": "\xD8", "&Oslash;": "\xD8", "&Ugrave": "\xD9", "&Ugrave;": "\xD9", "&Uacute": "\xDA", "&Uacute;": "\xDA", "&Ucirc": "\xDB", "&Ucirc;": "\xDB", "&Uuml": "\xDC", "&Uuml;": "\xDC", "&Yacute": "\xDD", "&Yacute;": "\xDD", "&THORN": "\xDE", "&THORN;": "\xDE", "&szlig": "\xDF", "&szlig;": "\xDF", "&agrave": "\xE0", "&agrave;": "\xE0", "&aacute": "\xE1", "&aacute;": "\xE1", "&acirc": "\xE2", "&acirc;": "\xE2", "&atilde": "\xE3", "&atilde;": "\xE3", "&auml": "\xE4", "&auml;": "\xE4", "&aring": "\xE5", "&aring;": "\xE5", "&aelig": "\xE6", "&aelig;": "\xE6", "&ccedil": "\xE7", "&ccedil;": "\xE7", "&egrave": "\xE8", "&egrave;": "\xE8", "&eacute": "\xE9", "&eacute;": "\xE9", "&ecirc": "\xEA", "&ecirc;": "\xEA", "&euml": "\xEB", "&euml;": "\xEB", "&igrave": "\xEC", "&igrave;": "\xEC", "&iacute": "\xED", "&iacute;": "\xED", "&icirc": "\xEE", "&icirc;": "\xEE", "&iuml": "\xEF", "&iuml;": "\xEF", "&eth": "\xF0", "&eth;": "\xF0", "&ntilde": "\xF1", "&ntilde;": "\xF1", "&ograve": "\xF2", "&ograve;": "\xF2", "&oacute": "\xF3", "&oacute;": "\xF3", "&ocirc": "\xF4", "&ocirc;": "\xF4", "&otilde": "\xF5", "&otilde;": "\xF5", "&ouml": "\xF6", "&ouml;": "\xF6", "&divide": "\xF7", "&divide;": "\xF7", "&oslash": "\xF8", "&oslash;": "\xF8", "&ugrave": "\xF9", "&ugrave;": "\xF9", "&uacute": "\xFA", "&uacute;": "\xFA", "&ucirc": "\xFB", "&ucirc;": "\xFB", "&uuml": "\xFC", "&uuml;": "\xFC", "&yacute": "\xFD", "&yacute;": "\xFD", "&thorn": "\xFE", "&thorn;": "\xFE", "&yuml": "\xFF", "&yuml;": "\xFF", "&quot": '"', "&quot;": '"', "&amp": "&", "&amp;": "&", "&lt": "<", "&lt;": "<", "&gt": ">", "&gt;": ">", "&OElig;": "\u0152", "&oelig;": "\u0153", "&Scaron;": "\u0160", "&scaron;": "\u0161", "&Yuml;": "\u0178", "&circ;": "\u02C6", "&tilde;": "\u02DC", "&ensp;": "\u2002", "&emsp;": "\u2003", "&thinsp;": "\u2009", "&zwnj;": "\u200C", "&zwj;": "\u200D", "&lrm;": "\u200E", "&rlm;": "\u200F", "&ndash;": "\u2013", "&mdash;": "\u2014", "&lsquo;": "\u2018", "&rsquo;": "\u2019", "&sbquo;": "\u201A", "&ldquo;": "\u201C", "&rdquo;": "\u201D", "&bdquo;": "\u201E", "&dagger;": "\u2020", "&Dagger;": "\u2021", "&permil;": "\u2030", "&lsaquo;": "\u2039", "&rsaquo;": "\u203A", "&euro;": "\u20AC", "&fnof;": "\u0192", "&Alpha;": "\u0391", "&Beta;": "\u0392", "&Gamma;": "\u0393", "&Delta;": "\u0394", "&Epsilon;": "\u0395", "&Zeta;": "\u0396", "&Eta;": "\u0397", "&Theta;": "\u0398", "&Iota;": "\u0399", "&Kappa;": "\u039A", "&Lambda;": "\u039B", "&Mu;": "\u039C", "&Nu;": "\u039D", "&Xi;": "\u039E", "&Omicron;": "\u039F", "&Pi;": "\u03A0", "&Rho;": "\u03A1", "&Sigma;": "\u03A3", "&Tau;": "\u03A4", "&Upsilon;": "\u03A5", "&Phi;": "\u03A6", "&Chi;": "\u03A7", "&Psi;": "\u03A8", "&Omega;": "\u03A9", "&alpha;": "\u03B1", "&beta;": "\u03B2", "&gamma;": "\u03B3", "&delta;": "\u03B4", "&epsilon;": "\u03B5", "&zeta;": "\u03B6", "&eta;": "\u03B7", "&theta;": "\u03B8", "&iota;": "\u03B9", "&kappa;": "\u03BA", "&lambda;": "\u03BB", "&mu;": "\u03BC", "&nu;": "\u03BD", "&xi;": "\u03BE", "&omicron;": "\u03BF", "&pi;": "\u03C0", "&rho;": "\u03C1", "&sigmaf;": "\u03C2", "&sigma;": "\u03C3", "&tau;": "\u03C4", "&upsilon;": "\u03C5", "&phi;": "\u03C6", "&chi;": "\u03C7", "&psi;": "\u03C8", "&omega;": "\u03C9", "&thetasym;": "\u03D1", "&upsih;": "\u03D2", "&piv;": "\u03D6", "&bull;": "\u2022", "&hellip;": "\u2026", "&prime;": "\u2032", "&Prime;": "\u2033", "&oline;": "\u203E", "&frasl;": "\u2044", "&weierp;": "\u2118", "&image;": "\u2111", "&real;": "\u211C", "&trade;": "\u2122", "&alefsym;": "\u2135", "&larr;": "\u2190", "&uarr;": "\u2191", "&rarr;": "\u2192", "&darr;": "\u2193", "&harr;": "\u2194", "&crarr;": "\u21B5", "&lArr;": "\u21D0", "&uArr;": "\u21D1", "&rArr;": "\u21D2", "&dArr;": "\u21D3", "&hArr;": "\u21D4", "&forall;": "\u2200", "&part;": "\u2202", "&exist;": "\u2203", "&empty;": "\u2205", "&nabla;": "\u2207", "&isin;": "\u2208", "&notin;": "\u2209", "&ni;": "\u220B", "&prod;": "\u220F", "&sum;": "\u2211", "&minus;": "\u2212", "&lowast;": "\u2217", "&radic;": "\u221A", "&prop;": "\u221D", "&infin;": "\u221E", "&ang;": "\u2220", "&and;": "\u2227", "&or;": "\u2228", "&cap;": "\u2229", "&cup;": "\u222A", "&int;": "\u222B", "&there4;": "\u2234", "&sim;": "\u223C", "&cong;": "\u2245", "&asymp;": "\u2248", "&ne;": "\u2260", "&equiv;": "\u2261", "&le;": "\u2264", "&ge;": "\u2265", "&sub;": "\u2282", "&sup;": "\u2283", "&nsub;": "\u2284", "&sube;": "\u2286", "&supe;": "\u2287", "&oplus;": "\u2295", "&otimes;": "\u2297", "&perp;": "\u22A5", "&sdot;": "\u22C5", "&lceil;": "\u2308", "&rceil;": "\u2309", "&lfloor;": "\u230A", "&rfloor;": "\u230B", "&lang;": "\u2329", "&rang;": "\u232A", "&loz;": "\u25CA", "&spades;": "\u2660", "&clubs;": "\u2663", "&hearts;": "\u2665", "&diams;": "\u2666" }, characters: { "'": "&apos;", "\xA0": "&nbsp;", "\xA1": "&iexcl;", "\xA2": "&cent;", "\xA3": "&pound;", "\xA4": "&curren;", "\xA5": "&yen;", "\xA6": "&brvbar;", "\xA7": "&sect;", "\xA8": "&uml;", "\xA9": "&copy;", "\xAA": "&ordf;", "\xAB": "&laquo;", "\xAC": "&not;", "\xAD": "&shy;", "\xAE": "&reg;", "\xAF": "&macr;", "\xB0": "&deg;", "\xB1": "&plusmn;", "\xB2": "&sup2;", "\xB3": "&sup3;", "\xB4": "&acute;", "\xB5": "&micro;", "\xB6": "&para;", "\xB7": "&middot;", "\xB8": "&cedil;", "\xB9": "&sup1;", "\xBA": "&ordm;", "\xBB": "&raquo;", "\xBC": "&frac14;", "\xBD": "&frac12;", "\xBE": "&frac34;", "\xBF": "&iquest;", "\xC0": "&Agrave;", "\xC1": "&Aacute;", "\xC2": "&Acirc;", "\xC3": "&Atilde;", "\xC4": "&Auml;", "\xC5": "&Aring;", "\xC6": "&AElig;", "\xC7": "&Ccedil;", "\xC8": "&Egrave;", "\xC9": "&Eacute;", "\xCA": "&Ecirc;", "\xCB": "&Euml;", "\xCC": "&Igrave;", "\xCD": "&Iacute;", "\xCE": "&Icirc;", "\xCF": "&Iuml;", "\xD0": "&ETH;", "\xD1": "&Ntilde;", "\xD2": "&Ograve;", "\xD3": "&Oacute;", "\xD4": "&Ocirc;", "\xD5": "&Otilde;", "\xD6": "&Ouml;", "\xD7": "&times;", "\xD8": "&Oslash;", "\xD9": "&Ugrave;", "\xDA": "&Uacute;", "\xDB": "&Ucirc;", "\xDC": "&Uuml;", "\xDD": "&Yacute;", "\xDE": "&THORN;", "\xDF": "&szlig;", "\xE0": "&agrave;", "\xE1": "&aacute;", "\xE2": "&acirc;", "\xE3": "&atilde;", "\xE4": "&auml;", "\xE5": "&aring;", "\xE6": "&aelig;", "\xE7": "&ccedil;", "\xE8": "&egrave;", "\xE9": "&eacute;", "\xEA": "&ecirc;", "\xEB": "&euml;", "\xEC": "&igrave;", "\xED": "&iacute;", "\xEE": "&icirc;", "\xEF": "&iuml;", "\xF0": "&eth;", "\xF1": "&ntilde;", "\xF2": "&ograve;", "\xF3": "&oacute;", "\xF4": "&ocirc;", "\xF5": "&otilde;", "\xF6": "&ouml;", "\xF7": "&divide;", "\xF8": "&oslash;", "\xF9": "&ugrave;", "\xFA": "&uacute;", "\xFB": "&ucirc;", "\xFC": "&uuml;", "\xFD": "&yacute;", "\xFE": "&thorn;", "\xFF": "&yuml;", '"': "&quot;", "&": "&amp;", "<": "&lt;", ">": "&gt;", "\u0152": "&OElig;", "\u0153": "&oelig;", "\u0160": "&Scaron;", "\u0161": "&scaron;", "\u0178": "&Yuml;", "\u02C6": "&circ;", "\u02DC": "&tilde;", "\u2002": "&ensp;", "\u2003": "&emsp;", "\u2009": "&thinsp;", "\u200C": "&zwnj;", "\u200D": "&zwj;", "\u200E": "&lrm;", "\u200F": "&rlm;", "\u2013": "&ndash;", "\u2014": "&mdash;", "\u2018": "&lsquo;", "\u2019": "&rsquo;", "\u201A": "&sbquo;", "\u201C": "&ldquo;", "\u201D": "&rdquo;", "\u201E": "&bdquo;", "\u2020": "&dagger;", "\u2021": "&Dagger;", "\u2030": "&permil;", "\u2039": "&lsaquo;", "\u203A": "&rsaquo;", "\u20AC": "&euro;", "\u0192": "&fnof;", "\u0391": "&Alpha;", "\u0392": "&Beta;", "\u0393": "&Gamma;", "\u0394": "&Delta;", "\u0395": "&Epsilon;", "\u0396": "&Zeta;", "\u0397": "&Eta;", "\u0398": "&Theta;", "\u0399": "&Iota;", "\u039A": "&Kappa;", "\u039B": "&Lambda;", "\u039C": "&Mu;", "\u039D": "&Nu;", "\u039E": "&Xi;", "\u039F": "&Omicron;", "\u03A0": "&Pi;", "\u03A1": "&Rho;", "\u03A3": "&Sigma;", "\u03A4": "&Tau;", "\u03A5": "&Upsilon;", "\u03A6": "&Phi;", "\u03A7": "&Chi;", "\u03A8": "&Psi;", "\u03A9": "&Omega;", "\u03B1": "&alpha;", "\u03B2": "&beta;", "\u03B3": "&gamma;", "\u03B4": "&delta;", "\u03B5": "&epsilon;", "\u03B6": "&zeta;", "\u03B7": "&eta;", "\u03B8": "&theta;", "\u03B9": "&iota;", "\u03BA": "&kappa;", "\u03BB": "&lambda;", "\u03BC": "&mu;", "\u03BD": "&nu;", "\u03BE": "&xi;", "\u03BF": "&omicron;", "\u03C0": "&pi;", "\u03C1": "&rho;", "\u03C2": "&sigmaf;", "\u03C3": "&sigma;", "\u03C4": "&tau;", "\u03C5": "&upsilon;", "\u03C6": "&phi;", "\u03C7": "&chi;", "\u03C8": "&psi;", "\u03C9": "&omega;", "\u03D1": "&thetasym;", "\u03D2": "&upsih;", "\u03D6": "&piv;", "\u2022": "&bull;", "\u2026": "&hellip;", "\u2032": "&prime;", "\u2033": "&Prime;", "\u203E": "&oline;", "\u2044": "&frasl;", "\u2118": "&weierp;", "\u2111": "&image;", "\u211C": "&real;", "\u2122": "&trade;", "\u2135": "&alefsym;", "\u2190": "&larr;", "\u2191": "&uarr;", "\u2192": "&rarr;", "\u2193": "&darr;", "\u2194": "&harr;", "\u21B5": "&crarr;", "\u21D0": "&lArr;", "\u21D1": "&uArr;", "\u21D2": "&rArr;", "\u21D3": "&dArr;", "\u21D4": "&hArr;", "\u2200": "&forall;", "\u2202": "&part;", "\u2203": "&exist;", "\u2205": "&empty;", "\u2207": "&nabla;", "\u2208": "&isin;", "\u2209": "&notin;", "\u220B": "&ni;", "\u220F": "&prod;", "\u2211": "&sum;", "\u2212": "&minus;", "\u2217": "&lowast;", "\u221A": "&radic;", "\u221D": "&prop;", "\u221E": "&infin;", "\u2220": "&ang;", "\u2227": "&and;", "\u2228": "&or;", "\u2229": "&cap;", "\u222A": "&cup;", "\u222B": "&int;", "\u2234": "&there4;", "\u223C": "&sim;", "\u2245": "&cong;", "\u2248": "&asymp;", "\u2260": "&ne;", "\u2261": "&equiv;", "\u2264": "&le;", "\u2265": "&ge;", "\u2282": "&sub;", "\u2283": "&sup;", "\u2284": "&nsub;", "\u2286": "&sube;", "\u2287": "&supe;", "\u2295": "&oplus;", "\u2297": "&otimes;", "\u22A5": "&perp;", "\u22C5": "&sdot;", "\u2308": "&lceil;", "\u2309": "&rceil;", "\u230A": "&lfloor;", "\u230B": "&rfloor;", "\u2329": "&lang;", "\u232A": "&rang;", "\u25CA": "&loz;", "\u2660": "&spades;", "\u2663": "&clubs;", "\u2665": "&hearts;", "\u2666": "&diams;" } }, html5: { entities: { "&AElig": "\xC6", "&AElig;": "\xC6", "&AMP": "&", "&AMP;": "&", "&Aacute": "\xC1", "&Aacute;": "\xC1", "&Abreve;": "\u0102", "&Acirc": "\xC2", "&Acirc;": "\xC2", "&Acy;": "\u0410", "&Afr;": "\u{1D504}", "&Agrave": "\xC0", "&Agrave;": "\xC0", "&Alpha;": "\u0391", "&Amacr;": "\u0100", "&And;": "\u2A53", "&Aogon;": "\u0104", "&Aopf;": "\u{1D538}", "&ApplyFunction;": "\u2061", "&Aring": "\xC5", "&Aring;": "\xC5", "&Ascr;": "\u{1D49C}", "&Assign;": "\u2254", "&Atilde": "\xC3", "&Atilde;": "\xC3", "&Auml": "\xC4", "&Auml;": "\xC4", "&Backslash;": "\u2216", "&Barv;": "\u2AE7", "&Barwed;": "\u2306", "&Bcy;": "\u0411", "&Because;": "\u2235", "&Bernoullis;": "\u212C", "&Beta;": "\u0392", "&Bfr;": "\u{1D505}", "&Bopf;": "\u{1D539}", "&Breve;": "\u02D8", "&Bscr;": "\u212C", "&Bumpeq;": "\u224E", "&CHcy;": "\u0427", "&COPY": "\xA9", "&COPY;": "\xA9", "&Cacute;": "\u0106", "&Cap;": "\u22D2", "&CapitalDifferentialD;": "\u2145", "&Cayleys;": "\u212D", "&Ccaron;": "\u010C", "&Ccedil": "\xC7", "&Ccedil;": "\xC7", "&Ccirc;": "\u0108", "&Cconint;": "\u2230", "&Cdot;": "\u010A", "&Cedilla;": "\xB8", "&CenterDot;": "\xB7", "&Cfr;": "\u212D", "&Chi;": "\u03A7", "&CircleDot;": "\u2299", "&CircleMinus;": "\u2296", "&CirclePlus;": "\u2295", "&CircleTimes;": "\u2297", "&ClockwiseContourIntegral;": "\u2232", "&CloseCurlyDoubleQuote;": "\u201D", "&CloseCurlyQuote;": "\u2019", "&Colon;": "\u2237", "&Colone;": "\u2A74", "&Congruent;": "\u2261", "&Conint;": "\u222F", "&ContourIntegral;": "\u222E", "&Copf;": "\u2102", "&Coproduct;": "\u2210", "&CounterClockwiseContourIntegral;": "\u2233", "&Cross;": "\u2A2F", "&Cscr;": "\u{1D49E}", "&Cup;": "\u22D3", "&CupCap;": "\u224D", "&DD;": "\u2145", "&DDotrahd;": "\u2911", "&DJcy;": "\u0402", "&DScy;": "\u0405", "&DZcy;": "\u040F", "&Dagger;": "\u2021", "&Darr;": "\u21A1", "&Dashv;": "\u2AE4", "&Dcaron;": "\u010E", "&Dcy;": "\u0414", "&Del;": "\u2207", "&Delta;": "\u0394", "&Dfr;": "\u{1D507}", "&DiacriticalAcute;": "\xB4", "&DiacriticalDot;": "\u02D9", "&DiacriticalDoubleAcute;": "\u02DD", "&DiacriticalGrave;": "`", "&DiacriticalTilde;": "\u02DC", "&Diamond;": "\u22C4", "&DifferentialD;": "\u2146", "&Dopf;": "\u{1D53B}", "&Dot;": "\xA8", "&DotDot;": "\u20DC", "&DotEqual;": "\u2250", "&DoubleContourIntegral;": "\u222F", "&DoubleDot;": "\xA8", "&DoubleDownArrow;": "\u21D3", "&DoubleLeftArrow;": "\u21D0", "&DoubleLeftRightArrow;": "\u21D4", "&DoubleLeftTee;": "\u2AE4", "&DoubleLongLeftArrow;": "\u27F8", "&DoubleLongLeftRightArrow;": "\u27FA", "&DoubleLongRightArrow;": "\u27F9", "&DoubleRightArrow;": "\u21D2", "&DoubleRightTee;": "\u22A8", "&DoubleUpArrow;": "\u21D1", "&DoubleUpDownArrow;": "\u21D5", "&DoubleVerticalBar;": "\u2225", "&DownArrow;": "\u2193", "&DownArrowBar;": "\u2913", "&DownArrowUpArrow;": "\u21F5", "&DownBreve;": "\u0311", "&DownLeftRightVector;": "\u2950", "&DownLeftTeeVector;": "\u295E", "&DownLeftVector;": "\u21BD", "&DownLeftVectorBar;": "\u2956", "&DownRightTeeVector;": "\u295F", "&DownRightVector;": "\u21C1", "&DownRightVectorBar;": "\u2957", "&DownTee;": "\u22A4", "&DownTeeArrow;": "\u21A7", "&Downarrow;": "\u21D3", "&Dscr;": "\u{1D49F}", "&Dstrok;": "\u0110", "&ENG;": "\u014A", "&ETH": "\xD0", "&ETH;": "\xD0", "&Eacute": "\xC9", "&Eacute;": "\xC9", "&Ecaron;": "\u011A", "&Ecirc": "\xCA", "&Ecirc;": "\xCA", "&Ecy;": "\u042D", "&Edot;": "\u0116", "&Efr;": "\u{1D508}", "&Egrave": "\xC8", "&Egrave;": "\xC8", "&Element;": "\u2208", "&Emacr;": "\u0112", "&EmptySmallSquare;": "\u25FB", "&EmptyVerySmallSquare;": "\u25AB", "&Eogon;": "\u0118", "&Eopf;": "\u{1D53C}", "&Epsilon;": "\u0395", "&Equal;": "\u2A75", "&EqualTilde;": "\u2242", "&Equilibrium;": "\u21CC", "&Escr;": "\u2130", "&Esim;": "\u2A73", "&Eta;": "\u0397", "&Euml": "\xCB", "&Euml;": "\xCB", "&Exists;": "\u2203", "&ExponentialE;": "\u2147", "&Fcy;": "\u0424", "&Ffr;": "\u{1D509}", "&FilledSmallSquare;": "\u25FC", "&FilledVerySmallSquare;": "\u25AA", "&Fopf;": "\u{1D53D}", "&ForAll;": "\u2200", "&Fouriertrf;": "\u2131", "&Fscr;": "\u2131", "&GJcy;": "\u0403", "&GT": ">", "&GT;": ">", "&Gamma;": "\u0393", "&Gammad;": "\u03DC", "&Gbreve;": "\u011E", "&Gcedil;": "\u0122", "&Gcirc;": "\u011C", "&Gcy;": "\u0413", "&Gdot;": "\u0120", "&Gfr;": "\u{1D50A}", "&Gg;": "\u22D9", "&Gopf;": "\u{1D53E}", "&GreaterEqual;": "\u2265", "&GreaterEqualLess;": "\u22DB", "&GreaterFullEqual;": "\u2267", "&GreaterGreater;": "\u2AA2", "&GreaterLess;": "\u2277", "&GreaterSlantEqual;": "\u2A7E", "&GreaterTilde;": "\u2273", "&Gscr;": "\u{1D4A2}", "&Gt;": "\u226B", "&HARDcy;": "\u042A", "&Hacek;": "\u02C7", "&Hat;": "^", "&Hcirc;": "\u0124", "&Hfr;": "\u210C", "&HilbertSpace;": "\u210B", "&Hopf;": "\u210D", "&HorizontalLine;": "\u2500", "&Hscr;": "\u210B", "&Hstrok;": "\u0126", "&HumpDownHump;": "\u224E", "&HumpEqual;": "\u224F", "&IEcy;": "\u0415", "&IJlig;": "\u0132", "&IOcy;": "\u0401", "&Iacute": "\xCD", "&Iacute;": "\xCD", "&Icirc": "\xCE", "&Icirc;": "\xCE", "&Icy;": "\u0418", "&Idot;": "\u0130", "&Ifr;": "\u2111", "&Igrave": "\xCC", "&Igrave;": "\xCC", "&Im;": "\u2111", "&Imacr;": "\u012A", "&ImaginaryI;": "\u2148", "&Implies;": "\u21D2", "&Int;": "\u222C", "&Integral;": "\u222B", "&Intersection;": "\u22C2", "&InvisibleComma;": "\u2063", "&InvisibleTimes;": "\u2062", "&Iogon;": "\u012E", "&Iopf;": "\u{1D540}", "&Iota;": "\u0399", "&Iscr;": "\u2110", "&Itilde;": "\u0128", "&Iukcy;": "\u0406", "&Iuml": "\xCF", "&Iuml;": "\xCF", "&Jcirc;": "\u0134", "&Jcy;": "\u0419", "&Jfr;": "\u{1D50D}", "&Jopf;": "\u{1D541}", "&Jscr;": "\u{1D4A5}", "&Jsercy;": "\u0408", "&Jukcy;": "\u0404", "&KHcy;": "\u0425", "&KJcy;": "\u040C", "&Kappa;": "\u039A", "&Kcedil;": "\u0136", "&Kcy;": "\u041A", "&Kfr;": "\u{1D50E}", "&Kopf;": "\u{1D542}", "&Kscr;": "\u{1D4A6}", "&LJcy;": "\u0409", "&LT": "<", "&LT;": "<", "&Lacute;": "\u0139", "&Lambda;": "\u039B", "&Lang;": "\u27EA", "&Laplacetrf;": "\u2112", "&Larr;": "\u219E", "&Lcaron;": "\u013D", "&Lcedil;": "\u013B", "&Lcy;": "\u041B", "&LeftAngleBracket;": "\u27E8", "&LeftArrow;": "\u2190", "&LeftArrowBar;": "\u21E4", "&LeftArrowRightArrow;": "\u21C6", "&LeftCeiling;": "\u2308", "&LeftDoubleBracket;": "\u27E6", "&LeftDownTeeVector;": "\u2961", "&LeftDownVector;": "\u21C3", "&LeftDownVectorBar;": "\u2959", "&LeftFloor;": "\u230A", "&LeftRightArrow;": "\u2194", "&LeftRightVector;": "\u294E", "&LeftTee;": "\u22A3", "&LeftTeeArrow;": "\u21A4", "&LeftTeeVector;": "\u295A", "&LeftTriangle;": "\u22B2", "&LeftTriangleBar;": "\u29CF", "&LeftTriangleEqual;": "\u22B4", "&LeftUpDownVector;": "\u2951", "&LeftUpTeeVector;": "\u2960", "&LeftUpVector;": "\u21BF", "&LeftUpVectorBar;": "\u2958", "&LeftVector;": "\u21BC", "&LeftVectorBar;": "\u2952", "&Leftarrow;": "\u21D0", "&Leftrightarrow;": "\u21D4", "&LessEqualGreater;": "\u22DA", "&LessFullEqual;": "\u2266", "&LessGreater;": "\u2276", "&LessLess;": "\u2AA1", "&LessSlantEqual;": "\u2A7D", "&LessTilde;": "\u2272", "&Lfr;": "\u{1D50F}", "&Ll;": "\u22D8", "&Lleftarrow;": "\u21DA", "&Lmidot;": "\u013F", "&LongLeftArrow;": "\u27F5", "&LongLeftRightArrow;": "\u27F7", "&LongRightArrow;": "\u27F6", "&Longleftarrow;": "\u27F8", "&Longleftrightarrow;": "\u27FA", "&Longrightarrow;": "\u27F9", "&Lopf;": "\u{1D543}", "&LowerLeftArrow;": "\u2199", "&LowerRightArrow;": "\u2198", "&Lscr;": "\u2112", "&Lsh;": "\u21B0", "&Lstrok;": "\u0141", "&Lt;": "\u226A", "&Map;": "\u2905", "&Mcy;": "\u041C", "&MediumSpace;": "\u205F", "&Mellintrf;": "\u2133", "&Mfr;": "\u{1D510}", "&MinusPlus;": "\u2213", "&Mopf;": "\u{1D544}", "&Mscr;": "\u2133", "&Mu;": "\u039C", "&NJcy;": "\u040A", "&Nacute;": "\u0143", "&Ncaron;": "\u0147", "&Ncedil;": "\u0145", "&Ncy;": "\u041D", "&NegativeMediumSpace;": "\u200B", "&NegativeThickSpace;": "\u200B", "&NegativeThinSpace;": "\u200B", "&NegativeVeryThinSpace;": "\u200B", "&NestedGreaterGreater;": "\u226B", "&NestedLessLess;": "\u226A", "&NewLine;": "\n", "&Nfr;": "\u{1D511}", "&NoBreak;": "\u2060", "&NonBreakingSpace;": "\xA0", "&Nopf;": "\u2115", "&Not;": "\u2AEC", "&NotCongruent;": "\u2262", "&NotCupCap;": "\u226D", "&NotDoubleVerticalBar;": "\u2226", "&NotElement;": "\u2209", "&NotEqual;": "\u2260", "&NotEqualTilde;": "\u2242\u0338", "&NotExists;": "\u2204", "&NotGreater;": "\u226F", "&NotGreaterEqual;": "\u2271", "&NotGreaterFullEqual;": "\u2267\u0338", "&NotGreaterGreater;": "\u226B\u0338", "&NotGreaterLess;": "\u2279", "&NotGreaterSlantEqual;": "\u2A7E\u0338", "&NotGreaterTilde;": "\u2275", "&NotHumpDownHump;": "\u224E\u0338", "&NotHumpEqual;": "\u224F\u0338", "&NotLeftTriangle;": "\u22EA", "&NotLeftTriangleBar;": "\u29CF\u0338", "&NotLeftTriangleEqual;": "\u22EC", "&NotLess;": "\u226E", "&NotLessEqual;": "\u2270", "&NotLessGreater;": "\u2278", "&NotLessLess;": "\u226A\u0338", "&NotLessSlantEqual;": "\u2A7D\u0338", "&NotLessTilde;": "\u2274", "&NotNestedGreaterGreater;": "\u2AA2\u0338", "&NotNestedLessLess;": "\u2AA1\u0338", "&NotPrecedes;": "\u2280", "&NotPrecedesEqual;": "\u2AAF\u0338", "&NotPrecedesSlantEqual;": "\u22E0", "&NotReverseElement;": "\u220C", "&NotRightTriangle;": "\u22EB", "&NotRightTriangleBar;": "\u29D0\u0338", "&NotRightTriangleEqual;": "\u22ED", "&NotSquareSubset;": "\u228F\u0338", "&NotSquareSubsetEqual;": "\u22E2", "&NotSquareSuperset;": "\u2290\u0338", "&NotSquareSupersetEqual;": "\u22E3", "&NotSubset;": "\u2282\u20D2", "&NotSubsetEqual;": "\u2288", "&NotSucceeds;": "\u2281", "&NotSucceedsEqual;": "\u2AB0\u0338", "&NotSucceedsSlantEqual;": "\u22E1", "&NotSucceedsTilde;": "\u227F\u0338", "&NotSuperset;": "\u2283\u20D2", "&NotSupersetEqual;": "\u2289", "&NotTilde;": "\u2241", "&NotTildeEqual;": "\u2244", "&NotTildeFullEqual;": "\u2247", "&NotTildeTilde;": "\u2249", "&NotVerticalBar;": "\u2224", "&Nscr;": "\u{1D4A9}", "&Ntilde": "\xD1", "&Ntilde;": "\xD1", "&Nu;": "\u039D", "&OElig;": "\u0152", "&Oacute": "\xD3", "&Oacute;": "\xD3", "&Ocirc": "\xD4", "&Ocirc;": "\xD4", "&Ocy;": "\u041E", "&Odblac;": "\u0150", "&Ofr;": "\u{1D512}", "&Ograve": "\xD2", "&Ograve;": "\xD2", "&Omacr;": "\u014C", "&Omega;": "\u03A9", "&Omicron;": "\u039F", "&Oopf;": "\u{1D546}", "&OpenCurlyDoubleQuote;": "\u201C", "&OpenCurlyQuote;": "\u2018", "&Or;": "\u2A54", "&Oscr;": "\u{1D4AA}", "&Oslash": "\xD8", "&Oslash;": "\xD8", "&Otilde": "\xD5", "&Otilde;": "\xD5", "&Otimes;": "\u2A37", "&Ouml": "\xD6", "&Ouml;": "\xD6", "&OverBar;": "\u203E", "&OverBrace;": "\u23DE", "&OverBracket;": "\u23B4", "&OverParenthesis;": "\u23DC", "&PartialD;": "\u2202", "&Pcy;": "\u041F", "&Pfr;": "\u{1D513}", "&Phi;": "\u03A6", "&Pi;": "\u03A0", "&PlusMinus;": "\xB1", "&Poincareplane;": "\u210C", "&Popf;": "\u2119", "&Pr;": "\u2ABB", "&Precedes;": "\u227A", "&PrecedesEqual;": "\u2AAF", "&PrecedesSlantEqual;": "\u227C", "&PrecedesTilde;": "\u227E", "&Prime;": "\u2033", "&Product;": "\u220F", "&Proportion;": "\u2237", "&Proportional;": "\u221D", "&Pscr;": "\u{1D4AB}", "&Psi;": "\u03A8", "&QUOT": '"', "&QUOT;": '"', "&Qfr;": "\u{1D514}", "&Qopf;": "\u211A", "&Qscr;": "\u{1D4AC}", "&RBarr;": "\u2910", "&REG": "\xAE", "&REG;": "\xAE", "&Racute;": "\u0154", "&Rang;": "\u27EB", "&Rarr;": "\u21A0", "&Rarrtl;": "\u2916", "&Rcaron;": "\u0158", "&Rcedil;": "\u0156", "&Rcy;": "\u0420", "&Re;": "\u211C", "&ReverseElement;": "\u220B", "&ReverseEquilibrium;": "\u21CB", "&ReverseUpEquilibrium;": "\u296F", "&Rfr;": "\u211C", "&Rho;": "\u03A1", "&RightAngleBracket;": "\u27E9", "&RightArrow;": "\u2192", "&RightArrowBar;": "\u21E5", "&RightArrowLeftArrow;": "\u21C4", "&RightCeiling;": "\u2309", "&RightDoubleBracket;": "\u27E7", "&RightDownTeeVector;": "\u295D", "&RightDownVector;": "\u21C2", "&RightDownVectorBar;": "\u2955", "&RightFloor;": "\u230B", "&RightTee;": "\u22A2", "&RightTeeArrow;": "\u21A6", "&RightTeeVector;": "\u295B", "&RightTriangle;": "\u22B3", "&RightTriangleBar;": "\u29D0", "&RightTriangleEqual;": "\u22B5", "&RightUpDownVector;": "\u294F", "&RightUpTeeVector;": "\u295C", "&RightUpVector;": "\u21BE", "&RightUpVectorBar;": "\u2954", "&RightVector;": "\u21C0", "&RightVectorBar;": "\u2953", "&Rightarrow;": "\u21D2", "&Ropf;": "\u211D", "&RoundImplies;": "\u2970", "&Rrightarrow;": "\u21DB", "&Rscr;": "\u211B", "&Rsh;": "\u21B1", "&RuleDelayed;": "\u29F4", "&SHCHcy;": "\u0429", "&SHcy;": "\u0428", "&SOFTcy;": "\u042C", "&Sacute;": "\u015A", "&Sc;": "\u2ABC", "&Scaron;": "\u0160", "&Scedil;": "\u015E", "&Scirc;": "\u015C", "&Scy;": "\u0421", "&Sfr;": "\u{1D516}", "&ShortDownArrow;": "\u2193", "&ShortLeftArrow;": "\u2190", "&ShortRightArrow;": "\u2192", "&ShortUpArrow;": "\u2191", "&Sigma;": "\u03A3", "&SmallCircle;": "\u2218", "&Sopf;": "\u{1D54A}", "&Sqrt;": "\u221A", "&Square;": "\u25A1", "&SquareIntersection;": "\u2293", "&SquareSubset;": "\u228F", "&SquareSubsetEqual;": "\u2291", "&SquareSuperset;": "\u2290", "&SquareSupersetEqual;": "\u2292", "&SquareUnion;": "\u2294", "&Sscr;": "\u{1D4AE}", "&Star;": "\u22C6", "&Sub;": "\u22D0", "&Subset;": "\u22D0", "&SubsetEqual;": "\u2286", "&Succeeds;": "\u227B", "&SucceedsEqual;": "\u2AB0", "&SucceedsSlantEqual;": "\u227D", "&SucceedsTilde;": "\u227F", "&SuchThat;": "\u220B", "&Sum;": "\u2211", "&Sup;": "\u22D1", "&Superset;": "\u2283", "&SupersetEqual;": "\u2287", "&Supset;": "\u22D1", "&THORN": "\xDE", "&THORN;": "\xDE", "&TRADE;": "\u2122", "&TSHcy;": "\u040B", "&TScy;": "\u0426", "&Tab;": "	", "&Tau;": "\u03A4", "&Tcaron;": "\u0164", "&Tcedil;": "\u0162", "&Tcy;": "\u0422", "&Tfr;": "\u{1D517}", "&Therefore;": "\u2234", "&Theta;": "\u0398", "&ThickSpace;": "\u205F\u200A", "&ThinSpace;": "\u2009", "&Tilde;": "\u223C", "&TildeEqual;": "\u2243", "&TildeFullEqual;": "\u2245", "&TildeTilde;": "\u2248", "&Topf;": "\u{1D54B}", "&TripleDot;": "\u20DB", "&Tscr;": "\u{1D4AF}", "&Tstrok;": "\u0166", "&Uacute": "\xDA", "&Uacute;": "\xDA", "&Uarr;": "\u219F", "&Uarrocir;": "\u2949", "&Ubrcy;": "\u040E", "&Ubreve;": "\u016C", "&Ucirc": "\xDB", "&Ucirc;": "\xDB", "&Ucy;": "\u0423", "&Udblac;": "\u0170", "&Ufr;": "\u{1D518}", "&Ugrave": "\xD9", "&Ugrave;": "\xD9", "&Umacr;": "\u016A", "&UnderBar;": "_", "&UnderBrace;": "\u23DF", "&UnderBracket;": "\u23B5", "&UnderParenthesis;": "\u23DD", "&Union;": "\u22C3", "&UnionPlus;": "\u228E", "&Uogon;": "\u0172", "&Uopf;": "\u{1D54C}", "&UpArrow;": "\u2191", "&UpArrowBar;": "\u2912", "&UpArrowDownArrow;": "\u21C5", "&UpDownArrow;": "\u2195", "&UpEquilibrium;": "\u296E", "&UpTee;": "\u22A5", "&UpTeeArrow;": "\u21A5", "&Uparrow;": "\u21D1", "&Updownarrow;": "\u21D5", "&UpperLeftArrow;": "\u2196", "&UpperRightArrow;": "\u2197", "&Upsi;": "\u03D2", "&Upsilon;": "\u03A5", "&Uring;": "\u016E", "&Uscr;": "\u{1D4B0}", "&Utilde;": "\u0168", "&Uuml": "\xDC", "&Uuml;": "\xDC", "&VDash;": "\u22AB", "&Vbar;": "\u2AEB", "&Vcy;": "\u0412", "&Vdash;": "\u22A9", "&Vdashl;": "\u2AE6", "&Vee;": "\u22C1", "&Verbar;": "\u2016", "&Vert;": "\u2016", "&VerticalBar;": "\u2223", "&VerticalLine;": "|", "&VerticalSeparator;": "\u2758", "&VerticalTilde;": "\u2240", "&VeryThinSpace;": "\u200A", "&Vfr;": "\u{1D519}", "&Vopf;": "\u{1D54D}", "&Vscr;": "\u{1D4B1}", "&Vvdash;": "\u22AA", "&Wcirc;": "\u0174", "&Wedge;": "\u22C0", "&Wfr;": "\u{1D51A}", "&Wopf;": "\u{1D54E}", "&Wscr;": "\u{1D4B2}", "&Xfr;": "\u{1D51B}", "&Xi;": "\u039E", "&Xopf;": "\u{1D54F}", "&Xscr;": "\u{1D4B3}", "&YAcy;": "\u042F", "&YIcy;": "\u0407", "&YUcy;": "\u042E", "&Yacute": "\xDD", "&Yacute;": "\xDD", "&Ycirc;": "\u0176", "&Ycy;": "\u042B", "&Yfr;": "\u{1D51C}", "&Yopf;": "\u{1D550}", "&Yscr;": "\u{1D4B4}", "&Yuml;": "\u0178", "&ZHcy;": "\u0416", "&Zacute;": "\u0179", "&Zcaron;": "\u017D", "&Zcy;": "\u0417", "&Zdot;": "\u017B", "&ZeroWidthSpace;": "\u200B", "&Zeta;": "\u0396", "&Zfr;": "\u2128", "&Zopf;": "\u2124", "&Zscr;": "\u{1D4B5}", "&aacute": "\xE1", "&aacute;": "\xE1", "&abreve;": "\u0103", "&ac;": "\u223E", "&acE;": "\u223E\u0333", "&acd;": "\u223F", "&acirc": "\xE2", "&acirc;": "\xE2", "&acute": "\xB4", "&acute;": "\xB4", "&acy;": "\u0430", "&aelig": "\xE6", "&aelig;": "\xE6", "&af;": "\u2061", "&afr;": "\u{1D51E}", "&agrave": "\xE0", "&agrave;": "\xE0", "&alefsym;": "\u2135", "&aleph;": "\u2135", "&alpha;": "\u03B1", "&amacr;": "\u0101", "&amalg;": "\u2A3F", "&amp": "&", "&amp;": "&", "&and;": "\u2227", "&andand;": "\u2A55", "&andd;": "\u2A5C", "&andslope;": "\u2A58", "&andv;": "\u2A5A", "&ang;": "\u2220", "&ange;": "\u29A4", "&angle;": "\u2220", "&angmsd;": "\u2221", "&angmsdaa;": "\u29A8", "&angmsdab;": "\u29A9", "&angmsdac;": "\u29AA", "&angmsdad;": "\u29AB", "&angmsdae;": "\u29AC", "&angmsdaf;": "\u29AD", "&angmsdag;": "\u29AE", "&angmsdah;": "\u29AF", "&angrt;": "\u221F", "&angrtvb;": "\u22BE", "&angrtvbd;": "\u299D", "&angsph;": "\u2222", "&angst;": "\xC5", "&angzarr;": "\u237C", "&aogon;": "\u0105", "&aopf;": "\u{1D552}", "&ap;": "\u2248", "&apE;": "\u2A70", "&apacir;": "\u2A6F", "&ape;": "\u224A", "&apid;": "\u224B", "&apos;": "'", "&approx;": "\u2248", "&approxeq;": "\u224A", "&aring": "\xE5", "&aring;": "\xE5", "&ascr;": "\u{1D4B6}", "&ast;": "*", "&asymp;": "\u2248", "&asympeq;": "\u224D", "&atilde": "\xE3", "&atilde;": "\xE3", "&auml": "\xE4", "&auml;": "\xE4", "&awconint;": "\u2233", "&awint;": "\u2A11", "&bNot;": "\u2AED", "&backcong;": "\u224C", "&backepsilon;": "\u03F6", "&backprime;": "\u2035", "&backsim;": "\u223D", "&backsimeq;": "\u22CD", "&barvee;": "\u22BD", "&barwed;": "\u2305", "&barwedge;": "\u2305", "&bbrk;": "\u23B5", "&bbrktbrk;": "\u23B6", "&bcong;": "\u224C", "&bcy;": "\u0431", "&bdquo;": "\u201E", "&becaus;": "\u2235", "&because;": "\u2235", "&bemptyv;": "\u29B0", "&bepsi;": "\u03F6", "&bernou;": "\u212C", "&beta;": "\u03B2", "&beth;": "\u2136", "&between;": "\u226C", "&bfr;": "\u{1D51F}", "&bigcap;": "\u22C2", "&bigcirc;": "\u25EF", "&bigcup;": "\u22C3", "&bigodot;": "\u2A00", "&bigoplus;": "\u2A01", "&bigotimes;": "\u2A02", "&bigsqcup;": "\u2A06", "&bigstar;": "\u2605", "&bigtriangledown;": "\u25BD", "&bigtriangleup;": "\u25B3", "&biguplus;": "\u2A04", "&bigvee;": "\u22C1", "&bigwedge;": "\u22C0", "&bkarow;": "\u290D", "&blacklozenge;": "\u29EB", "&blacksquare;": "\u25AA", "&blacktriangle;": "\u25B4", "&blacktriangledown;": "\u25BE", "&blacktriangleleft;": "\u25C2", "&blacktriangleright;": "\u25B8", "&blank;": "\u2423", "&blk12;": "\u2592", "&blk14;": "\u2591", "&blk34;": "\u2593", "&block;": "\u2588", "&bne;": "=\u20E5", "&bnequiv;": "\u2261\u20E5", "&bnot;": "\u2310", "&bopf;": "\u{1D553}", "&bot;": "\u22A5", "&bottom;": "\u22A5", "&bowtie;": "\u22C8", "&boxDL;": "\u2557", "&boxDR;": "\u2554", "&boxDl;": "\u2556", "&boxDr;": "\u2553", "&boxH;": "\u2550", "&boxHD;": "\u2566", "&boxHU;": "\u2569", "&boxHd;": "\u2564", "&boxHu;": "\u2567", "&boxUL;": "\u255D", "&boxUR;": "\u255A", "&boxUl;": "\u255C", "&boxUr;": "\u2559", "&boxV;": "\u2551", "&boxVH;": "\u256C", "&boxVL;": "\u2563", "&boxVR;": "\u2560", "&boxVh;": "\u256B", "&boxVl;": "\u2562", "&boxVr;": "\u255F", "&boxbox;": "\u29C9", "&boxdL;": "\u2555", "&boxdR;": "\u2552", "&boxdl;": "\u2510", "&boxdr;": "\u250C", "&boxh;": "\u2500", "&boxhD;": "\u2565", "&boxhU;": "\u2568", "&boxhd;": "\u252C", "&boxhu;": "\u2534", "&boxminus;": "\u229F", "&boxplus;": "\u229E", "&boxtimes;": "\u22A0", "&boxuL;": "\u255B", "&boxuR;": "\u2558", "&boxul;": "\u2518", "&boxur;": "\u2514", "&boxv;": "\u2502", "&boxvH;": "\u256A", "&boxvL;": "\u2561", "&boxvR;": "\u255E", "&boxvh;": "\u253C", "&boxvl;": "\u2524", "&boxvr;": "\u251C", "&bprime;": "\u2035", "&breve;": "\u02D8", "&brvbar": "\xA6", "&brvbar;": "\xA6", "&bscr;": "\u{1D4B7}", "&bsemi;": "\u204F", "&bsim;": "\u223D", "&bsime;": "\u22CD", "&bsol;": "\\", "&bsolb;": "\u29C5", "&bsolhsub;": "\u27C8", "&bull;": "\u2022", "&bullet;": "\u2022", "&bump;": "\u224E", "&bumpE;": "\u2AAE", "&bumpe;": "\u224F", "&bumpeq;": "\u224F", "&cacute;": "\u0107", "&cap;": "\u2229", "&capand;": "\u2A44", "&capbrcup;": "\u2A49", "&capcap;": "\u2A4B", "&capcup;": "\u2A47", "&capdot;": "\u2A40", "&caps;": "\u2229\uFE00", "&caret;": "\u2041", "&caron;": "\u02C7", "&ccaps;": "\u2A4D", "&ccaron;": "\u010D", "&ccedil": "\xE7", "&ccedil;": "\xE7", "&ccirc;": "\u0109", "&ccups;": "\u2A4C", "&ccupssm;": "\u2A50", "&cdot;": "\u010B", "&cedil": "\xB8", "&cedil;": "\xB8", "&cemptyv;": "\u29B2", "&cent": "\xA2", "&cent;": "\xA2", "&centerdot;": "\xB7", "&cfr;": "\u{1D520}", "&chcy;": "\u0447", "&check;": "\u2713", "&checkmark;": "\u2713", "&chi;": "\u03C7", "&cir;": "\u25CB", "&cirE;": "\u29C3", "&circ;": "\u02C6", "&circeq;": "\u2257", "&circlearrowleft;": "\u21BA", "&circlearrowright;": "\u21BB", "&circledR;": "\xAE", "&circledS;": "\u24C8", "&circledast;": "\u229B", "&circledcirc;": "\u229A", "&circleddash;": "\u229D", "&cire;": "\u2257", "&cirfnint;": "\u2A10", "&cirmid;": "\u2AEF", "&cirscir;": "\u29C2", "&clubs;": "\u2663", "&clubsuit;": "\u2663", "&colon;": ":", "&colone;": "\u2254", "&coloneq;": "\u2254", "&comma;": ",", "&commat;": "@", "&comp;": "\u2201", "&compfn;": "\u2218", "&complement;": "\u2201", "&complexes;": "\u2102", "&cong;": "\u2245", "&congdot;": "\u2A6D", "&conint;": "\u222E", "&copf;": "\u{1D554}", "&coprod;": "\u2210", "&copy": "\xA9", "&copy;": "\xA9", "&copysr;": "\u2117", "&crarr;": "\u21B5", "&cross;": "\u2717", "&cscr;": "\u{1D4B8}", "&csub;": "\u2ACF", "&csube;": "\u2AD1", "&csup;": "\u2AD0", "&csupe;": "\u2AD2", "&ctdot;": "\u22EF", "&cudarrl;": "\u2938", "&cudarrr;": "\u2935", "&cuepr;": "\u22DE", "&cuesc;": "\u22DF", "&cularr;": "\u21B6", "&cularrp;": "\u293D", "&cup;": "\u222A", "&cupbrcap;": "\u2A48", "&cupcap;": "\u2A46", "&cupcup;": "\u2A4A", "&cupdot;": "\u228D", "&cupor;": "\u2A45", "&cups;": "\u222A\uFE00", "&curarr;": "\u21B7", "&curarrm;": "\u293C", "&curlyeqprec;": "\u22DE", "&curlyeqsucc;": "\u22DF", "&curlyvee;": "\u22CE", "&curlywedge;": "\u22CF", "&curren": "\xA4", "&curren;": "\xA4", "&curvearrowleft;": "\u21B6", "&curvearrowright;": "\u21B7", "&cuvee;": "\u22CE", "&cuwed;": "\u22CF", "&cwconint;": "\u2232", "&cwint;": "\u2231", "&cylcty;": "\u232D", "&dArr;": "\u21D3", "&dHar;": "\u2965", "&dagger;": "\u2020", "&daleth;": "\u2138", "&darr;": "\u2193", "&dash;": "\u2010", "&dashv;": "\u22A3", "&dbkarow;": "\u290F", "&dblac;": "\u02DD", "&dcaron;": "\u010F", "&dcy;": "\u0434", "&dd;": "\u2146", "&ddagger;": "\u2021", "&ddarr;": "\u21CA", "&ddotseq;": "\u2A77", "&deg": "\xB0", "&deg;": "\xB0", "&delta;": "\u03B4", "&demptyv;": "\u29B1", "&dfisht;": "\u297F", "&dfr;": "\u{1D521}", "&dharl;": "\u21C3", "&dharr;": "\u21C2", "&diam;": "\u22C4", "&diamond;": "\u22C4", "&diamondsuit;": "\u2666", "&diams;": "\u2666", "&die;": "\xA8", "&digamma;": "\u03DD", "&disin;": "\u22F2", "&div;": "\xF7", "&divide": "\xF7", "&divide;": "\xF7", "&divideontimes;": "\u22C7", "&divonx;": "\u22C7", "&djcy;": "\u0452", "&dlcorn;": "\u231E", "&dlcrop;": "\u230D", "&dollar;": "$", "&dopf;": "\u{1D555}", "&dot;": "\u02D9", "&doteq;": "\u2250", "&doteqdot;": "\u2251", "&dotminus;": "\u2238", "&dotplus;": "\u2214", "&dotsquare;": "\u22A1", "&doublebarwedge;": "\u2306", "&downarrow;": "\u2193", "&downdownarrows;": "\u21CA", "&downharpoonleft;": "\u21C3", "&downharpoonright;": "\u21C2", "&drbkarow;": "\u2910", "&drcorn;": "\u231F", "&drcrop;": "\u230C", "&dscr;": "\u{1D4B9}", "&dscy;": "\u0455", "&dsol;": "\u29F6", "&dstrok;": "\u0111", "&dtdot;": "\u22F1", "&dtri;": "\u25BF", "&dtrif;": "\u25BE", "&duarr;": "\u21F5", "&duhar;": "\u296F", "&dwangle;": "\u29A6", "&dzcy;": "\u045F", "&dzigrarr;": "\u27FF", "&eDDot;": "\u2A77", "&eDot;": "\u2251", "&eacute": "\xE9", "&eacute;": "\xE9", "&easter;": "\u2A6E", "&ecaron;": "\u011B", "&ecir;": "\u2256", "&ecirc": "\xEA", "&ecirc;": "\xEA", "&ecolon;": "\u2255", "&ecy;": "\u044D", "&edot;": "\u0117", "&ee;": "\u2147", "&efDot;": "\u2252", "&efr;": "\u{1D522}", "&eg;": "\u2A9A", "&egrave": "\xE8", "&egrave;": "\xE8", "&egs;": "\u2A96", "&egsdot;": "\u2A98", "&el;": "\u2A99", "&elinters;": "\u23E7", "&ell;": "\u2113", "&els;": "\u2A95", "&elsdot;": "\u2A97", "&emacr;": "\u0113", "&empty;": "\u2205", "&emptyset;": "\u2205", "&emptyv;": "\u2205", "&emsp13;": "\u2004", "&emsp14;": "\u2005", "&emsp;": "\u2003", "&eng;": "\u014B", "&ensp;": "\u2002", "&eogon;": "\u0119", "&eopf;": "\u{1D556}", "&epar;": "\u22D5", "&eparsl;": "\u29E3", "&eplus;": "\u2A71", "&epsi;": "\u03B5", "&epsilon;": "\u03B5", "&epsiv;": "\u03F5", "&eqcirc;": "\u2256", "&eqcolon;": "\u2255", "&eqsim;": "\u2242", "&eqslantgtr;": "\u2A96", "&eqslantless;": "\u2A95", "&equals;": "=", "&equest;": "\u225F", "&equiv;": "\u2261", "&equivDD;": "\u2A78", "&eqvparsl;": "\u29E5", "&erDot;": "\u2253", "&erarr;": "\u2971", "&escr;": "\u212F", "&esdot;": "\u2250", "&esim;": "\u2242", "&eta;": "\u03B7", "&eth": "\xF0", "&eth;": "\xF0", "&euml": "\xEB", "&euml;": "\xEB", "&euro;": "\u20AC", "&excl;": "!", "&exist;": "\u2203", "&expectation;": "\u2130", "&exponentiale;": "\u2147", "&fallingdotseq;": "\u2252", "&fcy;": "\u0444", "&female;": "\u2640", "&ffilig;": "\uFB03", "&fflig;": "\uFB00", "&ffllig;": "\uFB04", "&ffr;": "\u{1D523}", "&filig;": "\uFB01", "&fjlig;": "fj", "&flat;": "\u266D", "&fllig;": "\uFB02", "&fltns;": "\u25B1", "&fnof;": "\u0192", "&fopf;": "\u{1D557}", "&forall;": "\u2200", "&fork;": "\u22D4", "&forkv;": "\u2AD9", "&fpartint;": "\u2A0D", "&frac12": "\xBD", "&frac12;": "\xBD", "&frac13;": "\u2153", "&frac14": "\xBC", "&frac14;": "\xBC", "&frac15;": "\u2155", "&frac16;": "\u2159", "&frac18;": "\u215B", "&frac23;": "\u2154", "&frac25;": "\u2156", "&frac34": "\xBE", "&frac34;": "\xBE", "&frac35;": "\u2157", "&frac38;": "\u215C", "&frac45;": "\u2158", "&frac56;": "\u215A", "&frac58;": "\u215D", "&frac78;": "\u215E", "&frasl;": "\u2044", "&frown;": "\u2322", "&fscr;": "\u{1D4BB}", "&gE;": "\u2267", "&gEl;": "\u2A8C", "&gacute;": "\u01F5", "&gamma;": "\u03B3", "&gammad;": "\u03DD", "&gap;": "\u2A86", "&gbreve;": "\u011F", "&gcirc;": "\u011D", "&gcy;": "\u0433", "&gdot;": "\u0121", "&ge;": "\u2265", "&gel;": "\u22DB", "&geq;": "\u2265", "&geqq;": "\u2267", "&geqslant;": "\u2A7E", "&ges;": "\u2A7E", "&gescc;": "\u2AA9", "&gesdot;": "\u2A80", "&gesdoto;": "\u2A82", "&gesdotol;": "\u2A84", "&gesl;": "\u22DB\uFE00", "&gesles;": "\u2A94", "&gfr;": "\u{1D524}", "&gg;": "\u226B", "&ggg;": "\u22D9", "&gimel;": "\u2137", "&gjcy;": "\u0453", "&gl;": "\u2277", "&glE;": "\u2A92", "&gla;": "\u2AA5", "&glj;": "\u2AA4", "&gnE;": "\u2269", "&gnap;": "\u2A8A", "&gnapprox;": "\u2A8A", "&gne;": "\u2A88", "&gneq;": "\u2A88", "&gneqq;": "\u2269", "&gnsim;": "\u22E7", "&gopf;": "\u{1D558}", "&grave;": "`", "&gscr;": "\u210A", "&gsim;": "\u2273", "&gsime;": "\u2A8E", "&gsiml;": "\u2A90", "&gt": ">", "&gt;": ">", "&gtcc;": "\u2AA7", "&gtcir;": "\u2A7A", "&gtdot;": "\u22D7", "&gtlPar;": "\u2995", "&gtquest;": "\u2A7C", "&gtrapprox;": "\u2A86", "&gtrarr;": "\u2978", "&gtrdot;": "\u22D7", "&gtreqless;": "\u22DB", "&gtreqqless;": "\u2A8C", "&gtrless;": "\u2277", "&gtrsim;": "\u2273", "&gvertneqq;": "\u2269\uFE00", "&gvnE;": "\u2269\uFE00", "&hArr;": "\u21D4", "&hairsp;": "\u200A", "&half;": "\xBD", "&hamilt;": "\u210B", "&hardcy;": "\u044A", "&harr;": "\u2194", "&harrcir;": "\u2948", "&harrw;": "\u21AD", "&hbar;": "\u210F", "&hcirc;": "\u0125", "&hearts;": "\u2665", "&heartsuit;": "\u2665", "&hellip;": "\u2026", "&hercon;": "\u22B9", "&hfr;": "\u{1D525}", "&hksearow;": "\u2925", "&hkswarow;": "\u2926", "&hoarr;": "\u21FF", "&homtht;": "\u223B", "&hookleftarrow;": "\u21A9", "&hookrightarrow;": "\u21AA", "&hopf;": "\u{1D559}", "&horbar;": "\u2015", "&hscr;": "\u{1D4BD}", "&hslash;": "\u210F", "&hstrok;": "\u0127", "&hybull;": "\u2043", "&hyphen;": "\u2010", "&iacute": "\xED", "&iacute;": "\xED", "&ic;": "\u2063", "&icirc": "\xEE", "&icirc;": "\xEE", "&icy;": "\u0438", "&iecy;": "\u0435", "&iexcl": "\xA1", "&iexcl;": "\xA1", "&iff;": "\u21D4", "&ifr;": "\u{1D526}", "&igrave": "\xEC", "&igrave;": "\xEC", "&ii;": "\u2148", "&iiiint;": "\u2A0C", "&iiint;": "\u222D", "&iinfin;": "\u29DC", "&iiota;": "\u2129", "&ijlig;": "\u0133", "&imacr;": "\u012B", "&image;": "\u2111", "&imagline;": "\u2110", "&imagpart;": "\u2111", "&imath;": "\u0131", "&imof;": "\u22B7", "&imped;": "\u01B5", "&in;": "\u2208", "&incare;": "\u2105", "&infin;": "\u221E", "&infintie;": "\u29DD", "&inodot;": "\u0131", "&int;": "\u222B", "&intcal;": "\u22BA", "&integers;": "\u2124", "&intercal;": "\u22BA", "&intlarhk;": "\u2A17", "&intprod;": "\u2A3C", "&iocy;": "\u0451", "&iogon;": "\u012F", "&iopf;": "\u{1D55A}", "&iota;": "\u03B9", "&iprod;": "\u2A3C", "&iquest": "\xBF", "&iquest;": "\xBF", "&iscr;": "\u{1D4BE}", "&isin;": "\u2208", "&isinE;": "\u22F9", "&isindot;": "\u22F5", "&isins;": "\u22F4", "&isinsv;": "\u22F3", "&isinv;": "\u2208", "&it;": "\u2062", "&itilde;": "\u0129", "&iukcy;": "\u0456", "&iuml": "\xEF", "&iuml;": "\xEF", "&jcirc;": "\u0135", "&jcy;": "\u0439", "&jfr;": "\u{1D527}", "&jmath;": "\u0237", "&jopf;": "\u{1D55B}", "&jscr;": "\u{1D4BF}", "&jsercy;": "\u0458", "&jukcy;": "\u0454", "&kappa;": "\u03BA", "&kappav;": "\u03F0", "&kcedil;": "\u0137", "&kcy;": "\u043A", "&kfr;": "\u{1D528}", "&kgreen;": "\u0138", "&khcy;": "\u0445", "&kjcy;": "\u045C", "&kopf;": "\u{1D55C}", "&kscr;": "\u{1D4C0}", "&lAarr;": "\u21DA", "&lArr;": "\u21D0", "&lAtail;": "\u291B", "&lBarr;": "\u290E", "&lE;": "\u2266", "&lEg;": "\u2A8B", "&lHar;": "\u2962", "&lacute;": "\u013A", "&laemptyv;": "\u29B4", "&lagran;": "\u2112", "&lambda;": "\u03BB", "&lang;": "\u27E8", "&langd;": "\u2991", "&langle;": "\u27E8", "&lap;": "\u2A85", "&laquo": "\xAB", "&laquo;": "\xAB", "&larr;": "\u2190", "&larrb;": "\u21E4", "&larrbfs;": "\u291F", "&larrfs;": "\u291D", "&larrhk;": "\u21A9", "&larrlp;": "\u21AB", "&larrpl;": "\u2939", "&larrsim;": "\u2973", "&larrtl;": "\u21A2", "&lat;": "\u2AAB", "&latail;": "\u2919", "&late;": "\u2AAD", "&lates;": "\u2AAD\uFE00", "&lbarr;": "\u290C", "&lbbrk;": "\u2772", "&lbrace;": "{", "&lbrack;": "[", "&lbrke;": "\u298B", "&lbrksld;": "\u298F", "&lbrkslu;": "\u298D", "&lcaron;": "\u013E", "&lcedil;": "\u013C", "&lceil;": "\u2308", "&lcub;": "{", "&lcy;": "\u043B", "&ldca;": "\u2936", "&ldquo;": "\u201C", "&ldquor;": "\u201E", "&ldrdhar;": "\u2967", "&ldrushar;": "\u294B", "&ldsh;": "\u21B2", "&le;": "\u2264", "&leftarrow;": "\u2190", "&leftarrowtail;": "\u21A2", "&leftharpoondown;": "\u21BD", "&leftharpoonup;": "\u21BC", "&leftleftarrows;": "\u21C7", "&leftrightarrow;": "\u2194", "&leftrightarrows;": "\u21C6", "&leftrightharpoons;": "\u21CB", "&leftrightsquigarrow;": "\u21AD", "&leftthreetimes;": "\u22CB", "&leg;": "\u22DA", "&leq;": "\u2264", "&leqq;": "\u2266", "&leqslant;": "\u2A7D", "&les;": "\u2A7D", "&lescc;": "\u2AA8", "&lesdot;": "\u2A7F", "&lesdoto;": "\u2A81", "&lesdotor;": "\u2A83", "&lesg;": "\u22DA\uFE00", "&lesges;": "\u2A93", "&lessapprox;": "\u2A85", "&lessdot;": "\u22D6", "&lesseqgtr;": "\u22DA", "&lesseqqgtr;": "\u2A8B", "&lessgtr;": "\u2276", "&lesssim;": "\u2272", "&lfisht;": "\u297C", "&lfloor;": "\u230A", "&lfr;": "\u{1D529}", "&lg;": "\u2276", "&lgE;": "\u2A91", "&lhard;": "\u21BD", "&lharu;": "\u21BC", "&lharul;": "\u296A", "&lhblk;": "\u2584", "&ljcy;": "\u0459", "&ll;": "\u226A", "&llarr;": "\u21C7", "&llcorner;": "\u231E", "&llhard;": "\u296B", "&lltri;": "\u25FA", "&lmidot;": "\u0140", "&lmoust;": "\u23B0", "&lmoustache;": "\u23B0", "&lnE;": "\u2268", "&lnap;": "\u2A89", "&lnapprox;": "\u2A89", "&lne;": "\u2A87", "&lneq;": "\u2A87", "&lneqq;": "\u2268", "&lnsim;": "\u22E6", "&loang;": "\u27EC", "&loarr;": "\u21FD", "&lobrk;": "\u27E6", "&longleftarrow;": "\u27F5", "&longleftrightarrow;": "\u27F7", "&longmapsto;": "\u27FC", "&longrightarrow;": "\u27F6", "&looparrowleft;": "\u21AB", "&looparrowright;": "\u21AC", "&lopar;": "\u2985", "&lopf;": "\u{1D55D}", "&loplus;": "\u2A2D", "&lotimes;": "\u2A34", "&lowast;": "\u2217", "&lowbar;": "_", "&loz;": "\u25CA", "&lozenge;": "\u25CA", "&lozf;": "\u29EB", "&lpar;": "(", "&lparlt;": "\u2993", "&lrarr;": "\u21C6", "&lrcorner;": "\u231F", "&lrhar;": "\u21CB", "&lrhard;": "\u296D", "&lrm;": "\u200E", "&lrtri;": "\u22BF", "&lsaquo;": "\u2039", "&lscr;": "\u{1D4C1}", "&lsh;": "\u21B0", "&lsim;": "\u2272", "&lsime;": "\u2A8D", "&lsimg;": "\u2A8F", "&lsqb;": "[", "&lsquo;": "\u2018", "&lsquor;": "\u201A", "&lstrok;": "\u0142", "&lt": "<", "&lt;": "<", "&ltcc;": "\u2AA6", "&ltcir;": "\u2A79", "&ltdot;": "\u22D6", "&lthree;": "\u22CB", "&ltimes;": "\u22C9", "&ltlarr;": "\u2976", "&ltquest;": "\u2A7B", "&ltrPar;": "\u2996", "&ltri;": "\u25C3", "&ltrie;": "\u22B4", "&ltrif;": "\u25C2", "&lurdshar;": "\u294A", "&luruhar;": "\u2966", "&lvertneqq;": "\u2268\uFE00", "&lvnE;": "\u2268\uFE00", "&mDDot;": "\u223A", "&macr": "\xAF", "&macr;": "\xAF", "&male;": "\u2642", "&malt;": "\u2720", "&maltese;": "\u2720", "&map;": "\u21A6", "&mapsto;": "\u21A6", "&mapstodown;": "\u21A7", "&mapstoleft;": "\u21A4", "&mapstoup;": "\u21A5", "&marker;": "\u25AE", "&mcomma;": "\u2A29", "&mcy;": "\u043C", "&mdash;": "\u2014", "&measuredangle;": "\u2221", "&mfr;": "\u{1D52A}", "&mho;": "\u2127", "&micro": "\xB5", "&micro;": "\xB5", "&mid;": "\u2223", "&midast;": "*", "&midcir;": "\u2AF0", "&middot": "\xB7", "&middot;": "\xB7", "&minus;": "\u2212", "&minusb;": "\u229F", "&minusd;": "\u2238", "&minusdu;": "\u2A2A", "&mlcp;": "\u2ADB", "&mldr;": "\u2026", "&mnplus;": "\u2213", "&models;": "\u22A7", "&mopf;": "\u{1D55E}", "&mp;": "\u2213", "&mscr;": "\u{1D4C2}", "&mstpos;": "\u223E", "&mu;": "\u03BC", "&multimap;": "\u22B8", "&mumap;": "\u22B8", "&nGg;": "\u22D9\u0338", "&nGt;": "\u226B\u20D2", "&nGtv;": "\u226B\u0338", "&nLeftarrow;": "\u21CD", "&nLeftrightarrow;": "\u21CE", "&nLl;": "\u22D8\u0338", "&nLt;": "\u226A\u20D2", "&nLtv;": "\u226A\u0338", "&nRightarrow;": "\u21CF", "&nVDash;": "\u22AF", "&nVdash;": "\u22AE", "&nabla;": "\u2207", "&nacute;": "\u0144", "&nang;": "\u2220\u20D2", "&nap;": "\u2249", "&napE;": "\u2A70\u0338", "&napid;": "\u224B\u0338", "&napos;": "\u0149", "&napprox;": "\u2249", "&natur;": "\u266E", "&natural;": "\u266E", "&naturals;": "\u2115", "&nbsp": "\xA0", "&nbsp;": "\xA0", "&nbump;": "\u224E\u0338", "&nbumpe;": "\u224F\u0338", "&ncap;": "\u2A43", "&ncaron;": "\u0148", "&ncedil;": "\u0146", "&ncong;": "\u2247", "&ncongdot;": "\u2A6D\u0338", "&ncup;": "\u2A42", "&ncy;": "\u043D", "&ndash;": "\u2013", "&ne;": "\u2260", "&neArr;": "\u21D7", "&nearhk;": "\u2924", "&nearr;": "\u2197", "&nearrow;": "\u2197", "&nedot;": "\u2250\u0338", "&nequiv;": "\u2262", "&nesear;": "\u2928", "&nesim;": "\u2242\u0338", "&nexist;": "\u2204", "&nexists;": "\u2204", "&nfr;": "\u{1D52B}", "&ngE;": "\u2267\u0338", "&nge;": "\u2271", "&ngeq;": "\u2271", "&ngeqq;": "\u2267\u0338", "&ngeqslant;": "\u2A7E\u0338", "&nges;": "\u2A7E\u0338", "&ngsim;": "\u2275", "&ngt;": "\u226F", "&ngtr;": "\u226F", "&nhArr;": "\u21CE", "&nharr;": "\u21AE", "&nhpar;": "\u2AF2", "&ni;": "\u220B", "&nis;": "\u22FC", "&nisd;": "\u22FA", "&niv;": "\u220B", "&njcy;": "\u045A", "&nlArr;": "\u21CD", "&nlE;": "\u2266\u0338", "&nlarr;": "\u219A", "&nldr;": "\u2025", "&nle;": "\u2270", "&nleftarrow;": "\u219A", "&nleftrightarrow;": "\u21AE", "&nleq;": "\u2270", "&nleqq;": "\u2266\u0338", "&nleqslant;": "\u2A7D\u0338", "&nles;": "\u2A7D\u0338", "&nless;": "\u226E", "&nlsim;": "\u2274", "&nlt;": "\u226E", "&nltri;": "\u22EA", "&nltrie;": "\u22EC", "&nmid;": "\u2224", "&nopf;": "\u{1D55F}", "&not": "\xAC", "&not;": "\xAC", "&notin;": "\u2209", "&notinE;": "\u22F9\u0338", "&notindot;": "\u22F5\u0338", "&notinva;": "\u2209", "&notinvb;": "\u22F7", "&notinvc;": "\u22F6", "&notni;": "\u220C", "&notniva;": "\u220C", "&notnivb;": "\u22FE", "&notnivc;": "\u22FD", "&npar;": "\u2226", "&nparallel;": "\u2226", "&nparsl;": "\u2AFD\u20E5", "&npart;": "\u2202\u0338", "&npolint;": "\u2A14", "&npr;": "\u2280", "&nprcue;": "\u22E0", "&npre;": "\u2AAF\u0338", "&nprec;": "\u2280", "&npreceq;": "\u2AAF\u0338", "&nrArr;": "\u21CF", "&nrarr;": "\u219B", "&nrarrc;": "\u2933\u0338", "&nrarrw;": "\u219D\u0338", "&nrightarrow;": "\u219B", "&nrtri;": "\u22EB", "&nrtrie;": "\u22ED", "&nsc;": "\u2281", "&nsccue;": "\u22E1", "&nsce;": "\u2AB0\u0338", "&nscr;": "\u{1D4C3}", "&nshortmid;": "\u2224", "&nshortparallel;": "\u2226", "&nsim;": "\u2241", "&nsime;": "\u2244", "&nsimeq;": "\u2244", "&nsmid;": "\u2224", "&nspar;": "\u2226", "&nsqsube;": "\u22E2", "&nsqsupe;": "\u22E3", "&nsub;": "\u2284", "&nsubE;": "\u2AC5\u0338", "&nsube;": "\u2288", "&nsubset;": "\u2282\u20D2", "&nsubseteq;": "\u2288", "&nsubseteqq;": "\u2AC5\u0338", "&nsucc;": "\u2281", "&nsucceq;": "\u2AB0\u0338", "&nsup;": "\u2285", "&nsupE;": "\u2AC6\u0338", "&nsupe;": "\u2289", "&nsupset;": "\u2283\u20D2", "&nsupseteq;": "\u2289", "&nsupseteqq;": "\u2AC6\u0338", "&ntgl;": "\u2279", "&ntilde": "\xF1", "&ntilde;": "\xF1", "&ntlg;": "\u2278", "&ntriangleleft;": "\u22EA", "&ntrianglelefteq;": "\u22EC", "&ntriangleright;": "\u22EB", "&ntrianglerighteq;": "\u22ED", "&nu;": "\u03BD", "&num;": "#", "&numero;": "\u2116", "&numsp;": "\u2007", "&nvDash;": "\u22AD", "&nvHarr;": "\u2904", "&nvap;": "\u224D\u20D2", "&nvdash;": "\u22AC", "&nvge;": "\u2265\u20D2", "&nvgt;": ">\u20D2", "&nvinfin;": "\u29DE", "&nvlArr;": "\u2902", "&nvle;": "\u2264\u20D2", "&nvlt;": "<\u20D2", "&nvltrie;": "\u22B4\u20D2", "&nvrArr;": "\u2903", "&nvrtrie;": "\u22B5\u20D2", "&nvsim;": "\u223C\u20D2", "&nwArr;": "\u21D6", "&nwarhk;": "\u2923", "&nwarr;": "\u2196", "&nwarrow;": "\u2196", "&nwnear;": "\u2927", "&oS;": "\u24C8", "&oacute": "\xF3", "&oacute;": "\xF3", "&oast;": "\u229B", "&ocir;": "\u229A", "&ocirc": "\xF4", "&ocirc;": "\xF4", "&ocy;": "\u043E", "&odash;": "\u229D", "&odblac;": "\u0151", "&odiv;": "\u2A38", "&odot;": "\u2299", "&odsold;": "\u29BC", "&oelig;": "\u0153", "&ofcir;": "\u29BF", "&ofr;": "\u{1D52C}", "&ogon;": "\u02DB", "&ograve": "\xF2", "&ograve;": "\xF2", "&ogt;": "\u29C1", "&ohbar;": "\u29B5", "&ohm;": "\u03A9", "&oint;": "\u222E", "&olarr;": "\u21BA", "&olcir;": "\u29BE", "&olcross;": "\u29BB", "&oline;": "\u203E", "&olt;": "\u29C0", "&omacr;": "\u014D", "&omega;": "\u03C9", "&omicron;": "\u03BF", "&omid;": "\u29B6", "&ominus;": "\u2296", "&oopf;": "\u{1D560}", "&opar;": "\u29B7", "&operp;": "\u29B9", "&oplus;": "\u2295", "&or;": "\u2228", "&orarr;": "\u21BB", "&ord;": "\u2A5D", "&order;": "\u2134", "&orderof;": "\u2134", "&ordf": "\xAA", "&ordf;": "\xAA", "&ordm": "\xBA", "&ordm;": "\xBA", "&origof;": "\u22B6", "&oror;": "\u2A56", "&orslope;": "\u2A57", "&orv;": "\u2A5B", "&oscr;": "\u2134", "&oslash": "\xF8", "&oslash;": "\xF8", "&osol;": "\u2298", "&otilde": "\xF5", "&otilde;": "\xF5", "&otimes;": "\u2297", "&otimesas;": "\u2A36", "&ouml": "\xF6", "&ouml;": "\xF6", "&ovbar;": "\u233D", "&par;": "\u2225", "&para": "\xB6", "&para;": "\xB6", "&parallel;": "\u2225", "&parsim;": "\u2AF3", "&parsl;": "\u2AFD", "&part;": "\u2202", "&pcy;": "\u043F", "&percnt;": "%", "&period;": ".", "&permil;": "\u2030", "&perp;": "\u22A5", "&pertenk;": "\u2031", "&pfr;": "\u{1D52D}", "&phi;": "\u03C6", "&phiv;": "\u03D5", "&phmmat;": "\u2133", "&phone;": "\u260E", "&pi;": "\u03C0", "&pitchfork;": "\u22D4", "&piv;": "\u03D6", "&planck;": "\u210F", "&planckh;": "\u210E", "&plankv;": "\u210F", "&plus;": "+", "&plusacir;": "\u2A23", "&plusb;": "\u229E", "&pluscir;": "\u2A22", "&plusdo;": "\u2214", "&plusdu;": "\u2A25", "&pluse;": "\u2A72", "&plusmn": "\xB1", "&plusmn;": "\xB1", "&plussim;": "\u2A26", "&plustwo;": "\u2A27", "&pm;": "\xB1", "&pointint;": "\u2A15", "&popf;": "\u{1D561}", "&pound": "\xA3", "&pound;": "\xA3", "&pr;": "\u227A", "&prE;": "\u2AB3", "&prap;": "\u2AB7", "&prcue;": "\u227C", "&pre;": "\u2AAF", "&prec;": "\u227A", "&precapprox;": "\u2AB7", "&preccurlyeq;": "\u227C", "&preceq;": "\u2AAF", "&precnapprox;": "\u2AB9", "&precneqq;": "\u2AB5", "&precnsim;": "\u22E8", "&precsim;": "\u227E", "&prime;": "\u2032", "&primes;": "\u2119", "&prnE;": "\u2AB5", "&prnap;": "\u2AB9", "&prnsim;": "\u22E8", "&prod;": "\u220F", "&profalar;": "\u232E", "&profline;": "\u2312", "&profsurf;": "\u2313", "&prop;": "\u221D", "&propto;": "\u221D", "&prsim;": "\u227E", "&prurel;": "\u22B0", "&pscr;": "\u{1D4C5}", "&psi;": "\u03C8", "&puncsp;": "\u2008", "&qfr;": "\u{1D52E}", "&qint;": "\u2A0C", "&qopf;": "\u{1D562}", "&qprime;": "\u2057", "&qscr;": "\u{1D4C6}", "&quaternions;": "\u210D", "&quatint;": "\u2A16", "&quest;": "?", "&questeq;": "\u225F", "&quot": '"', "&quot;": '"', "&rAarr;": "\u21DB", "&rArr;": "\u21D2", "&rAtail;": "\u291C", "&rBarr;": "\u290F", "&rHar;": "\u2964", "&race;": "\u223D\u0331", "&racute;": "\u0155", "&radic;": "\u221A", "&raemptyv;": "\u29B3", "&rang;": "\u27E9", "&rangd;": "\u2992", "&range;": "\u29A5", "&rangle;": "\u27E9", "&raquo": "\xBB", "&raquo;": "\xBB", "&rarr;": "\u2192", "&rarrap;": "\u2975", "&rarrb;": "\u21E5", "&rarrbfs;": "\u2920", "&rarrc;": "\u2933", "&rarrfs;": "\u291E", "&rarrhk;": "\u21AA", "&rarrlp;": "\u21AC", "&rarrpl;": "\u2945", "&rarrsim;": "\u2974", "&rarrtl;": "\u21A3", "&rarrw;": "\u219D", "&ratail;": "\u291A", "&ratio;": "\u2236", "&rationals;": "\u211A", "&rbarr;": "\u290D", "&rbbrk;": "\u2773", "&rbrace;": "}", "&rbrack;": "]", "&rbrke;": "\u298C", "&rbrksld;": "\u298E", "&rbrkslu;": "\u2990", "&rcaron;": "\u0159", "&rcedil;": "\u0157", "&rceil;": "\u2309", "&rcub;": "}", "&rcy;": "\u0440", "&rdca;": "\u2937", "&rdldhar;": "\u2969", "&rdquo;": "\u201D", "&rdquor;": "\u201D", "&rdsh;": "\u21B3", "&real;": "\u211C", "&realine;": "\u211B", "&realpart;": "\u211C", "&reals;": "\u211D", "&rect;": "\u25AD", "&reg": "\xAE", "&reg;": "\xAE", "&rfisht;": "\u297D", "&rfloor;": "\u230B", "&rfr;": "\u{1D52F}", "&rhard;": "\u21C1", "&rharu;": "\u21C0", "&rharul;": "\u296C", "&rho;": "\u03C1", "&rhov;": "\u03F1", "&rightarrow;": "\u2192", "&rightarrowtail;": "\u21A3", "&rightharpoondown;": "\u21C1", "&rightharpoonup;": "\u21C0", "&rightleftarrows;": "\u21C4", "&rightleftharpoons;": "\u21CC", "&rightrightarrows;": "\u21C9", "&rightsquigarrow;": "\u219D", "&rightthreetimes;": "\u22CC", "&ring;": "\u02DA", "&risingdotseq;": "\u2253", "&rlarr;": "\u21C4", "&rlhar;": "\u21CC", "&rlm;": "\u200F", "&rmoust;": "\u23B1", "&rmoustache;": "\u23B1", "&rnmid;": "\u2AEE", "&roang;": "\u27ED", "&roarr;": "\u21FE", "&robrk;": "\u27E7", "&ropar;": "\u2986", "&ropf;": "\u{1D563}", "&roplus;": "\u2A2E", "&rotimes;": "\u2A35", "&rpar;": ")", "&rpargt;": "\u2994", "&rppolint;": "\u2A12", "&rrarr;": "\u21C9", "&rsaquo;": "\u203A", "&rscr;": "\u{1D4C7}", "&rsh;": "\u21B1", "&rsqb;": "]", "&rsquo;": "\u2019", "&rsquor;": "\u2019", "&rthree;": "\u22CC", "&rtimes;": "\u22CA", "&rtri;": "\u25B9", "&rtrie;": "\u22B5", "&rtrif;": "\u25B8", "&rtriltri;": "\u29CE", "&ruluhar;": "\u2968", "&rx;": "\u211E", "&sacute;": "\u015B", "&sbquo;": "\u201A", "&sc;": "\u227B", "&scE;": "\u2AB4", "&scap;": "\u2AB8", "&scaron;": "\u0161", "&sccue;": "\u227D", "&sce;": "\u2AB0", "&scedil;": "\u015F", "&scirc;": "\u015D", "&scnE;": "\u2AB6", "&scnap;": "\u2ABA", "&scnsim;": "\u22E9", "&scpolint;": "\u2A13", "&scsim;": "\u227F", "&scy;": "\u0441", "&sdot;": "\u22C5", "&sdotb;": "\u22A1", "&sdote;": "\u2A66", "&seArr;": "\u21D8", "&searhk;": "\u2925", "&searr;": "\u2198", "&searrow;": "\u2198", "&sect": "\xA7", "&sect;": "\xA7", "&semi;": ";", "&seswar;": "\u2929", "&setminus;": "\u2216", "&setmn;": "\u2216", "&sext;": "\u2736", "&sfr;": "\u{1D530}", "&sfrown;": "\u2322", "&sharp;": "\u266F", "&shchcy;": "\u0449", "&shcy;": "\u0448", "&shortmid;": "\u2223", "&shortparallel;": "\u2225", "&shy": "\xAD", "&shy;": "\xAD", "&sigma;": "\u03C3", "&sigmaf;": "\u03C2", "&sigmav;": "\u03C2", "&sim;": "\u223C", "&simdot;": "\u2A6A", "&sime;": "\u2243", "&simeq;": "\u2243", "&simg;": "\u2A9E", "&simgE;": "\u2AA0", "&siml;": "\u2A9D", "&simlE;": "\u2A9F", "&simne;": "\u2246", "&simplus;": "\u2A24", "&simrarr;": "\u2972", "&slarr;": "\u2190", "&smallsetminus;": "\u2216", "&smashp;": "\u2A33", "&smeparsl;": "\u29E4", "&smid;": "\u2223", "&smile;": "\u2323", "&smt;": "\u2AAA", "&smte;": "\u2AAC", "&smtes;": "\u2AAC\uFE00", "&softcy;": "\u044C", "&sol;": "/", "&solb;": "\u29C4", "&solbar;": "\u233F", "&sopf;": "\u{1D564}", "&spades;": "\u2660", "&spadesuit;": "\u2660", "&spar;": "\u2225", "&sqcap;": "\u2293", "&sqcaps;": "\u2293\uFE00", "&sqcup;": "\u2294", "&sqcups;": "\u2294\uFE00", "&sqsub;": "\u228F", "&sqsube;": "\u2291", "&sqsubset;": "\u228F", "&sqsubseteq;": "\u2291", "&sqsup;": "\u2290", "&sqsupe;": "\u2292", "&sqsupset;": "\u2290", "&sqsupseteq;": "\u2292", "&squ;": "\u25A1", "&square;": "\u25A1", "&squarf;": "\u25AA", "&squf;": "\u25AA", "&srarr;": "\u2192", "&sscr;": "\u{1D4C8}", "&ssetmn;": "\u2216", "&ssmile;": "\u2323", "&sstarf;": "\u22C6", "&star;": "\u2606", "&starf;": "\u2605", "&straightepsilon;": "\u03F5", "&straightphi;": "\u03D5", "&strns;": "\xAF", "&sub;": "\u2282", "&subE;": "\u2AC5", "&subdot;": "\u2ABD", "&sube;": "\u2286", "&subedot;": "\u2AC3", "&submult;": "\u2AC1", "&subnE;": "\u2ACB", "&subne;": "\u228A", "&subplus;": "\u2ABF", "&subrarr;": "\u2979", "&subset;": "\u2282", "&subseteq;": "\u2286", "&subseteqq;": "\u2AC5", "&subsetneq;": "\u228A", "&subsetneqq;": "\u2ACB", "&subsim;": "\u2AC7", "&subsub;": "\u2AD5", "&subsup;": "\u2AD3", "&succ;": "\u227B", "&succapprox;": "\u2AB8", "&succcurlyeq;": "\u227D", "&succeq;": "\u2AB0", "&succnapprox;": "\u2ABA", "&succneqq;": "\u2AB6", "&succnsim;": "\u22E9", "&succsim;": "\u227F", "&sum;": "\u2211", "&sung;": "\u266A", "&sup1": "\xB9", "&sup1;": "\xB9", "&sup2": "\xB2", "&sup2;": "\xB2", "&sup3": "\xB3", "&sup3;": "\xB3", "&sup;": "\u2283", "&supE;": "\u2AC6", "&supdot;": "\u2ABE", "&supdsub;": "\u2AD8", "&supe;": "\u2287", "&supedot;": "\u2AC4", "&suphsol;": "\u27C9", "&suphsub;": "\u2AD7", "&suplarr;": "\u297B", "&supmult;": "\u2AC2", "&supnE;": "\u2ACC", "&supne;": "\u228B", "&supplus;": "\u2AC0", "&supset;": "\u2283", "&supseteq;": "\u2287", "&supseteqq;": "\u2AC6", "&supsetneq;": "\u228B", "&supsetneqq;": "\u2ACC", "&supsim;": "\u2AC8", "&supsub;": "\u2AD4", "&supsup;": "\u2AD6", "&swArr;": "\u21D9", "&swarhk;": "\u2926", "&swarr;": "\u2199", "&swarrow;": "\u2199", "&swnwar;": "\u292A", "&szlig": "\xDF", "&szlig;": "\xDF", "&target;": "\u2316", "&tau;": "\u03C4", "&tbrk;": "\u23B4", "&tcaron;": "\u0165", "&tcedil;": "\u0163", "&tcy;": "\u0442", "&tdot;": "\u20DB", "&telrec;": "\u2315", "&tfr;": "\u{1D531}", "&there4;": "\u2234", "&therefore;": "\u2234", "&theta;": "\u03B8", "&thetasym;": "\u03D1", "&thetav;": "\u03D1", "&thickapprox;": "\u2248", "&thicksim;": "\u223C", "&thinsp;": "\u2009", "&thkap;": "\u2248", "&thksim;": "\u223C", "&thorn": "\xFE", "&thorn;": "\xFE", "&tilde;": "\u02DC", "&times": "\xD7", "&times;": "\xD7", "&timesb;": "\u22A0", "&timesbar;": "\u2A31", "&timesd;": "\u2A30", "&tint;": "\u222D", "&toea;": "\u2928", "&top;": "\u22A4", "&topbot;": "\u2336", "&topcir;": "\u2AF1", "&topf;": "\u{1D565}", "&topfork;": "\u2ADA", "&tosa;": "\u2929", "&tprime;": "\u2034", "&trade;": "\u2122", "&triangle;": "\u25B5", "&triangledown;": "\u25BF", "&triangleleft;": "\u25C3", "&trianglelefteq;": "\u22B4", "&triangleq;": "\u225C", "&triangleright;": "\u25B9", "&trianglerighteq;": "\u22B5", "&tridot;": "\u25EC", "&trie;": "\u225C", "&triminus;": "\u2A3A", "&triplus;": "\u2A39", "&trisb;": "\u29CD", "&tritime;": "\u2A3B", "&trpezium;": "\u23E2", "&tscr;": "\u{1D4C9}", "&tscy;": "\u0446", "&tshcy;": "\u045B", "&tstrok;": "\u0167", "&twixt;": "\u226C", "&twoheadleftarrow;": "\u219E", "&twoheadrightarrow;": "\u21A0", "&uArr;": "\u21D1", "&uHar;": "\u2963", "&uacute": "\xFA", "&uacute;": "\xFA", "&uarr;": "\u2191", "&ubrcy;": "\u045E", "&ubreve;": "\u016D", "&ucirc": "\xFB", "&ucirc;": "\xFB", "&ucy;": "\u0443", "&udarr;": "\u21C5", "&udblac;": "\u0171", "&udhar;": "\u296E", "&ufisht;": "\u297E", "&ufr;": "\u{1D532}", "&ugrave": "\xF9", "&ugrave;": "\xF9", "&uharl;": "\u21BF", "&uharr;": "\u21BE", "&uhblk;": "\u2580", "&ulcorn;": "\u231C", "&ulcorner;": "\u231C", "&ulcrop;": "\u230F", "&ultri;": "\u25F8", "&umacr;": "\u016B", "&uml": "\xA8", "&uml;": "\xA8", "&uogon;": "\u0173", "&uopf;": "\u{1D566}", "&uparrow;": "\u2191", "&updownarrow;": "\u2195", "&upharpoonleft;": "\u21BF", "&upharpoonright;": "\u21BE", "&uplus;": "\u228E", "&upsi;": "\u03C5", "&upsih;": "\u03D2", "&upsilon;": "\u03C5", "&upuparrows;": "\u21C8", "&urcorn;": "\u231D", "&urcorner;": "\u231D", "&urcrop;": "\u230E", "&uring;": "\u016F", "&urtri;": "\u25F9", "&uscr;": "\u{1D4CA}", "&utdot;": "\u22F0", "&utilde;": "\u0169", "&utri;": "\u25B5", "&utrif;": "\u25B4", "&uuarr;": "\u21C8", "&uuml": "\xFC", "&uuml;": "\xFC", "&uwangle;": "\u29A7", "&vArr;": "\u21D5", "&vBar;": "\u2AE8", "&vBarv;": "\u2AE9", "&vDash;": "\u22A8", "&vangrt;": "\u299C", "&varepsilon;": "\u03F5", "&varkappa;": "\u03F0", "&varnothing;": "\u2205", "&varphi;": "\u03D5", "&varpi;": "\u03D6", "&varpropto;": "\u221D", "&varr;": "\u2195", "&varrho;": "\u03F1", "&varsigma;": "\u03C2", "&varsubsetneq;": "\u228A\uFE00", "&varsubsetneqq;": "\u2ACB\uFE00", "&varsupsetneq;": "\u228B\uFE00", "&varsupsetneqq;": "\u2ACC\uFE00", "&vartheta;": "\u03D1", "&vartriangleleft;": "\u22B2", "&vartriangleright;": "\u22B3", "&vcy;": "\u0432", "&vdash;": "\u22A2", "&vee;": "\u2228", "&veebar;": "\u22BB", "&veeeq;": "\u225A", "&vellip;": "\u22EE", "&verbar;": "|", "&vert;": "|", "&vfr;": "\u{1D533}", "&vltri;": "\u22B2", "&vnsub;": "\u2282\u20D2", "&vnsup;": "\u2283\u20D2", "&vopf;": "\u{1D567}", "&vprop;": "\u221D", "&vrtri;": "\u22B3", "&vscr;": "\u{1D4CB}", "&vsubnE;": "\u2ACB\uFE00", "&vsubne;": "\u228A\uFE00", "&vsupnE;": "\u2ACC\uFE00", "&vsupne;": "\u228B\uFE00", "&vzigzag;": "\u299A", "&wcirc;": "\u0175", "&wedbar;": "\u2A5F", "&wedge;": "\u2227", "&wedgeq;": "\u2259", "&weierp;": "\u2118", "&wfr;": "\u{1D534}", "&wopf;": "\u{1D568}", "&wp;": "\u2118", "&wr;": "\u2240", "&wreath;": "\u2240", "&wscr;": "\u{1D4CC}", "&xcap;": "\u22C2", "&xcirc;": "\u25EF", "&xcup;": "\u22C3", "&xdtri;": "\u25BD", "&xfr;": "\u{1D535}", "&xhArr;": "\u27FA", "&xharr;": "\u27F7", "&xi;": "\u03BE", "&xlArr;": "\u27F8", "&xlarr;": "\u27F5", "&xmap;": "\u27FC", "&xnis;": "\u22FB", "&xodot;": "\u2A00", "&xopf;": "\u{1D569}", "&xoplus;": "\u2A01", "&xotime;": "\u2A02", "&xrArr;": "\u27F9", "&xrarr;": "\u27F6", "&xscr;": "\u{1D4CD}", "&xsqcup;": "\u2A06", "&xuplus;": "\u2A04", "&xutri;": "\u25B3", "&xvee;": "\u22C1", "&xwedge;": "\u22C0", "&yacute": "\xFD", "&yacute;": "\xFD", "&yacy;": "\u044F", "&ycirc;": "\u0177", "&ycy;": "\u044B", "&yen": "\xA5", "&yen;": "\xA5", "&yfr;": "\u{1D536}", "&yicy;": "\u0457", "&yopf;": "\u{1D56A}", "&yscr;": "\u{1D4CE}", "&yucy;": "\u044E", "&yuml": "\xFF", "&yuml;": "\xFF", "&zacute;": "\u017A", "&zcaron;": "\u017E", "&zcy;": "\u0437", "&zdot;": "\u017C", "&zeetrf;": "\u2128", "&zeta;": "\u03B6", "&zfr;": "\u{1D537}", "&zhcy;": "\u0436", "&zigrarr;": "\u21DD", "&zopf;": "\u{1D56B}", "&zscr;": "\u{1D4CF}", "&zwj;": "\u200D", "&zwnj;": "\u200C" }, characters: { "\xC6": "&AElig;", "&": "&amp;", "\xC1": "&Aacute;", "\u0102": "&Abreve;", "\xC2": "&Acirc;", "\u0410": "&Acy;", "\u{1D504}": "&Afr;", "\xC0": "&Agrave;", "\u0391": "&Alpha;", "\u0100": "&Amacr;", "\u2A53": "&And;", "\u0104": "&Aogon;", "\u{1D538}": "&Aopf;", "\u2061": "&af;", "\xC5": "&angst;", "\u{1D49C}": "&Ascr;", "\u2254": "&coloneq;", "\xC3": "&Atilde;", "\xC4": "&Auml;", "\u2216": "&ssetmn;", "\u2AE7": "&Barv;", "\u2306": "&doublebarwedge;", "\u0411": "&Bcy;", "\u2235": "&because;", "\u212C": "&bernou;", "\u0392": "&Beta;", "\u{1D505}": "&Bfr;", "\u{1D539}": "&Bopf;", "\u02D8": "&breve;", "\u224E": "&bump;", "\u0427": "&CHcy;", "\xA9": "&copy;", "\u0106": "&Cacute;", "\u22D2": "&Cap;", "\u2145": "&DD;", "\u212D": "&Cfr;", "\u010C": "&Ccaron;", "\xC7": "&Ccedil;", "\u0108": "&Ccirc;", "\u2230": "&Cconint;", "\u010A": "&Cdot;", "\xB8": "&cedil;", "\xB7": "&middot;", "\u03A7": "&Chi;", "\u2299": "&odot;", "\u2296": "&ominus;", "\u2295": "&oplus;", "\u2297": "&otimes;", "\u2232": "&cwconint;", "\u201D": "&rdquor;", "\u2019": "&rsquor;", "\u2237": "&Proportion;", "\u2A74": "&Colone;", "\u2261": "&equiv;", "\u222F": "&DoubleContourIntegral;", "\u222E": "&oint;", "\u2102": "&complexes;", "\u2210": "&coprod;", "\u2233": "&awconint;", "\u2A2F": "&Cross;", "\u{1D49E}": "&Cscr;", "\u22D3": "&Cup;", "\u224D": "&asympeq;", "\u2911": "&DDotrahd;", "\u0402": "&DJcy;", "\u0405": "&DScy;", "\u040F": "&DZcy;", "\u2021": "&ddagger;", "\u21A1": "&Darr;", "\u2AE4": "&DoubleLeftTee;", "\u010E": "&Dcaron;", "\u0414": "&Dcy;", "\u2207": "&nabla;", "\u0394": "&Delta;", "\u{1D507}": "&Dfr;", "\xB4": "&acute;", "\u02D9": "&dot;", "\u02DD": "&dblac;", "`": "&grave;", "\u02DC": "&tilde;", "\u22C4": "&diamond;", "\u2146": "&dd;", "\u{1D53B}": "&Dopf;", "\xA8": "&uml;", "\u20DC": "&DotDot;", "\u2250": "&esdot;", "\u21D3": "&dArr;", "\u21D0": "&lArr;", "\u21D4": "&iff;", "\u27F8": "&xlArr;", "\u27FA": "&xhArr;", "\u27F9": "&xrArr;", "\u21D2": "&rArr;", "\u22A8": "&vDash;", "\u21D1": "&uArr;", "\u21D5": "&vArr;", "\u2225": "&spar;", "\u2193": "&downarrow;", "\u2913": "&DownArrowBar;", "\u21F5": "&duarr;", "\u0311": "&DownBreve;", "\u2950": "&DownLeftRightVector;", "\u295E": "&DownLeftTeeVector;", "\u21BD": "&lhard;", "\u2956": "&DownLeftVectorBar;", "\u295F": "&DownRightTeeVector;", "\u21C1": "&rightharpoondown;", "\u2957": "&DownRightVectorBar;", "\u22A4": "&top;", "\u21A7": "&mapstodown;", "\u{1D49F}": "&Dscr;", "\u0110": "&Dstrok;", "\u014A": "&ENG;", "\xD0": "&ETH;", "\xC9": "&Eacute;", "\u011A": "&Ecaron;", "\xCA": "&Ecirc;", "\u042D": "&Ecy;", "\u0116": "&Edot;", "\u{1D508}": "&Efr;", "\xC8": "&Egrave;", "\u2208": "&isinv;", "\u0112": "&Emacr;", "\u25FB": "&EmptySmallSquare;", "\u25AB": "&EmptyVerySmallSquare;", "\u0118": "&Eogon;", "\u{1D53C}": "&Eopf;", "\u0395": "&Epsilon;", "\u2A75": "&Equal;", "\u2242": "&esim;", "\u21CC": "&rlhar;", "\u2130": "&expectation;", "\u2A73": "&Esim;", "\u0397": "&Eta;", "\xCB": "&Euml;", "\u2203": "&exist;", "\u2147": "&exponentiale;", "\u0424": "&Fcy;", "\u{1D509}": "&Ffr;", "\u25FC": "&FilledSmallSquare;", "\u25AA": "&squf;", "\u{1D53D}": "&Fopf;", "\u2200": "&forall;", "\u2131": "&Fscr;", "\u0403": "&GJcy;", ">": "&gt;", "\u0393": "&Gamma;", "\u03DC": "&Gammad;", "\u011E": "&Gbreve;", "\u0122": "&Gcedil;", "\u011C": "&Gcirc;", "\u0413": "&Gcy;", "\u0120": "&Gdot;", "\u{1D50A}": "&Gfr;", "\u22D9": "&ggg;", "\u{1D53E}": "&Gopf;", "\u2265": "&geq;", "\u22DB": "&gtreqless;", "\u2267": "&geqq;", "\u2AA2": "&GreaterGreater;", "\u2277": "&gtrless;", "\u2A7E": "&ges;", "\u2273": "&gtrsim;", "\u{1D4A2}": "&Gscr;", "\u226B": "&gg;", "\u042A": "&HARDcy;", "\u02C7": "&caron;", "^": "&Hat;", "\u0124": "&Hcirc;", "\u210C": "&Poincareplane;", "\u210B": "&hamilt;", "\u210D": "&quaternions;", "\u2500": "&boxh;", "\u0126": "&Hstrok;", "\u224F": "&bumpeq;", "\u0415": "&IEcy;", "\u0132": "&IJlig;", "\u0401": "&IOcy;", "\xCD": "&Iacute;", "\xCE": "&Icirc;", "\u0418": "&Icy;", "\u0130": "&Idot;", "\u2111": "&imagpart;", "\xCC": "&Igrave;", "\u012A": "&Imacr;", "\u2148": "&ii;", "\u222C": "&Int;", "\u222B": "&int;", "\u22C2": "&xcap;", "\u2063": "&ic;", "\u2062": "&it;", "\u012E": "&Iogon;", "\u{1D540}": "&Iopf;", "\u0399": "&Iota;", "\u2110": "&imagline;", "\u0128": "&Itilde;", "\u0406": "&Iukcy;", "\xCF": "&Iuml;", "\u0134": "&Jcirc;", "\u0419": "&Jcy;", "\u{1D50D}": "&Jfr;", "\u{1D541}": "&Jopf;", "\u{1D4A5}": "&Jscr;", "\u0408": "&Jsercy;", "\u0404": "&Jukcy;", "\u0425": "&KHcy;", "\u040C": "&KJcy;", "\u039A": "&Kappa;", "\u0136": "&Kcedil;", "\u041A": "&Kcy;", "\u{1D50E}": "&Kfr;", "\u{1D542}": "&Kopf;", "\u{1D4A6}": "&Kscr;", "\u0409": "&LJcy;", "<": "&lt;", "\u0139": "&Lacute;", "\u039B": "&Lambda;", "\u27EA": "&Lang;", "\u2112": "&lagran;", "\u219E": "&twoheadleftarrow;", "\u013D": "&Lcaron;", "\u013B": "&Lcedil;", "\u041B": "&Lcy;", "\u27E8": "&langle;", "\u2190": "&slarr;", "\u21E4": "&larrb;", "\u21C6": "&lrarr;", "\u2308": "&lceil;", "\u27E6": "&lobrk;", "\u2961": "&LeftDownTeeVector;", "\u21C3": "&downharpoonleft;", "\u2959": "&LeftDownVectorBar;", "\u230A": "&lfloor;", "\u2194": "&leftrightarrow;", "\u294E": "&LeftRightVector;", "\u22A3": "&dashv;", "\u21A4": "&mapstoleft;", "\u295A": "&LeftTeeVector;", "\u22B2": "&vltri;", "\u29CF": "&LeftTriangleBar;", "\u22B4": "&trianglelefteq;", "\u2951": "&LeftUpDownVector;", "\u2960": "&LeftUpTeeVector;", "\u21BF": "&upharpoonleft;", "\u2958": "&LeftUpVectorBar;", "\u21BC": "&lharu;", "\u2952": "&LeftVectorBar;", "\u22DA": "&lesseqgtr;", "\u2266": "&leqq;", "\u2276": "&lg;", "\u2AA1": "&LessLess;", "\u2A7D": "&les;", "\u2272": "&lsim;", "\u{1D50F}": "&Lfr;", "\u22D8": "&Ll;", "\u21DA": "&lAarr;", "\u013F": "&Lmidot;", "\u27F5": "&xlarr;", "\u27F7": "&xharr;", "\u27F6": "&xrarr;", "\u{1D543}": "&Lopf;", "\u2199": "&swarrow;", "\u2198": "&searrow;", "\u21B0": "&lsh;", "\u0141": "&Lstrok;", "\u226A": "&ll;", "\u2905": "&Map;", "\u041C": "&Mcy;", "\u205F": "&MediumSpace;", "\u2133": "&phmmat;", "\u{1D510}": "&Mfr;", "\u2213": "&mp;", "\u{1D544}": "&Mopf;", "\u039C": "&Mu;", "\u040A": "&NJcy;", "\u0143": "&Nacute;", "\u0147": "&Ncaron;", "\u0145": "&Ncedil;", "\u041D": "&Ncy;", "\u200B": "&ZeroWidthSpace;", "\n": "&NewLine;", "\u{1D511}": "&Nfr;", "\u2060": "&NoBreak;", "\xA0": "&nbsp;", "\u2115": "&naturals;", "\u2AEC": "&Not;", "\u2262": "&nequiv;", "\u226D": "&NotCupCap;", "\u2226": "&nspar;", "\u2209": "&notinva;", "\u2260": "&ne;", "\u2242\u0338": "&nesim;", "\u2204": "&nexists;", "\u226F": "&ngtr;", "\u2271": "&ngeq;", "\u2267\u0338": "&ngeqq;", "\u226B\u0338": "&nGtv;", "\u2279": "&ntgl;", "\u2A7E\u0338": "&nges;", "\u2275": "&ngsim;", "\u224E\u0338": "&nbump;", "\u224F\u0338": "&nbumpe;", "\u22EA": "&ntriangleleft;", "\u29CF\u0338": "&NotLeftTriangleBar;", "\u22EC": "&ntrianglelefteq;", "\u226E": "&nlt;", "\u2270": "&nleq;", "\u2278": "&ntlg;", "\u226A\u0338": "&nLtv;", "\u2A7D\u0338": "&nles;", "\u2274": "&nlsim;", "\u2AA2\u0338": "&NotNestedGreaterGreater;", "\u2AA1\u0338": "&NotNestedLessLess;", "\u2280": "&nprec;", "\u2AAF\u0338": "&npreceq;", "\u22E0": "&nprcue;", "\u220C": "&notniva;", "\u22EB": "&ntriangleright;", "\u29D0\u0338": "&NotRightTriangleBar;", "\u22ED": "&ntrianglerighteq;", "\u228F\u0338": "&NotSquareSubset;", "\u22E2": "&nsqsube;", "\u2290\u0338": "&NotSquareSuperset;", "\u22E3": "&nsqsupe;", "\u2282\u20D2": "&vnsub;", "\u2288": "&nsubseteq;", "\u2281": "&nsucc;", "\u2AB0\u0338": "&nsucceq;", "\u22E1": "&nsccue;", "\u227F\u0338": "&NotSucceedsTilde;", "\u2283\u20D2": "&vnsup;", "\u2289": "&nsupseteq;", "\u2241": "&nsim;", "\u2244": "&nsimeq;", "\u2247": "&ncong;", "\u2249": "&napprox;", "\u2224": "&nsmid;", "\u{1D4A9}": "&Nscr;", "\xD1": "&Ntilde;", "\u039D": "&Nu;", "\u0152": "&OElig;", "\xD3": "&Oacute;", "\xD4": "&Ocirc;", "\u041E": "&Ocy;", "\u0150": "&Odblac;", "\u{1D512}": "&Ofr;", "\xD2": "&Ograve;", "\u014C": "&Omacr;", "\u03A9": "&ohm;", "\u039F": "&Omicron;", "\u{1D546}": "&Oopf;", "\u201C": "&ldquo;", "\u2018": "&lsquo;", "\u2A54": "&Or;", "\u{1D4AA}": "&Oscr;", "\xD8": "&Oslash;", "\xD5": "&Otilde;", "\u2A37": "&Otimes;", "\xD6": "&Ouml;", "\u203E": "&oline;", "\u23DE": "&OverBrace;", "\u23B4": "&tbrk;", "\u23DC": "&OverParenthesis;", "\u2202": "&part;", "\u041F": "&Pcy;", "\u{1D513}": "&Pfr;", "\u03A6": "&Phi;", "\u03A0": "&Pi;", "\xB1": "&pm;", "\u2119": "&primes;", "\u2ABB": "&Pr;", "\u227A": "&prec;", "\u2AAF": "&preceq;", "\u227C": "&preccurlyeq;", "\u227E": "&prsim;", "\u2033": "&Prime;", "\u220F": "&prod;", "\u221D": "&vprop;", "\u{1D4AB}": "&Pscr;", "\u03A8": "&Psi;", '"': "&quot;", "\u{1D514}": "&Qfr;", "\u211A": "&rationals;", "\u{1D4AC}": "&Qscr;", "\u2910": "&drbkarow;", "\xAE": "&reg;", "\u0154": "&Racute;", "\u27EB": "&Rang;", "\u21A0": "&twoheadrightarrow;", "\u2916": "&Rarrtl;", "\u0158": "&Rcaron;", "\u0156": "&Rcedil;", "\u0420": "&Rcy;", "\u211C": "&realpart;", "\u220B": "&niv;", "\u21CB": "&lrhar;", "\u296F": "&duhar;", "\u03A1": "&Rho;", "\u27E9": "&rangle;", "\u2192": "&srarr;", "\u21E5": "&rarrb;", "\u21C4": "&rlarr;", "\u2309": "&rceil;", "\u27E7": "&robrk;", "\u295D": "&RightDownTeeVector;", "\u21C2": "&downharpoonright;", "\u2955": "&RightDownVectorBar;", "\u230B": "&rfloor;", "\u22A2": "&vdash;", "\u21A6": "&mapsto;", "\u295B": "&RightTeeVector;", "\u22B3": "&vrtri;", "\u29D0": "&RightTriangleBar;", "\u22B5": "&trianglerighteq;", "\u294F": "&RightUpDownVector;", "\u295C": "&RightUpTeeVector;", "\u21BE": "&upharpoonright;", "\u2954": "&RightUpVectorBar;", "\u21C0": "&rightharpoonup;", "\u2953": "&RightVectorBar;", "\u211D": "&reals;", "\u2970": "&RoundImplies;", "\u21DB": "&rAarr;", "\u211B": "&realine;", "\u21B1": "&rsh;", "\u29F4": "&RuleDelayed;", "\u0429": "&SHCHcy;", "\u0428": "&SHcy;", "\u042C": "&SOFTcy;", "\u015A": "&Sacute;", "\u2ABC": "&Sc;", "\u0160": "&Scaron;", "\u015E": "&Scedil;", "\u015C": "&Scirc;", "\u0421": "&Scy;", "\u{1D516}": "&Sfr;", "\u2191": "&uparrow;", "\u03A3": "&Sigma;", "\u2218": "&compfn;", "\u{1D54A}": "&Sopf;", "\u221A": "&radic;", "\u25A1": "&square;", "\u2293": "&sqcap;", "\u228F": "&sqsubset;", "\u2291": "&sqsubseteq;", "\u2290": "&sqsupset;", "\u2292": "&sqsupseteq;", "\u2294": "&sqcup;", "\u{1D4AE}": "&Sscr;", "\u22C6": "&sstarf;", "\u22D0": "&Subset;", "\u2286": "&subseteq;", "\u227B": "&succ;", "\u2AB0": "&succeq;", "\u227D": "&succcurlyeq;", "\u227F": "&succsim;", "\u2211": "&sum;", "\u22D1": "&Supset;", "\u2283": "&supset;", "\u2287": "&supseteq;", "\xDE": "&THORN;", "\u2122": "&trade;", "\u040B": "&TSHcy;", "\u0426": "&TScy;", "	": "&Tab;", "\u03A4": "&Tau;", "\u0164": "&Tcaron;", "\u0162": "&Tcedil;", "\u0422": "&Tcy;", "\u{1D517}": "&Tfr;", "\u2234": "&therefore;", "\u0398": "&Theta;", "\u205F\u200A": "&ThickSpace;", "\u2009": "&thinsp;", "\u223C": "&thksim;", "\u2243": "&simeq;", "\u2245": "&cong;", "\u2248": "&thkap;", "\u{1D54B}": "&Topf;", "\u20DB": "&tdot;", "\u{1D4AF}": "&Tscr;", "\u0166": "&Tstrok;", "\xDA": "&Uacute;", "\u219F": "&Uarr;", "\u2949": "&Uarrocir;", "\u040E": "&Ubrcy;", "\u016C": "&Ubreve;", "\xDB": "&Ucirc;", "\u0423": "&Ucy;", "\u0170": "&Udblac;", "\u{1D518}": "&Ufr;", "\xD9": "&Ugrave;", "\u016A": "&Umacr;", _: "&lowbar;", "\u23DF": "&UnderBrace;", "\u23B5": "&bbrk;", "\u23DD": "&UnderParenthesis;", "\u22C3": "&xcup;", "\u228E": "&uplus;", "\u0172": "&Uogon;", "\u{1D54C}": "&Uopf;", "\u2912": "&UpArrowBar;", "\u21C5": "&udarr;", "\u2195": "&varr;", "\u296E": "&udhar;", "\u22A5": "&perp;", "\u21A5": "&mapstoup;", "\u2196": "&nwarrow;", "\u2197": "&nearrow;", "\u03D2": "&upsih;", "\u03A5": "&Upsilon;", "\u016E": "&Uring;", "\u{1D4B0}": "&Uscr;", "\u0168": "&Utilde;", "\xDC": "&Uuml;", "\u22AB": "&VDash;", "\u2AEB": "&Vbar;", "\u0412": "&Vcy;", "\u22A9": "&Vdash;", "\u2AE6": "&Vdashl;", "\u22C1": "&xvee;", "\u2016": "&Vert;", "\u2223": "&smid;", "|": "&vert;", "\u2758": "&VerticalSeparator;", "\u2240": "&wreath;", "\u200A": "&hairsp;", "\u{1D519}": "&Vfr;", "\u{1D54D}": "&Vopf;", "\u{1D4B1}": "&Vscr;", "\u22AA": "&Vvdash;", "\u0174": "&Wcirc;", "\u22C0": "&xwedge;", "\u{1D51A}": "&Wfr;", "\u{1D54E}": "&Wopf;", "\u{1D4B2}": "&Wscr;", "\u{1D51B}": "&Xfr;", "\u039E": "&Xi;", "\u{1D54F}": "&Xopf;", "\u{1D4B3}": "&Xscr;", "\u042F": "&YAcy;", "\u0407": "&YIcy;", "\u042E": "&YUcy;", "\xDD": "&Yacute;", "\u0176": "&Ycirc;", "\u042B": "&Ycy;", "\u{1D51C}": "&Yfr;", "\u{1D550}": "&Yopf;", "\u{1D4B4}": "&Yscr;", "\u0178": "&Yuml;", "\u0416": "&ZHcy;", "\u0179": "&Zacute;", "\u017D": "&Zcaron;", "\u0417": "&Zcy;", "\u017B": "&Zdot;", "\u0396": "&Zeta;", "\u2128": "&zeetrf;", "\u2124": "&integers;", "\u{1D4B5}": "&Zscr;", "\xE1": "&aacute;", "\u0103": "&abreve;", "\u223E": "&mstpos;", "\u223E\u0333": "&acE;", "\u223F": "&acd;", "\xE2": "&acirc;", "\u0430": "&acy;", "\xE6": "&aelig;", "\u{1D51E}": "&afr;", "\xE0": "&agrave;", "\u2135": "&aleph;", "\u03B1": "&alpha;", "\u0101": "&amacr;", "\u2A3F": "&amalg;", "\u2227": "&wedge;", "\u2A55": "&andand;", "\u2A5C": "&andd;", "\u2A58": "&andslope;", "\u2A5A": "&andv;", "\u2220": "&angle;", "\u29A4": "&ange;", "\u2221": "&measuredangle;", "\u29A8": "&angmsdaa;", "\u29A9": "&angmsdab;", "\u29AA": "&angmsdac;", "\u29AB": "&angmsdad;", "\u29AC": "&angmsdae;", "\u29AD": "&angmsdaf;", "\u29AE": "&angmsdag;", "\u29AF": "&angmsdah;", "\u221F": "&angrt;", "\u22BE": "&angrtvb;", "\u299D": "&angrtvbd;", "\u2222": "&angsph;", "\u237C": "&angzarr;", "\u0105": "&aogon;", "\u{1D552}": "&aopf;", "\u2A70": "&apE;", "\u2A6F": "&apacir;", "\u224A": "&approxeq;", "\u224B": "&apid;", "'": "&apos;", "\xE5": "&aring;", "\u{1D4B6}": "&ascr;", "*": "&midast;", "\xE3": "&atilde;", "\xE4": "&auml;", "\u2A11": "&awint;", "\u2AED": "&bNot;", "\u224C": "&bcong;", "\u03F6": "&bepsi;", "\u2035": "&bprime;", "\u223D": "&bsim;", "\u22CD": "&bsime;", "\u22BD": "&barvee;", "\u2305": "&barwedge;", "\u23B6": "&bbrktbrk;", "\u0431": "&bcy;", "\u201E": "&ldquor;", "\u29B0": "&bemptyv;", "\u03B2": "&beta;", "\u2136": "&beth;", "\u226C": "&twixt;", "\u{1D51F}": "&bfr;", "\u25EF": "&xcirc;", "\u2A00": "&xodot;", "\u2A01": "&xoplus;", "\u2A02": "&xotime;", "\u2A06": "&xsqcup;", "\u2605": "&starf;", "\u25BD": "&xdtri;", "\u25B3": "&xutri;", "\u2A04": "&xuplus;", "\u290D": "&rbarr;", "\u29EB": "&lozf;", "\u25B4": "&utrif;", "\u25BE": "&dtrif;", "\u25C2": "&ltrif;", "\u25B8": "&rtrif;", "\u2423": "&blank;", "\u2592": "&blk12;", "\u2591": "&blk14;", "\u2593": "&blk34;", "\u2588": "&block;", "=\u20E5": "&bne;", "\u2261\u20E5": "&bnequiv;", "\u2310": "&bnot;", "\u{1D553}": "&bopf;", "\u22C8": "&bowtie;", "\u2557": "&boxDL;", "\u2554": "&boxDR;", "\u2556": "&boxDl;", "\u2553": "&boxDr;", "\u2550": "&boxH;", "\u2566": "&boxHD;", "\u2569": "&boxHU;", "\u2564": "&boxHd;", "\u2567": "&boxHu;", "\u255D": "&boxUL;", "\u255A": "&boxUR;", "\u255C": "&boxUl;", "\u2559": "&boxUr;", "\u2551": "&boxV;", "\u256C": "&boxVH;", "\u2563": "&boxVL;", "\u2560": "&boxVR;", "\u256B": "&boxVh;", "\u2562": "&boxVl;", "\u255F": "&boxVr;", "\u29C9": "&boxbox;", "\u2555": "&boxdL;", "\u2552": "&boxdR;", "\u2510": "&boxdl;", "\u250C": "&boxdr;", "\u2565": "&boxhD;", "\u2568": "&boxhU;", "\u252C": "&boxhd;", "\u2534": "&boxhu;", "\u229F": "&minusb;", "\u229E": "&plusb;", "\u22A0": "&timesb;", "\u255B": "&boxuL;", "\u2558": "&boxuR;", "\u2518": "&boxul;", "\u2514": "&boxur;", "\u2502": "&boxv;", "\u256A": "&boxvH;", "\u2561": "&boxvL;", "\u255E": "&boxvR;", "\u253C": "&boxvh;", "\u2524": "&boxvl;", "\u251C": "&boxvr;", "\xA6": "&brvbar;", "\u{1D4B7}": "&bscr;", "\u204F": "&bsemi;", "\\": "&bsol;", "\u29C5": "&bsolb;", "\u27C8": "&bsolhsub;", "\u2022": "&bullet;", "\u2AAE": "&bumpE;", "\u0107": "&cacute;", "\u2229": "&cap;", "\u2A44": "&capand;", "\u2A49": "&capbrcup;", "\u2A4B": "&capcap;", "\u2A47": "&capcup;", "\u2A40": "&capdot;", "\u2229\uFE00": "&caps;", "\u2041": "&caret;", "\u2A4D": "&ccaps;", "\u010D": "&ccaron;", "\xE7": "&ccedil;", "\u0109": "&ccirc;", "\u2A4C": "&ccups;", "\u2A50": "&ccupssm;", "\u010B": "&cdot;", "\u29B2": "&cemptyv;", "\xA2": "&cent;", "\u{1D520}": "&cfr;", "\u0447": "&chcy;", "\u2713": "&checkmark;", "\u03C7": "&chi;", "\u25CB": "&cir;", "\u29C3": "&cirE;", "\u02C6": "&circ;", "\u2257": "&cire;", "\u21BA": "&olarr;", "\u21BB": "&orarr;", "\u24C8": "&oS;", "\u229B": "&oast;", "\u229A": "&ocir;", "\u229D": "&odash;", "\u2A10": "&cirfnint;", "\u2AEF": "&cirmid;", "\u29C2": "&cirscir;", "\u2663": "&clubsuit;", ":": "&colon;", ",": "&comma;", "@": "&commat;", "\u2201": "&complement;", "\u2A6D": "&congdot;", "\u{1D554}": "&copf;", "\u2117": "&copysr;", "\u21B5": "&crarr;", "\u2717": "&cross;", "\u{1D4B8}": "&cscr;", "\u2ACF": "&csub;", "\u2AD1": "&csube;", "\u2AD0": "&csup;", "\u2AD2": "&csupe;", "\u22EF": "&ctdot;", "\u2938": "&cudarrl;", "\u2935": "&cudarrr;", "\u22DE": "&curlyeqprec;", "\u22DF": "&curlyeqsucc;", "\u21B6": "&curvearrowleft;", "\u293D": "&cularrp;", "\u222A": "&cup;", "\u2A48": "&cupbrcap;", "\u2A46": "&cupcap;", "\u2A4A": "&cupcup;", "\u228D": "&cupdot;", "\u2A45": "&cupor;", "\u222A\uFE00": "&cups;", "\u21B7": "&curvearrowright;", "\u293C": "&curarrm;", "\u22CE": "&cuvee;", "\u22CF": "&cuwed;", "\xA4": "&curren;", "\u2231": "&cwint;", "\u232D": "&cylcty;", "\u2965": "&dHar;", "\u2020": "&dagger;", "\u2138": "&daleth;", "\u2010": "&hyphen;", "\u290F": "&rBarr;", "\u010F": "&dcaron;", "\u0434": "&dcy;", "\u21CA": "&downdownarrows;", "\u2A77": "&eDDot;", "\xB0": "&deg;", "\u03B4": "&delta;", "\u29B1": "&demptyv;", "\u297F": "&dfisht;", "\u{1D521}": "&dfr;", "\u2666": "&diams;", "\u03DD": "&gammad;", "\u22F2": "&disin;", "\xF7": "&divide;", "\u22C7": "&divonx;", "\u0452": "&djcy;", "\u231E": "&llcorner;", "\u230D": "&dlcrop;", $: "&dollar;", "\u{1D555}": "&dopf;", "\u2251": "&eDot;", "\u2238": "&minusd;", "\u2214": "&plusdo;", "\u22A1": "&sdotb;", "\u231F": "&lrcorner;", "\u230C": "&drcrop;", "\u{1D4B9}": "&dscr;", "\u0455": "&dscy;", "\u29F6": "&dsol;", "\u0111": "&dstrok;", "\u22F1": "&dtdot;", "\u25BF": "&triangledown;", "\u29A6": "&dwangle;", "\u045F": "&dzcy;", "\u27FF": "&dzigrarr;", "\xE9": "&eacute;", "\u2A6E": "&easter;", "\u011B": "&ecaron;", "\u2256": "&eqcirc;", "\xEA": "&ecirc;", "\u2255": "&eqcolon;", "\u044D": "&ecy;", "\u0117": "&edot;", "\u2252": "&fallingdotseq;", "\u{1D522}": "&efr;", "\u2A9A": "&eg;", "\xE8": "&egrave;", "\u2A96": "&eqslantgtr;", "\u2A98": "&egsdot;", "\u2A99": "&el;", "\u23E7": "&elinters;", "\u2113": "&ell;", "\u2A95": "&eqslantless;", "\u2A97": "&elsdot;", "\u0113": "&emacr;", "\u2205": "&varnothing;", "\u2004": "&emsp13;", "\u2005": "&emsp14;", "\u2003": "&emsp;", "\u014B": "&eng;", "\u2002": "&ensp;", "\u0119": "&eogon;", "\u{1D556}": "&eopf;", "\u22D5": "&epar;", "\u29E3": "&eparsl;", "\u2A71": "&eplus;", "\u03B5": "&epsilon;", "\u03F5": "&varepsilon;", "=": "&equals;", "\u225F": "&questeq;", "\u2A78": "&equivDD;", "\u29E5": "&eqvparsl;", "\u2253": "&risingdotseq;", "\u2971": "&erarr;", "\u212F": "&escr;", "\u03B7": "&eta;", "\xF0": "&eth;", "\xEB": "&euml;", "\u20AC": "&euro;", "!": "&excl;", "\u0444": "&fcy;", "\u2640": "&female;", "\uFB03": "&ffilig;", "\uFB00": "&fflig;", "\uFB04": "&ffllig;", "\u{1D523}": "&ffr;", "\uFB01": "&filig;", fj: "&fjlig;", "\u266D": "&flat;", "\uFB02": "&fllig;", "\u25B1": "&fltns;", "\u0192": "&fnof;", "\u{1D557}": "&fopf;", "\u22D4": "&pitchfork;", "\u2AD9": "&forkv;", "\u2A0D": "&fpartint;", "\xBD": "&half;", "\u2153": "&frac13;", "\xBC": "&frac14;", "\u2155": "&frac15;", "\u2159": "&frac16;", "\u215B": "&frac18;", "\u2154": "&frac23;", "\u2156": "&frac25;", "\xBE": "&frac34;", "\u2157": "&frac35;", "\u215C": "&frac38;", "\u2158": "&frac45;", "\u215A": "&frac56;", "\u215D": "&frac58;", "\u215E": "&frac78;", "\u2044": "&frasl;", "\u2322": "&sfrown;", "\u{1D4BB}": "&fscr;", "\u2A8C": "&gtreqqless;", "\u01F5": "&gacute;", "\u03B3": "&gamma;", "\u2A86": "&gtrapprox;", "\u011F": "&gbreve;", "\u011D": "&gcirc;", "\u0433": "&gcy;", "\u0121": "&gdot;", "\u2AA9": "&gescc;", "\u2A80": "&gesdot;", "\u2A82": "&gesdoto;", "\u2A84": "&gesdotol;", "\u22DB\uFE00": "&gesl;", "\u2A94": "&gesles;", "\u{1D524}": "&gfr;", "\u2137": "&gimel;", "\u0453": "&gjcy;", "\u2A92": "&glE;", "\u2AA5": "&gla;", "\u2AA4": "&glj;", "\u2269": "&gneqq;", "\u2A8A": "&gnapprox;", "\u2A88": "&gneq;", "\u22E7": "&gnsim;", "\u{1D558}": "&gopf;", "\u210A": "&gscr;", "\u2A8E": "&gsime;", "\u2A90": "&gsiml;", "\u2AA7": "&gtcc;", "\u2A7A": "&gtcir;", "\u22D7": "&gtrdot;", "\u2995": "&gtlPar;", "\u2A7C": "&gtquest;", "\u2978": "&gtrarr;", "\u2269\uFE00": "&gvnE;", "\u044A": "&hardcy;", "\u2948": "&harrcir;", "\u21AD": "&leftrightsquigarrow;", "\u210F": "&plankv;", "\u0125": "&hcirc;", "\u2665": "&heartsuit;", "\u2026": "&mldr;", "\u22B9": "&hercon;", "\u{1D525}": "&hfr;", "\u2925": "&searhk;", "\u2926": "&swarhk;", "\u21FF": "&hoarr;", "\u223B": "&homtht;", "\u21A9": "&larrhk;", "\u21AA": "&rarrhk;", "\u{1D559}": "&hopf;", "\u2015": "&horbar;", "\u{1D4BD}": "&hscr;", "\u0127": "&hstrok;", "\u2043": "&hybull;", "\xED": "&iacute;", "\xEE": "&icirc;", "\u0438": "&icy;", "\u0435": "&iecy;", "\xA1": "&iexcl;", "\u{1D526}": "&ifr;", "\xEC": "&igrave;", "\u2A0C": "&qint;", "\u222D": "&tint;", "\u29DC": "&iinfin;", "\u2129": "&iiota;", "\u0133": "&ijlig;", "\u012B": "&imacr;", "\u0131": "&inodot;", "\u22B7": "&imof;", "\u01B5": "&imped;", "\u2105": "&incare;", "\u221E": "&infin;", "\u29DD": "&infintie;", "\u22BA": "&intercal;", "\u2A17": "&intlarhk;", "\u2A3C": "&iprod;", "\u0451": "&iocy;", "\u012F": "&iogon;", "\u{1D55A}": "&iopf;", "\u03B9": "&iota;", "\xBF": "&iquest;", "\u{1D4BE}": "&iscr;", "\u22F9": "&isinE;", "\u22F5": "&isindot;", "\u22F4": "&isins;", "\u22F3": "&isinsv;", "\u0129": "&itilde;", "\u0456": "&iukcy;", "\xEF": "&iuml;", "\u0135": "&jcirc;", "\u0439": "&jcy;", "\u{1D527}": "&jfr;", "\u0237": "&jmath;", "\u{1D55B}": "&jopf;", "\u{1D4BF}": "&jscr;", "\u0458": "&jsercy;", "\u0454": "&jukcy;", "\u03BA": "&kappa;", "\u03F0": "&varkappa;", "\u0137": "&kcedil;", "\u043A": "&kcy;", "\u{1D528}": "&kfr;", "\u0138": "&kgreen;", "\u0445": "&khcy;", "\u045C": "&kjcy;", "\u{1D55C}": "&kopf;", "\u{1D4C0}": "&kscr;", "\u291B": "&lAtail;", "\u290E": "&lBarr;", "\u2A8B": "&lesseqqgtr;", "\u2962": "&lHar;", "\u013A": "&lacute;", "\u29B4": "&laemptyv;", "\u03BB": "&lambda;", "\u2991": "&langd;", "\u2A85": "&lessapprox;", "\xAB": "&laquo;", "\u291F": "&larrbfs;", "\u291D": "&larrfs;", "\u21AB": "&looparrowleft;", "\u2939": "&larrpl;", "\u2973": "&larrsim;", "\u21A2": "&leftarrowtail;", "\u2AAB": "&lat;", "\u2919": "&latail;", "\u2AAD": "&late;", "\u2AAD\uFE00": "&lates;", "\u290C": "&lbarr;", "\u2772": "&lbbrk;", "{": "&lcub;", "[": "&lsqb;", "\u298B": "&lbrke;", "\u298F": "&lbrksld;", "\u298D": "&lbrkslu;", "\u013E": "&lcaron;", "\u013C": "&lcedil;", "\u043B": "&lcy;", "\u2936": "&ldca;", "\u2967": "&ldrdhar;", "\u294B": "&ldrushar;", "\u21B2": "&ldsh;", "\u2264": "&leq;", "\u21C7": "&llarr;", "\u22CB": "&lthree;", "\u2AA8": "&lescc;", "\u2A7F": "&lesdot;", "\u2A81": "&lesdoto;", "\u2A83": "&lesdotor;", "\u22DA\uFE00": "&lesg;", "\u2A93": "&lesges;", "\u22D6": "&ltdot;", "\u297C": "&lfisht;", "\u{1D529}": "&lfr;", "\u2A91": "&lgE;", "\u296A": "&lharul;", "\u2584": "&lhblk;", "\u0459": "&ljcy;", "\u296B": "&llhard;", "\u25FA": "&lltri;", "\u0140": "&lmidot;", "\u23B0": "&lmoustache;", "\u2268": "&lneqq;", "\u2A89": "&lnapprox;", "\u2A87": "&lneq;", "\u22E6": "&lnsim;", "\u27EC": "&loang;", "\u21FD": "&loarr;", "\u27FC": "&xmap;", "\u21AC": "&rarrlp;", "\u2985": "&lopar;", "\u{1D55D}": "&lopf;", "\u2A2D": "&loplus;", "\u2A34": "&lotimes;", "\u2217": "&lowast;", "\u25CA": "&lozenge;", "(": "&lpar;", "\u2993": "&lparlt;", "\u296D": "&lrhard;", "\u200E": "&lrm;", "\u22BF": "&lrtri;", "\u2039": "&lsaquo;", "\u{1D4C1}": "&lscr;", "\u2A8D": "&lsime;", "\u2A8F": "&lsimg;", "\u201A": "&sbquo;", "\u0142": "&lstrok;", "\u2AA6": "&ltcc;", "\u2A79": "&ltcir;", "\u22C9": "&ltimes;", "\u2976": "&ltlarr;", "\u2A7B": "&ltquest;", "\u2996": "&ltrPar;", "\u25C3": "&triangleleft;", "\u294A": "&lurdshar;", "\u2966": "&luruhar;", "\u2268\uFE00": "&lvnE;", "\u223A": "&mDDot;", "\xAF": "&strns;", "\u2642": "&male;", "\u2720": "&maltese;", "\u25AE": "&marker;", "\u2A29": "&mcomma;", "\u043C": "&mcy;", "\u2014": "&mdash;", "\u{1D52A}": "&mfr;", "\u2127": "&mho;", "\xB5": "&micro;", "\u2AF0": "&midcir;", "\u2212": "&minus;", "\u2A2A": "&minusdu;", "\u2ADB": "&mlcp;", "\u22A7": "&models;", "\u{1D55E}": "&mopf;", "\u{1D4C2}": "&mscr;", "\u03BC": "&mu;", "\u22B8": "&mumap;", "\u22D9\u0338": "&nGg;", "\u226B\u20D2": "&nGt;", "\u21CD": "&nlArr;", "\u21CE": "&nhArr;", "\u22D8\u0338": "&nLl;", "\u226A\u20D2": "&nLt;", "\u21CF": "&nrArr;", "\u22AF": "&nVDash;", "\u22AE": "&nVdash;", "\u0144": "&nacute;", "\u2220\u20D2": "&nang;", "\u2A70\u0338": "&napE;", "\u224B\u0338": "&napid;", "\u0149": "&napos;", "\u266E": "&natural;", "\u2A43": "&ncap;", "\u0148": "&ncaron;", "\u0146": "&ncedil;", "\u2A6D\u0338": "&ncongdot;", "\u2A42": "&ncup;", "\u043D": "&ncy;", "\u2013": "&ndash;", "\u21D7": "&neArr;", "\u2924": "&nearhk;", "\u2250\u0338": "&nedot;", "\u2928": "&toea;", "\u{1D52B}": "&nfr;", "\u21AE": "&nleftrightarrow;", "\u2AF2": "&nhpar;", "\u22FC": "&nis;", "\u22FA": "&nisd;", "\u045A": "&njcy;", "\u2266\u0338": "&nleqq;", "\u219A": "&nleftarrow;", "\u2025": "&nldr;", "\u{1D55F}": "&nopf;", "\xAC": "&not;", "\u22F9\u0338": "&notinE;", "\u22F5\u0338": "&notindot;", "\u22F7": "&notinvb;", "\u22F6": "&notinvc;", "\u22FE": "&notnivb;", "\u22FD": "&notnivc;", "\u2AFD\u20E5": "&nparsl;", "\u2202\u0338": "&npart;", "\u2A14": "&npolint;", "\u219B": "&nrightarrow;", "\u2933\u0338": "&nrarrc;", "\u219D\u0338": "&nrarrw;", "\u{1D4C3}": "&nscr;", "\u2284": "&nsub;", "\u2AC5\u0338": "&nsubseteqq;", "\u2285": "&nsup;", "\u2AC6\u0338": "&nsupseteqq;", "\xF1": "&ntilde;", "\u03BD": "&nu;", "#": "&num;", "\u2116": "&numero;", "\u2007": "&numsp;", "\u22AD": "&nvDash;", "\u2904": "&nvHarr;", "\u224D\u20D2": "&nvap;", "\u22AC": "&nvdash;", "\u2265\u20D2": "&nvge;", ">\u20D2": "&nvgt;", "\u29DE": "&nvinfin;", "\u2902": "&nvlArr;", "\u2264\u20D2": "&nvle;", "<\u20D2": "&nvlt;", "\u22B4\u20D2": "&nvltrie;", "\u2903": "&nvrArr;", "\u22B5\u20D2": "&nvrtrie;", "\u223C\u20D2": "&nvsim;", "\u21D6": "&nwArr;", "\u2923": "&nwarhk;", "\u2927": "&nwnear;", "\xF3": "&oacute;", "\xF4": "&ocirc;", "\u043E": "&ocy;", "\u0151": "&odblac;", "\u2A38": "&odiv;", "\u29BC": "&odsold;", "\u0153": "&oelig;", "\u29BF": "&ofcir;", "\u{1D52C}": "&ofr;", "\u02DB": "&ogon;", "\xF2": "&ograve;", "\u29C1": "&ogt;", "\u29B5": "&ohbar;", "\u29BE": "&olcir;", "\u29BB": "&olcross;", "\u29C0": "&olt;", "\u014D": "&omacr;", "\u03C9": "&omega;", "\u03BF": "&omicron;", "\u29B6": "&omid;", "\u{1D560}": "&oopf;", "\u29B7": "&opar;", "\u29B9": "&operp;", "\u2228": "&vee;", "\u2A5D": "&ord;", "\u2134": "&oscr;", "\xAA": "&ordf;", "\xBA": "&ordm;", "\u22B6": "&origof;", "\u2A56": "&oror;", "\u2A57": "&orslope;", "\u2A5B": "&orv;", "\xF8": "&oslash;", "\u2298": "&osol;", "\xF5": "&otilde;", "\u2A36": "&otimesas;", "\xF6": "&ouml;", "\u233D": "&ovbar;", "\xB6": "&para;", "\u2AF3": "&parsim;", "\u2AFD": "&parsl;", "\u043F": "&pcy;", "%": "&percnt;", ".": "&period;", "\u2030": "&permil;", "\u2031": "&pertenk;", "\u{1D52D}": "&pfr;", "\u03C6": "&phi;", "\u03D5": "&varphi;", "\u260E": "&phone;", "\u03C0": "&pi;", "\u03D6": "&varpi;", "\u210E": "&planckh;", "+": "&plus;", "\u2A23": "&plusacir;", "\u2A22": "&pluscir;", "\u2A25": "&plusdu;", "\u2A72": "&pluse;", "\u2A26": "&plussim;", "\u2A27": "&plustwo;", "\u2A15": "&pointint;", "\u{1D561}": "&popf;", "\xA3": "&pound;", "\u2AB3": "&prE;", "\u2AB7": "&precapprox;", "\u2AB9": "&prnap;", "\u2AB5": "&prnE;", "\u22E8": "&prnsim;", "\u2032": "&prime;", "\u232E": "&profalar;", "\u2312": "&profline;", "\u2313": "&profsurf;", "\u22B0": "&prurel;", "\u{1D4C5}": "&pscr;", "\u03C8": "&psi;", "\u2008": "&puncsp;", "\u{1D52E}": "&qfr;", "\u{1D562}": "&qopf;", "\u2057": "&qprime;", "\u{1D4C6}": "&qscr;", "\u2A16": "&quatint;", "?": "&quest;", "\u291C": "&rAtail;", "\u2964": "&rHar;", "\u223D\u0331": "&race;", "\u0155": "&racute;", "\u29B3": "&raemptyv;", "\u2992": "&rangd;", "\u29A5": "&range;", "\xBB": "&raquo;", "\u2975": "&rarrap;", "\u2920": "&rarrbfs;", "\u2933": "&rarrc;", "\u291E": "&rarrfs;", "\u2945": "&rarrpl;", "\u2974": "&rarrsim;", "\u21A3": "&rightarrowtail;", "\u219D": "&rightsquigarrow;", "\u291A": "&ratail;", "\u2236": "&ratio;", "\u2773": "&rbbrk;", "}": "&rcub;", "]": "&rsqb;", "\u298C": "&rbrke;", "\u298E": "&rbrksld;", "\u2990": "&rbrkslu;", "\u0159": "&rcaron;", "\u0157": "&rcedil;", "\u0440": "&rcy;", "\u2937": "&rdca;", "\u2969": "&rdldhar;", "\u21B3": "&rdsh;", "\u25AD": "&rect;", "\u297D": "&rfisht;", "\u{1D52F}": "&rfr;", "\u296C": "&rharul;", "\u03C1": "&rho;", "\u03F1": "&varrho;", "\u21C9": "&rrarr;", "\u22CC": "&rthree;", "\u02DA": "&ring;", "\u200F": "&rlm;", "\u23B1": "&rmoustache;", "\u2AEE": "&rnmid;", "\u27ED": "&roang;", "\u21FE": "&roarr;", "\u2986": "&ropar;", "\u{1D563}": "&ropf;", "\u2A2E": "&roplus;", "\u2A35": "&rotimes;", ")": "&rpar;", "\u2994": "&rpargt;", "\u2A12": "&rppolint;", "\u203A": "&rsaquo;", "\u{1D4C7}": "&rscr;", "\u22CA": "&rtimes;", "\u25B9": "&triangleright;", "\u29CE": "&rtriltri;", "\u2968": "&ruluhar;", "\u211E": "&rx;", "\u015B": "&sacute;", "\u2AB4": "&scE;", "\u2AB8": "&succapprox;", "\u0161": "&scaron;", "\u015F": "&scedil;", "\u015D": "&scirc;", "\u2AB6": "&succneqq;", "\u2ABA": "&succnapprox;", "\u22E9": "&succnsim;", "\u2A13": "&scpolint;", "\u0441": "&scy;", "\u22C5": "&sdot;", "\u2A66": "&sdote;", "\u21D8": "&seArr;", "\xA7": "&sect;", ";": "&semi;", "\u2929": "&tosa;", "\u2736": "&sext;", "\u{1D530}": "&sfr;", "\u266F": "&sharp;", "\u0449": "&shchcy;", "\u0448": "&shcy;", "\xAD": "&shy;", "\u03C3": "&sigma;", "\u03C2": "&varsigma;", "\u2A6A": "&simdot;", "\u2A9E": "&simg;", "\u2AA0": "&simgE;", "\u2A9D": "&siml;", "\u2A9F": "&simlE;", "\u2246": "&simne;", "\u2A24": "&simplus;", "\u2972": "&simrarr;", "\u2A33": "&smashp;", "\u29E4": "&smeparsl;", "\u2323": "&ssmile;", "\u2AAA": "&smt;", "\u2AAC": "&smte;", "\u2AAC\uFE00": "&smtes;", "\u044C": "&softcy;", "/": "&sol;", "\u29C4": "&solb;", "\u233F": "&solbar;", "\u{1D564}": "&sopf;", "\u2660": "&spadesuit;", "\u2293\uFE00": "&sqcaps;", "\u2294\uFE00": "&sqcups;", "\u{1D4C8}": "&sscr;", "\u2606": "&star;", "\u2282": "&subset;", "\u2AC5": "&subseteqq;", "\u2ABD": "&subdot;", "\u2AC3": "&subedot;", "\u2AC1": "&submult;", "\u2ACB": "&subsetneqq;", "\u228A": "&subsetneq;", "\u2ABF": "&subplus;", "\u2979": "&subrarr;", "\u2AC7": "&subsim;", "\u2AD5": "&subsub;", "\u2AD3": "&subsup;", "\u266A": "&sung;", "\xB9": "&sup1;", "\xB2": "&sup2;", "\xB3": "&sup3;", "\u2AC6": "&supseteqq;", "\u2ABE": "&supdot;", "\u2AD8": "&supdsub;", "\u2AC4": "&supedot;", "\u27C9": "&suphsol;", "\u2AD7": "&suphsub;", "\u297B": "&suplarr;", "\u2AC2": "&supmult;", "\u2ACC": "&supsetneqq;", "\u228B": "&supsetneq;", "\u2AC0": "&supplus;", "\u2AC8": "&supsim;", "\u2AD4": "&supsub;", "\u2AD6": "&supsup;", "\u21D9": "&swArr;", "\u292A": "&swnwar;", "\xDF": "&szlig;", "\u2316": "&target;", "\u03C4": "&tau;", "\u0165": "&tcaron;", "\u0163": "&tcedil;", "\u0442": "&tcy;", "\u2315": "&telrec;", "\u{1D531}": "&tfr;", "\u03B8": "&theta;", "\u03D1": "&vartheta;", "\xFE": "&thorn;", "\xD7": "&times;", "\u2A31": "&timesbar;", "\u2A30": "&timesd;", "\u2336": "&topbot;", "\u2AF1": "&topcir;", "\u{1D565}": "&topf;", "\u2ADA": "&topfork;", "\u2034": "&tprime;", "\u25B5": "&utri;", "\u225C": "&trie;", "\u25EC": "&tridot;", "\u2A3A": "&triminus;", "\u2A39": "&triplus;", "\u29CD": "&trisb;", "\u2A3B": "&tritime;", "\u23E2": "&trpezium;", "\u{1D4C9}": "&tscr;", "\u0446": "&tscy;", "\u045B": "&tshcy;", "\u0167": "&tstrok;", "\u2963": "&uHar;", "\xFA": "&uacute;", "\u045E": "&ubrcy;", "\u016D": "&ubreve;", "\xFB": "&ucirc;", "\u0443": "&ucy;", "\u0171": "&udblac;", "\u297E": "&ufisht;", "\u{1D532}": "&ufr;", "\xF9": "&ugrave;", "\u2580": "&uhblk;", "\u231C": "&ulcorner;", "\u230F": "&ulcrop;", "\u25F8": "&ultri;", "\u016B": "&umacr;", "\u0173": "&uogon;", "\u{1D566}": "&uopf;", "\u03C5": "&upsilon;", "\u21C8": "&uuarr;", "\u231D": "&urcorner;", "\u230E": "&urcrop;", "\u016F": "&uring;", "\u25F9": "&urtri;", "\u{1D4CA}": "&uscr;", "\u22F0": "&utdot;", "\u0169": "&utilde;", "\xFC": "&uuml;", "\u29A7": "&uwangle;", "\u2AE8": "&vBar;", "\u2AE9": "&vBarv;", "\u299C": "&vangrt;", "\u228A\uFE00": "&vsubne;", "\u2ACB\uFE00": "&vsubnE;", "\u228B\uFE00": "&vsupne;", "\u2ACC\uFE00": "&vsupnE;", "\u0432": "&vcy;", "\u22BB": "&veebar;", "\u225A": "&veeeq;", "\u22EE": "&vellip;", "\u{1D533}": "&vfr;", "\u{1D567}": "&vopf;", "\u{1D4CB}": "&vscr;", "\u299A": "&vzigzag;", "\u0175": "&wcirc;", "\u2A5F": "&wedbar;", "\u2259": "&wedgeq;", "\u2118": "&wp;", "\u{1D534}": "&wfr;", "\u{1D568}": "&wopf;", "\u{1D4CC}": "&wscr;", "\u{1D535}": "&xfr;", "\u03BE": "&xi;", "\u22FB": "&xnis;", "\u{1D569}": "&xopf;", "\u{1D4CD}": "&xscr;", "\xFD": "&yacute;", "\u044F": "&yacy;", "\u0177": "&ycirc;", "\u044B": "&ycy;", "\xA5": "&yen;", "\u{1D536}": "&yfr;", "\u0457": "&yicy;", "\u{1D56A}": "&yopf;", "\u{1D4CE}": "&yscr;", "\u044E": "&yucy;", "\xFF": "&yuml;", "\u017A": "&zacute;", "\u017E": "&zcaron;", "\u0437": "&zcy;", "\u017C": "&zdot;", "\u03B6": "&zeta;", "\u{1D537}": "&zfr;", "\u0436": "&zhcy;", "\u21DD": "&zigrarr;", "\u{1D56B}": "&zopf;", "\u{1D4CF}": "&zscr;", "\u200D": "&zwj;", "\u200C": "&zwnj;" } } };
    }
  });

  // node_modules/html-entities/lib/numeric-unicode-map.js
  var require_numeric_unicode_map = __commonJS({
    "node_modules/html-entities/lib/numeric-unicode-map.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.numericUnicodeMap = { 0: 65533, 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 };
    }
  });

  // node_modules/html-entities/lib/surrogate-pairs.js
  var require_surrogate_pairs = __commonJS({
    "node_modules/html-entities/lib/surrogate-pairs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromCodePoint = String.fromCodePoint || function(astralCodePoint) {
        return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);
      };
      exports.getCodePoint = String.prototype.codePointAt ? function(input, position2) {
        return input.codePointAt(position2);
      } : function(input, position2) {
        return (input.charCodeAt(position2) - 55296) * 1024 + input.charCodeAt(position2 + 1) - 56320 + 65536;
      };
      exports.highSurrogateFrom = 55296;
      exports.highSurrogateTo = 56319;
    }
  });

  // node_modules/html-entities/lib/index.js
  var require_lib = __commonJS({
    "node_modules/html-entities/lib/index.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var named_references_1 = require_named_references();
      var numeric_unicode_map_1 = require_numeric_unicode_map();
      var surrogate_pairs_1 = require_surrogate_pairs();
      var allNamedReferences = __assign(__assign({}, named_references_1.namedReferences), { all: named_references_1.namedReferences.html5 });
      var encodeRegExps = { specialChars: /[<>'"&]/g, nonAscii: /[<>'"&\u0080-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g, nonAsciiPrintable: /[<>'"&\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g, nonAsciiPrintableOnly: /[\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g, extensive: /[\x01-\x0c\x0e-\x1f\x21-\x2c\x2e-\x2f\x3a-\x40\x5b-\x60\x7b-\x7d\x7f-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g };
      var defaultEncodeOptions = { mode: "specialChars", level: "all", numeric: "decimal" };
      function encode(text2, _a2) {
        var _b = _a2 === void 0 ? defaultEncodeOptions : _a2, _c = _b.mode, mode = _c === void 0 ? "specialChars" : _c, _d = _b.numeric, numeric = _d === void 0 ? "decimal" : _d, _e = _b.level, level = _e === void 0 ? "all" : _e;
        if (!text2) {
          return "";
        }
        var encodeRegExp = encodeRegExps[mode];
        var references = allNamedReferences[level].characters;
        var isHex = numeric === "hexadecimal";
        return text2.replace(encodeRegExp, function(input) {
          var result = references[input];
          if (!result) {
            var code = input.length > 1 ? surrogate_pairs_1.getCodePoint(input, 0) : input.charCodeAt(0);
            result = (isHex ? "&#x" + code.toString(16) : "&#" + code) + ";";
          }
          return result;
        });
      }
      exports.encode = encode;
      var defaultDecodeOptions = { scope: "body", level: "all" };
      var strict = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g;
      var attribute = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;
      var baseDecodeRegExps = { xml: { strict, attribute, body: named_references_1.bodyRegExps.xml }, html4: { strict, attribute, body: named_references_1.bodyRegExps.html4 }, html5: { strict, attribute, body: named_references_1.bodyRegExps.html5 } };
      var decodeRegExps = __assign(__assign({}, baseDecodeRegExps), { all: baseDecodeRegExps.html5 });
      var fromCharCode = String.fromCharCode;
      var outOfBoundsChar = fromCharCode(65533);
      var defaultDecodeEntityOptions = { level: "all" };
      function getDecodedEntity(entity, references, isAttribute, isStrict) {
        var decodeResult = entity;
        var decodeEntityLastChar = entity[entity.length - 1];
        if (isAttribute && decodeEntityLastChar === "=") {
          decodeResult = entity;
        } else if (isStrict && decodeEntityLastChar !== ";") {
          decodeResult = entity;
        } else {
          var decodeResultByReference = references[entity];
          if (decodeResultByReference) {
            decodeResult = decodeResultByReference;
          } else if (entity[0] === "&" && entity[1] === "#") {
            var decodeSecondChar = entity[2];
            var decodeCode = decodeSecondChar == "x" || decodeSecondChar == "X" ? parseInt(entity.substr(3), 16) : parseInt(entity.substr(2));
            decodeResult = decodeCode >= 1114111 ? outOfBoundsChar : decodeCode > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode] || decodeCode);
          }
        }
        return decodeResult;
      }
      function decodeEntity(entity, _a2) {
        var _b = (_a2 === void 0 ? defaultDecodeEntityOptions : _a2).level, level = _b === void 0 ? "all" : _b;
        if (!entity) {
          return "";
        }
        return getDecodedEntity(entity, allNamedReferences[level].entities, false, false);
      }
      exports.decodeEntity = decodeEntity;
      function decode2(text2, _a2) {
        var _b = _a2 === void 0 ? defaultDecodeOptions : _a2, _c = _b.level, level = _c === void 0 ? "all" : _c, _d = _b.scope, scope = _d === void 0 ? level === "xml" ? "strict" : "body" : _d;
        if (!text2) {
          return "";
        }
        var decodeRegExp = decodeRegExps[level][scope];
        var references = allNamedReferences[level].entities;
        var isAttribute = scope === "attribute";
        var isStrict = scope === "strict";
        return text2.replace(decodeRegExp, function(entity) {
          return getDecodedEntity(entity, references, isAttribute, isStrict);
        });
      }
      exports.decode = decode2;
    }
  });

  // js/beacon_live_admin.js
  var import_topbar = __toESM(require_topbar());

  // ../deps/live_monaco_editor/priv/static/live_monaco_editor.esm.js
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source2 = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source2), true).forEach(function(key) {
          _defineProperty(target, key, source2[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
      } else {
        ownKeys(Object(source2)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
        });
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose(source2, excluded) {
    if (source2 == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source2);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source2[key];
    }
    return target;
  }
  function _objectWithoutProperties(source2, excluded) {
    if (source2 == null) return {};
    var target = _objectWithoutPropertiesLoose(source2, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source2, key)) continue;
        target[key] = source2[key];
      }
    }
    return target;
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _defineProperty2(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function ownKeys2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread22(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source2 = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys2(Object(source2), true).forEach(function(key) {
          _defineProperty2(target, key, source2[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
      } else {
        ownKeys2(Object(source2)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
        });
      }
    }
    return target;
  }
  function compose() {
    for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
      fns[_key] = arguments[_key];
    }
    return function(x) {
      return fns.reduceRight(function(y, f) {
        return f(y);
      }, x);
    };
  }
  function curry(fn) {
    return function curried() {
      var _this = this;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return args.length >= fn.length ? fn.apply(this, args) : function() {
        for (var _len3 = arguments.length, nextArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          nextArgs[_key3] = arguments[_key3];
        }
        return curried.apply(_this, [].concat(args, nextArgs));
      };
    };
  }
  function isObject(value2) {
    return {}.toString.call(value2).includes("Object");
  }
  function isEmpty(obj) {
    return !Object.keys(obj).length;
  }
  function isFunction(value2) {
    return typeof value2 === "function";
  }
  function hasOwnProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }
  function validateChanges(initial, changes) {
    if (!isObject(changes)) errorHandler("changeType");
    if (Object.keys(changes).some(function(field) {
      return !hasOwnProperty(initial, field);
    })) errorHandler("changeField");
    return changes;
  }
  function validateSelector(selector) {
    if (!isFunction(selector)) errorHandler("selectorType");
  }
  function validateHandler(handler) {
    if (!(isFunction(handler) || isObject(handler))) errorHandler("handlerType");
    if (isObject(handler) && Object.values(handler).some(function(_handler) {
      return !isFunction(_handler);
    })) errorHandler("handlersType");
  }
  function validateInitial(initial) {
    if (!initial) errorHandler("initialIsRequired");
    if (!isObject(initial)) errorHandler("initialType");
    if (isEmpty(initial)) errorHandler("initialContent");
  }
  function throwError(errorMessages32, type) {
    throw new Error(errorMessages32[type] || errorMessages32["default"]);
  }
  var errorMessages = {
    initialIsRequired: "initial state is required",
    initialType: "initial state should be an object",
    initialContent: "initial state shouldn't be an empty object",
    handlerType: "handler should be an object or a function",
    handlersType: "all handlers should be a functions",
    selectorType: "selector should be a function",
    changeType: "provided value of changes should be an object",
    changeField: 'it seams you want to change a field in the state which is not specified in the "initial" state',
    "default": "an unknown error accured in `state-local` package"
  };
  var errorHandler = curry(throwError)(errorMessages);
  var validators = {
    changes: validateChanges,
    selector: validateSelector,
    handler: validateHandler,
    initial: validateInitial
  };
  function create(initial) {
    var handler = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    validators.initial(initial);
    validators.handler(handler);
    var state2 = {
      current: initial
    };
    var didUpdate = curry(didStateUpdate)(state2, handler);
    var update2 = curry(updateState)(state2);
    var validate = curry(validators.changes)(initial);
    var getChanges = curry(extractChanges)(state2);
    function getState22() {
      var selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function(state22) {
        return state22;
      };
      validators.selector(selector);
      return selector(state2.current);
    }
    function setState22(causedChanges) {
      compose(didUpdate, update2, validate, getChanges)(causedChanges);
    }
    return [getState22, setState22];
  }
  function extractChanges(state2, causedChanges) {
    return isFunction(causedChanges) ? causedChanges(state2.current) : causedChanges;
  }
  function updateState(state2, changes) {
    state2.current = _objectSpread22(_objectSpread22({}, state2.current), changes);
    return changes;
  }
  function didStateUpdate(state2, handler, changes) {
    isFunction(handler) ? handler(state2.current) : Object.keys(changes).forEach(function(field) {
      var _handler$field;
      return (_handler$field = handler[field]) === null || _handler$field === void 0 ? void 0 : _handler$field.call(handler, state2.current[field]);
    });
    return changes;
  }
  var index = {
    create
  };
  var state_local_default = index;
  var config = {
    paths: {
      vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs"
    }
  };
  var config_default = config;
  function curry2(fn) {
    return function curried() {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return args.length >= fn.length ? fn.apply(this, args) : function() {
        for (var _len2 = arguments.length, nextArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          nextArgs[_key2] = arguments[_key2];
        }
        return curried.apply(_this, [].concat(args, nextArgs));
      };
    };
  }
  var curry_default = curry2;
  function isObject2(value2) {
    return {}.toString.call(value2).includes("Object");
  }
  var isObject_default = isObject2;
  function validateConfig(config32) {
    if (!config32) errorHandler2("configIsRequired");
    if (!isObject_default(config32)) errorHandler2("configType");
    if (config32.urls) {
      informAboutDeprecation();
      return {
        paths: {
          vs: config32.urls.monacoBase
        }
      };
    }
    return config32;
  }
  function informAboutDeprecation() {
    console.warn(errorMessages2.deprecation);
  }
  function throwError2(errorMessages32, type) {
    throw new Error(errorMessages32[type] || errorMessages32["default"]);
  }
  var errorMessages2 = {
    configIsRequired: "the configuration object is required",
    configType: "the configuration object should be an object",
    "default": "an unknown error accured in `@monaco-editor/loader` package",
    deprecation: "Deprecation warning!\n    You are using deprecated way of configuration.\n\n    Instead of using\n      monaco.config({ urls: { monacoBase: '...' } })\n    use\n      monaco.config({ paths: { vs: '...' } })\n\n    For more please check the link https://github.com/suren-atoyan/monaco-loader#config\n  "
  };
  var errorHandler2 = curry_default(throwError2)(errorMessages2);
  var validators2 = {
    config: validateConfig
  };
  var validators_default = validators2;
  var compose2 = function compose3() {
    for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
      fns[_key] = arguments[_key];
    }
    return function(x) {
      return fns.reduceRight(function(y, f) {
        return f(y);
      }, x);
    };
  };
  var compose_default = compose2;
  function merge(target, source2) {
    Object.keys(source2).forEach(function(key) {
      if (source2[key] instanceof Object) {
        if (target[key]) {
          Object.assign(source2[key], merge(target[key], source2[key]));
        }
      }
    });
    return _objectSpread2(_objectSpread2({}, target), source2);
  }
  var deepMerge_default = merge;
  var CANCELATION_MESSAGE = {
    type: "cancelation",
    msg: "operation is manually canceled"
  };
  function makeCancelable(promise) {
    var hasCanceled_ = false;
    var wrappedPromise = new Promise(function(resolve, reject) {
      promise.then(function(val) {
        return hasCanceled_ ? reject(CANCELATION_MESSAGE) : resolve(val);
      });
      promise["catch"](reject);
    });
    return wrappedPromise.cancel = function() {
      return hasCanceled_ = true;
    }, wrappedPromise;
  }
  var makeCancelable_default = makeCancelable;
  var _state$create = state_local_default.create({
    config: config_default,
    isInitialized: false,
    resolve: null,
    reject: null,
    monaco: null
  });
  var _state$create2 = _slicedToArray(_state$create, 2);
  var getState = _state$create2[0];
  var setState = _state$create2[1];
  function config2(globalConfig) {
    var _validators$config = validators_default.config(globalConfig), monaco = _validators$config.monaco, config32 = _objectWithoutProperties(_validators$config, ["monaco"]);
    setState(function(state2) {
      return {
        config: deepMerge_default(state2.config, config32),
        monaco
      };
    });
  }
  function init() {
    var state2 = getState(function(_ref) {
      var monaco = _ref.monaco, isInitialized = _ref.isInitialized, resolve = _ref.resolve;
      return {
        monaco,
        isInitialized,
        resolve
      };
    });
    if (!state2.isInitialized) {
      setState({
        isInitialized: true
      });
      if (state2.monaco) {
        state2.resolve(state2.monaco);
        return makeCancelable_default(wrapperPromise);
      }
      if (window.monaco && window.monaco.editor) {
        storeMonacoInstance(window.monaco);
        state2.resolve(window.monaco);
        return makeCancelable_default(wrapperPromise);
      }
      compose_default(injectScripts, getMonacoLoaderScript)(configureLoader);
    }
    return makeCancelable_default(wrapperPromise);
  }
  function injectScripts(script) {
    return document.body.appendChild(script);
  }
  function createScript(src) {
    var script = document.createElement("script");
    return src && (script.src = src), script;
  }
  function getMonacoLoaderScript(configureLoader22) {
    var state2 = getState(function(_ref2) {
      var config32 = _ref2.config, reject = _ref2.reject;
      return {
        config: config32,
        reject
      };
    });
    var loaderScript = createScript("".concat(state2.config.paths.vs, "/loader.js"));
    loaderScript.onload = function() {
      return configureLoader22();
    };
    loaderScript.onerror = state2.reject;
    return loaderScript;
  }
  function configureLoader() {
    var state2 = getState(function(_ref3) {
      var config32 = _ref3.config, resolve = _ref3.resolve, reject = _ref3.reject;
      return {
        config: config32,
        resolve,
        reject
      };
    });
    var require2 = window.require;
    require2.config(state2.config);
    require2(["vs/editor/editor.main"], function(monaco) {
      storeMonacoInstance(monaco);
      state2.resolve(monaco);
    }, function(error) {
      state2.reject(error);
    });
  }
  function storeMonacoInstance(monaco) {
    if (!getState().monaco) {
      setState({
        monaco
      });
    }
  }
  function __getMonacoInstance() {
    return getState(function(_ref4) {
      var monaco = _ref4.monaco;
      return monaco;
    });
  }
  var wrapperPromise = new Promise(function(resolve, reject) {
    return setState({
      resolve,
      reject
    });
  });
  var loader = {
    config: config2,
    init,
    __getMonacoInstance
  };
  var loader_default = loader;
  var colors = {
    background: "#282c34",
    default: "#c4cad6",
    lightRed: "#e06c75",
    blue: "#61afef",
    gray: "#8c92a3",
    green: "#98c379",
    purple: "#c678dd",
    red: "#be5046",
    teal: "#56b6c2",
    peach: "#d19a66"
  };
  var rules = (colors2) => [
    { token: "", foreground: colors2.default },
    { token: "variable", foreground: colors2.lightRed },
    { token: "constant", foreground: colors2.blue },
    { token: "constant.character.escape", foreground: colors2.blue },
    { token: "comment", foreground: colors2.gray },
    { token: "number", foreground: colors2.blue },
    { token: "regexp", foreground: colors2.lightRed },
    { token: "type", foreground: colors2.lightRed },
    { token: "string", foreground: colors2.green },
    { token: "keyword", foreground: colors2.purple },
    { token: "operator", foreground: colors2.peach },
    { token: "delimiter.bracket.embed", foreground: colors2.red },
    { token: "sigil", foreground: colors2.teal },
    { token: "function", foreground: colors2.blue },
    { token: "function.call", foreground: colors2.default },
    // Markdown specific
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "keyword.md", foreground: colors2.lightRed },
    { token: "keyword.table", foreground: colors2.lightRed },
    { token: "string.link.md", foreground: colors2.blue },
    { token: "variable.md", foreground: colors2.teal },
    { token: "string.md", foreground: colors2.default },
    { token: "variable.source.md", foreground: colors2.default },
    // XML specific
    { token: "tag", foreground: colors2.lightRed },
    { token: "metatag", foreground: colors2.lightRed },
    { token: "attribute.name", foreground: colors2.peach },
    { token: "attribute.value", foreground: colors2.green },
    // JSON specific
    { token: "string.key", foreground: colors2.lightRed },
    { token: "keyword.json", foreground: colors2.blue },
    // SQL specific
    { token: "operator.sql", foreground: colors2.purple }
  ];
  var theme = {
    base: "vs-dark",
    inherit: false,
    rules: rules(colors),
    colors: {
      "editor.background": colors.background,
      "editor.foreground": colors.default,
      "editorLineNumber.foreground": "#636d83",
      "editorCursor.foreground": "#636d83",
      "editor.selectionBackground": "#3e4451",
      "editor.findMatchHighlightBackground": "#528bff3d",
      "editorSuggestWidget.background": "#21252b",
      "editorSuggestWidget.border": "#181a1f",
      "editorSuggestWidget.selectedBackground": "#2c313a",
      "input.background": "#1b1d23",
      "input.border": "#181a1f",
      "editorBracketMatch.border": "#282c34",
      "editorBracketMatch.background": "#3e4451"
    }
  };
  var CodeEditor = class {
    constructor(el, path, value2, opts) {
      this.el = el;
      this.path = path;
      this.value = value2;
      this.opts = opts;
      this.standalone_code_editor = null;
      this._onMount = [];
    }
    isMounted() {
      return !!this.standalone_code_editor;
    }
    mount() {
      if (this.isMounted()) {
        throw new Error("The monaco editor is already mounted");
      }
      this._mountEditor();
    }
    onMount(callback) {
      this._onMount.push(callback);
    }
    dispose() {
      if (this.isMounted()) {
        const model = this.standalone_code_editor.getModel();
        if (model) {
          model.dispose();
        }
        this.standalone_code_editor.dispose();
      }
    }
    _mountEditor() {
      this.opts.value = this.value;
      loader_default.config({
        paths: { vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs" }
      });
      loader_default.init().then((monaco) => {
        monaco.editor.defineTheme("default", theme);
        let modelUri = monaco.Uri.parse(this.path);
        let language = this.opts.language;
        let model = monaco.editor.createModel(this.value, language, modelUri);
        this.opts.language = void 0;
        this.opts.model = model;
        this.standalone_code_editor = monaco.editor.create(this.el, this.opts);
        this._onMount.forEach((callback) => callback(monaco));
        this._setScreenDependantEditorOptions();
        this.standalone_code_editor.addAction({
          contextMenuGroupId: "word-wrapping",
          id: "enable-word-wrapping",
          label: "Enable word wrapping",
          precondition: "config.editor.wordWrap == off",
          keybindings: [monaco.KeyMod.Alt | monaco.KeyCode.KeyZ],
          run: (editor) => editor.updateOptions({ wordWrap: "on" })
        });
        this.standalone_code_editor.addAction({
          contextMenuGroupId: "word-wrapping",
          id: "disable-word-wrapping",
          label: "Disable word wrapping",
          precondition: "config.editor.wordWrap == on",
          keybindings: [monaco.KeyMod.Alt | monaco.KeyCode.KeyZ],
          run: (editor) => editor.updateOptions({ wordWrap: "off" })
        });
        const resizeObserver = new ResizeObserver((entries) => {
          entries.forEach(() => {
            if (this.el.offsetHeight > 0) {
              this._setScreenDependantEditorOptions();
              this.standalone_code_editor.layout();
            }
          });
        });
        resizeObserver.observe(this.el);
        this.standalone_code_editor.onDidContentSizeChange(() => {
          const contentHeight = this.standalone_code_editor.getContentHeight();
          this.el.style.height = `${contentHeight}px`;
        });
      });
    }
    _setScreenDependantEditorOptions() {
      if (window.screen.width < 768) {
        this.standalone_code_editor.updateOptions({
          folding: false,
          lineDecorationsWidth: 16,
          lineNumbersMinChars: Math.floor(
            Math.log10(this.standalone_code_editor.getModel().getLineCount())
          ) + 3
        });
      } else {
        this.standalone_code_editor.updateOptions({
          folding: true,
          lineDecorationsWidth: 10,
          lineNumbersMinChars: 5
        });
      }
    }
  };
  var code_editor_default = CodeEditor;
  var CodeEditorHook = {
    mounted() {
      const opts = JSON.parse(this.el.dataset.opts);
      this.codeEditor = new code_editor_default(
        this.el,
        this.el.dataset.path,
        this.el.dataset.value,
        opts
      );
      this.codeEditor.onMount((monaco) => {
        if (this.el.dataset.changeEvent && this.el.dataset.changeEvent !== "") {
          this.codeEditor.standalone_code_editor.onDidChangeModelContent(() => {
            if (this.el.dataset.target && this.el.dataset.target !== "") {
              this.pushEventTo(
                this.el.dataset.target,
                this.el.dataset.changeEvent,
                {
                  value: this.codeEditor.standalone_code_editor.getValue()
                }
              );
            } else {
              this.pushEvent(this.el.dataset.changeEvent, {
                value: this.codeEditor.standalone_code_editor.getValue()
              });
            }
          });
        }
        this.handleEvent(
          "lme:change_language:" + this.el.dataset.path,
          (data) => {
            const model = this.codeEditor.standalone_code_editor.getModel();
            if (model.getLanguageId() !== data.mimeTypeOrLanguageId) {
              monaco.editor.setModelLanguage(model, data.mimeTypeOrLanguageId);
            }
          }
        );
        this.handleEvent("lme:set_value:" + this.el.dataset.path, (data) => {
          this.codeEditor.standalone_code_editor.setValue(data.value);
        });
        this.el.querySelectorAll("textarea").forEach((textarea) => {
          textarea.setAttribute(
            "name",
            "live_monaco_editor[" + this.el.dataset.path + "]"
          );
        });
        this.el.removeAttribute("data-value");
        this.el.removeAttribute("data-opts");
        this.el.dispatchEvent(
          new CustomEvent("lme:editor_mounted", {
            detail: { hook: this, editor: this.codeEditor },
            bubbles: true
          })
        );
      });
      if (!this.codeEditor.isMounted()) {
        this.codeEditor.mount();
      }
    },
    destroyed() {
      if (this.codeEditor) {
        this.codeEditor.dispose();
      }
    }
  };

  // ../lib/beacon/live_admin/components/visual_editor/hooks/color_picker.js
  var ColorPicker = {
    mounted() {
      this.handleKeydown = (event2) => {
        if (event2.key === "Escape") {
          this.pushEventTo(this.el, "close_picker", {});
        }
      };
      document.addEventListener("keydown", this.handleKeydown);
      const input = this.el.querySelector("input[name]");
      if (input) {
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === "attributes" && mutation.attributeName === "data-value") {
              const newValue = input.getAttribute("data-value");
              input.value = newValue;
              input.dispatchEvent(new Event("change", { bubbles: true }));
            }
          });
        });
        observer.observe(input, {
          attributes: true,
          attributeFilter: ["data-value"]
        });
        this.observer = observer;
      }
    },
    destroyed() {
      document.removeEventListener("keydown", this.handleKeydown);
      if (this.observer) {
        this.observer.disconnect();
      }
    }
  };
  var color_picker_default = ColorPicker;

  // ../lib/beacon/live_admin/components/visual_editor/hooks.js
  var hooks_default = {
    ColorPicker: color_picker_default,
    VisualEditorClassInput: {
      mounted() {
        this.el.addEventListener("keydown", (event2) => {
          if (event2.key === "Enter") {
            event2.preventDefault();
            const target = "#" + this.el.dataset.target;
            this.pushEventTo(target, "add_class", { value: this.el.value }, () => {
              this.el.value = "";
            });
          }
        });
      }
    },
    // This hook is used to save the expanded state of a section
    // That way if a user collapses, for instance, the opacity section,
    // whenever the user reloads the page or chooses a different element that
    // section remains.
    // Persistence is done by saving the expanded state in localStorage.
    ControlSectionSaveExpandedState: {
      mounted() {
        const sectionId = this.el.dataset.sectionId;
        const expanded = localStorage.getItem(`section-${sectionId}-expanded`);
        if (expanded !== null) {
          this.pushEventTo(this.el, "set_expanded", { expanded: expanded === "true" });
        }
        this.handleEvent("expanded_changed", (data) => {
          if (data.sectionId === sectionId) {
            localStorage.setItem(`section-${sectionId}-expanded`, data.expanded);
          }
        });
      }
    },
    ToggleGroup: {
      mounted() {
        this.el.addEventListener("click", (e) => {
          if (e.target.tagName !== "LABEL") {
            return;
          }
          const input = e.target.querySelector("input");
          if (input?.checked) {
            e.preventDefault();
            e.stopPropagation();
            const defaultInput = this.el.querySelector('input[value="default"]');
            defaultInput.click();
          }
        });
      }
    },
    PreventEmptyChange: {
      mounted() {
        let currentValue = this.el.value;
        let isCleared = false;
        this.el.addEventListener("input", (e) => {
          if (e.target.value === "") {
            e.stopPropagation();
            isCleared = true;
          } else {
            currentValue = e.target.value;
            isCleared = false;
          }
        });
        this.el.addEventListener("change", (e) => {
          if (isCleared) {
            e.stopPropagation();
          }
        });
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === "attributes" && mutation.attributeName === "value") {
              currentValue = this.el.value;
            }
          });
        });
        observer.observe(this.el, { attributes: true });
        this.el.addEventListener("blur", (e) => {
          if (e.target.value === "") {
            e.target.value = currentValue;
            isCleared = false;
          }
        });
        this.destroy = () => observer.disconnect();
      }
    }
  };

  // node_modules/svelte/src/constants.js
  var EACH_ITEM_REACTIVE = 1;
  var EACH_INDEX_REACTIVE = 1 << 1;
  var EACH_IS_CONTROLLED = 1 << 2;
  var EACH_IS_ANIMATED = 1 << 3;
  var EACH_ITEM_IMMUTABLE = 1 << 4;
  var PROPS_IS_IMMUTABLE = 1;
  var PROPS_IS_RUNES = 1 << 1;
  var PROPS_IS_UPDATED = 1 << 2;
  var PROPS_IS_BINDABLE = 1 << 3;
  var PROPS_IS_LAZY_INITIAL = 1 << 4;
  var TRANSITION_IN = 1;
  var TRANSITION_OUT = 1 << 1;
  var TRANSITION_GLOBAL = 1 << 2;
  var TEMPLATE_FRAGMENT = 1;
  var TEMPLATE_USE_IMPORT_NODE = 1 << 1;
  var HYDRATION_START = "[";
  var HYDRATION_START_ELSE = "[!";
  var HYDRATION_END = "]";
  var HYDRATION_ERROR = {};
  var ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
  var UNINITIALIZED = Symbol();
  var FILENAME = Symbol("filename");
  var HMR = Symbol("hmr");
  var NAMESPACE_HTML = "http://www.w3.org/1999/xhtml";
  var NAMESPACE_SVG = "http://www.w3.org/2000/svg";

  // node_modules/clsx/dist/clsx.mjs
  function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for (f in e) e[f] && (n && (n += " "), n += f);
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
  }

  // node_modules/svelte/src/internal/shared/attributes.js
  function clsx2(value2) {
    if (typeof value2 === "object") {
      return clsx(value2);
    } else {
      return value2 ?? "";
    }
  }
  var whitespace = [..." 	\n\r\f\xA0\v\uFEFF"];
  function to_class(value2, hash2, directives) {
    var classname = value2 == null ? "" : "" + value2;
    if (hash2) {
      classname = classname ? classname + " " + hash2 : hash2;
    }
    if (directives) {
      for (var key in directives) {
        if (directives[key]) {
          classname = classname ? classname + " " + key : key;
        } else if (classname.length) {
          var len = key.length;
          var a = 0;
          while ((a = classname.indexOf(key, a)) >= 0) {
            var b = a + len;
            if ((a === 0 || whitespace.includes(classname[a - 1])) && (b === classname.length || whitespace.includes(classname[b]))) {
              classname = (a === 0 ? "" : classname.substring(0, a)) + classname.substring(b + 1);
            } else {
              a = b;
            }
          }
        }
      }
    }
    return classname === "" ? null : classname;
  }
  function append_styles(styles, important = false) {
    var separator = important ? " !important;" : ";";
    var css = "";
    for (var key in styles) {
      var value2 = styles[key];
      if (value2 != null && value2 !== "") {
        css += " " + key + ": " + value2 + separator;
      }
    }
    return css;
  }
  function to_css_name(name) {
    if (name[0] !== "-" || name[1] !== "-") {
      return name.toLowerCase();
    }
    return name;
  }
  function to_style(value2, styles) {
    if (styles) {
      var new_style = "";
      var normal_styles;
      var important_styles;
      if (Array.isArray(styles)) {
        normal_styles = styles[0];
        important_styles = styles[1];
      } else {
        normal_styles = styles;
      }
      if (value2) {
        value2 = String(value2).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
        var in_str = false;
        var in_apo = 0;
        var in_comment = false;
        var reserved_names = [];
        if (normal_styles) {
          reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
        }
        if (important_styles) {
          reserved_names.push(...Object.keys(important_styles).map(to_css_name));
        }
        var start_index = 0;
        var name_index = -1;
        const len = value2.length;
        for (var i = 0; i < len; i++) {
          var c = value2[i];
          if (in_comment) {
            if (c === "/" && value2[i - 1] === "*") {
              in_comment = false;
            }
          } else if (in_str) {
            if (in_str === c) {
              in_str = false;
            }
          } else if (c === "/" && value2[i + 1] === "*") {
            in_comment = true;
          } else if (c === '"' || c === "'") {
            in_str = c;
          } else if (c === "(") {
            in_apo++;
          } else if (c === ")") {
            in_apo--;
          }
          if (!in_comment && in_str === false && in_apo === 0) {
            if (c === ":" && name_index === -1) {
              name_index = i;
            } else if (c === ";" || i === len - 1) {
              if (name_index !== -1) {
                var name = to_css_name(value2.substring(start_index, name_index).trim());
                if (!reserved_names.includes(name)) {
                  if (c !== ";") {
                    i++;
                  }
                  var property = value2.substring(start_index, i).trim();
                  new_style += " " + property + ";";
                }
              }
              start_index = i + 1;
              name_index = -1;
            }
          }
        }
      }
      if (normal_styles) {
        new_style += append_styles(normal_styles);
      }
      if (important_styles) {
        new_style += append_styles(important_styles, true);
      }
      new_style = new_style.trim();
      return new_style === "" ? null : new_style;
    }
    return value2 == null ? null : String(value2);
  }

  // node_modules/svelte/src/internal/shared/utils.js
  var is_array = Array.isArray;
  var index_of = Array.prototype.indexOf;
  var array_from = Array.from;
  var object_keys = Object.keys;
  var define_property = Object.defineProperty;
  var get_descriptor = Object.getOwnPropertyDescriptor;
  var get_descriptors = Object.getOwnPropertyDescriptors;
  var object_prototype = Object.prototype;
  var array_prototype = Array.prototype;
  var get_prototype_of = Object.getPrototypeOf;
  var is_extensible = Object.isExtensible;
  function is_function(thing) {
    return typeof thing === "function";
  }
  var noop = () => {
  };
  function run(fn) {
    return fn();
  }
  function run_all(arr) {
    for (var i = 0; i < arr.length; i++) {
      arr[i]();
    }
  }

  // node_modules/esm-env/true.js
  var true_default = true;

  // node_modules/svelte/src/internal/client/constants.js
  var DERIVED = 1 << 1;
  var EFFECT = 1 << 2;
  var RENDER_EFFECT = 1 << 3;
  var BLOCK_EFFECT = 1 << 4;
  var BRANCH_EFFECT = 1 << 5;
  var ROOT_EFFECT = 1 << 6;
  var BOUNDARY_EFFECT = 1 << 7;
  var UNOWNED = 1 << 8;
  var DISCONNECTED = 1 << 9;
  var CLEAN = 1 << 10;
  var DIRTY = 1 << 11;
  var MAYBE_DIRTY = 1 << 12;
  var INERT = 1 << 13;
  var DESTROYED = 1 << 14;
  var EFFECT_RAN = 1 << 15;
  var EFFECT_TRANSPARENT = 1 << 16;
  var LEGACY_DERIVED_PROP = 1 << 17;
  var INSPECT_EFFECT = 1 << 18;
  var HEAD_EFFECT = 1 << 19;
  var EFFECT_HAS_DERIVED = 1 << 20;
  var EFFECT_IS_UPDATING = 1 << 21;
  var STATE_SYMBOL = Symbol("$state");
  var STATE_SYMBOL_METADATA = Symbol("$state metadata");
  var LEGACY_PROPS = Symbol("legacy props");
  var LOADING_ATTR_SYMBOL = Symbol("");

  // node_modules/svelte/src/internal/client/reactivity/equality.js
  function equals(value2) {
    return value2 === this.v;
  }
  function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || a !== null && typeof a === "object" || typeof a === "function";
  }
  function safe_equals(value2) {
    return !safe_not_equal(value2, this.v);
  }

  // node_modules/svelte/src/internal/client/errors.js
  function component_api_changed(parent, method, component2) {
    if (true_default) {
      const error = new Error(`component_api_changed
${parent} called \`${method}\` on an instance of ${component2}, which is no longer valid in Svelte 5
https://svelte.dev/e/component_api_changed`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/component_api_changed`);
    }
  }
  function component_api_invalid_new(component2, name) {
    if (true_default) {
      const error = new Error(`component_api_invalid_new
Attempted to instantiate ${component2} with \`new ${name}\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \`compatibility.componentApi\` compiler option to \`4\` to keep it working.
https://svelte.dev/e/component_api_invalid_new`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/component_api_invalid_new`);
    }
  }
  function derived_references_self() {
    if (true_default) {
      const error = new Error(`derived_references_self
A derived value cannot reference itself recursively
https://svelte.dev/e/derived_references_self`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/derived_references_self`);
    }
  }
  function effect_in_teardown(rune) {
    if (true_default) {
      const error = new Error(`effect_in_teardown
\`${rune}\` cannot be used inside an effect cleanup function
https://svelte.dev/e/effect_in_teardown`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/effect_in_teardown`);
    }
  }
  function effect_in_unowned_derived() {
    if (true_default) {
      const error = new Error(`effect_in_unowned_derived
Effect cannot be created inside a \`$derived\` value that was not itself created inside an effect
https://svelte.dev/e/effect_in_unowned_derived`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
    }
  }
  function effect_orphan(rune) {
    if (true_default) {
      const error = new Error(`effect_orphan
\`${rune}\` can only be used inside an effect (e.g. during component initialisation)
https://svelte.dev/e/effect_orphan`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/effect_orphan`);
    }
  }
  function effect_update_depth_exceeded() {
    if (true_default) {
      const error = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops
https://svelte.dev/e/effect_update_depth_exceeded`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
    }
  }
  function hydration_failed() {
    if (true_default) {
      const error = new Error(`hydration_failed
Failed to hydrate the application
https://svelte.dev/e/hydration_failed`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/hydration_failed`);
    }
  }
  function props_invalid_value(key) {
    if (true_default) {
      const error = new Error(`props_invalid_value
Cannot do \`bind:${key}={undefined}\` when \`${key}\` has a fallback value
https://svelte.dev/e/props_invalid_value`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/props_invalid_value`);
    }
  }
  function rune_outside_svelte(rune) {
    if (true_default) {
      const error = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files
https://svelte.dev/e/rune_outside_svelte`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
    }
  }
  function state_descriptors_fixed() {
    if (true_default) {
      const error = new Error(`state_descriptors_fixed
Property descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.
https://svelte.dev/e/state_descriptors_fixed`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
    }
  }
  function state_prototype_fixed() {
    if (true_default) {
      const error = new Error(`state_prototype_fixed
Cannot set prototype of \`$state\` object
https://svelte.dev/e/state_prototype_fixed`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
    }
  }
  function state_unsafe_mutation() {
    if (true_default) {
      const error = new Error(`state_unsafe_mutation
Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`
https://svelte.dev/e/state_unsafe_mutation`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
    }
  }

  // node_modules/svelte/src/internal/flags/index.js
  var legacy_mode_flag = false;
  var tracing_mode_flag = false;
  function enable_legacy_mode_flag() {
    legacy_mode_flag = true;
  }

  // node_modules/svelte/src/internal/shared/warnings.js
  var bold = "font-weight: bold";
  var normal = "font-weight: normal";
  function dynamic_void_element_content(tag) {
    if (true_default) {
      console.warn(`%c[svelte] dynamic_void_element_content
%c\`<svelte:element this="${tag}">\` is a void element \u2014 it cannot have content
https://svelte.dev/e/dynamic_void_element_content`, bold, normal);
    } else {
      console.warn(`https://svelte.dev/e/dynamic_void_element_content`);
    }
  }

  // node_modules/svelte/src/internal/client/dev/tracing.js
  var tracing_expressions = null;
  function get_stack(label) {
    let error = Error();
    const stack2 = error.stack;
    if (stack2) {
      const lines = stack2.split("\n");
      const new_lines = ["\n"];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line === "Error") {
          continue;
        }
        if (line.includes("validate_each_keys")) {
          return null;
        }
        if (line.includes("svelte/src/internal")) {
          continue;
        }
        new_lines.push(line);
      }
      if (new_lines.length === 1) {
        return null;
      }
      define_property(error, "stack", {
        value: new_lines.join("\n")
      });
      define_property(error, "name", {
        // 'Error' suffix is required for stack traces to be rendered properly
        value: `${label}Error`
      });
    }
    return error;
  }

  // node_modules/svelte/src/internal/client/warnings.js
  var bold2 = "font-weight: bold";
  var normal2 = "font-weight: normal";
  function assignment_value_stale(property, location) {
    if (true_default) {
      console.warn(`%c[svelte] assignment_value_stale
%cAssignment to \`${property}\` property (${location}) will evaluate to the right-hand side, not the value of \`${property}\` following the assignment. This may result in unexpected behaviour.
https://svelte.dev/e/assignment_value_stale`, bold2, normal2);
    } else {
      console.warn(`https://svelte.dev/e/assignment_value_stale`);
    }
  }
  function event_handler_invalid(handler, suggestion) {
    if (true_default) {
      console.warn(`%c[svelte] event_handler_invalid
%c${handler} should be a function. Did you mean to ${suggestion}?
https://svelte.dev/e/event_handler_invalid`, bold2, normal2);
    } else {
      console.warn(`https://svelte.dev/e/event_handler_invalid`);
    }
  }
  function hydration_attribute_changed(attribute, html3, value2) {
    if (true_default) {
      console.warn(`%c[svelte] hydration_attribute_changed
%cThe \`${attribute}\` attribute on \`${html3}\` changed its value between server and client renders. The client value, \`${value2}\`, will be ignored in favour of the server value
https://svelte.dev/e/hydration_attribute_changed`, bold2, normal2);
    } else {
      console.warn(`https://svelte.dev/e/hydration_attribute_changed`);
    }
  }
  function hydration_html_changed(location) {
    if (true_default) {
      console.warn(`%c[svelte] hydration_html_changed
%c${location ? `The value of an \`{@html ...}\` block ${location} changed between server and client renders. The client value will be ignored in favour of the server value` : "The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value"}
https://svelte.dev/e/hydration_html_changed`, bold2, normal2);
    } else {
      console.warn(`https://svelte.dev/e/hydration_html_changed`);
    }
  }
  function hydration_mismatch(location) {
    if (true_default) {
      console.warn(`%c[svelte] hydration_mismatch
%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : "Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`, bold2, normal2);
    } else {
      console.warn(`https://svelte.dev/e/hydration_mismatch`);
    }
  }
  function invalid_raw_snippet_render() {
    if (true_default) {
      console.warn(`%c[svelte] invalid_raw_snippet_render
%cThe \`render\` function passed to \`createRawSnippet\` should return HTML for a single element
https://svelte.dev/e/invalid_raw_snippet_render`, bold2, normal2);
    } else {
      console.warn(`https://svelte.dev/e/invalid_raw_snippet_render`);
    }
  }
  function lifecycle_double_unmount() {
    if (true_default) {
      console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`, bold2, normal2);
    } else {
      console.warn(`https://svelte.dev/e/lifecycle_double_unmount`);
    }
  }
  function ownership_invalid_mutation(component2, owner) {
    if (true_default) {
      console.warn(`%c[svelte] ownership_invalid_mutation
%c${component2 ? `${component2} mutated a value owned by ${owner}. This is strongly discouraged. Consider passing values to child components with \`bind:\`, or use a callback instead` : "Mutating a value outside the component that created it is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead"}
https://svelte.dev/e/ownership_invalid_mutation`, bold2, normal2);
    } else {
      console.warn(`https://svelte.dev/e/ownership_invalid_mutation`);
    }
  }
  function state_proxy_equality_mismatch(operator) {
    if (true_default) {
      console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`, bold2, normal2);
    } else {
      console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
    }
  }

  // node_modules/svelte/src/internal/client/dev/ownership.js
  var boundaries = {};
  var chrome_pattern = /at (?:.+ \()?(.+):(\d+):(\d+)\)?$/;
  var firefox_pattern = /@(.+):(\d+):(\d+)$/;
  function get_stack2() {
    const stack2 = new Error().stack;
    if (!stack2) return null;
    const entries = [];
    for (const line of stack2.split("\n")) {
      let match = chrome_pattern.exec(line) ?? firefox_pattern.exec(line);
      if (match) {
        entries.push({
          file: match[1],
          line: +match[2],
          column: +match[3]
        });
      }
    }
    return entries;
  }
  function get_component() {
    const stack2 = get_stack2()?.slice(4);
    if (!stack2) return null;
    for (let i = 0; i < stack2.length; i++) {
      const entry = stack2[i];
      const modules2 = boundaries[entry.file];
      if (!modules2) {
        if (i === 0) return null;
        continue;
      }
      for (const module of modules2) {
        if (module.end == null) {
          return null;
        }
        if (module.start.line < entry.line && module.end.line > entry.line) {
          return module.component;
        }
      }
    }
    return null;
  }
  var ADD_OWNER = Symbol("ADD_OWNER");
  function mark_module_start() {
    var _a2;
    const start = get_stack2()?.[2];
    if (start) {
      (boundaries[_a2 = start.file] ?? (boundaries[_a2] = [])).push({
        start,
        // @ts-expect-error
        end: null,
        // @ts-expect-error we add the component at the end, since HMR will overwrite the function
        component: null
      });
    }
  }
  function mark_module_end(component2) {
    const end = get_stack2()?.[2];
    if (end) {
      const boundaries_file = boundaries[end.file];
      const boundary2 = boundaries_file[boundaries_file.length - 1];
      boundary2.end = end;
      boundary2.component = component2;
    }
  }
  function widen_ownership(from, to) {
    if (to.owners === null) {
      return;
    }
    while (from) {
      if (from.owners === null) {
        to.owners = null;
        break;
      }
      for (const owner of from.owners) {
        to.owners.add(owner);
      }
      from = from.parent;
    }
  }
  function has_owner(metadata, component2) {
    if (metadata.owners === null) {
      return true;
    }
    return metadata.owners.has(component2) || // This helps avoid false positives when using HMR, where the component function is replaced
    FILENAME in component2 && [...metadata.owners].some(
      (owner) => (
        /** @type {any} */
        owner[FILENAME] === component2[FILENAME]
      )
    ) || metadata.parent !== null && has_owner(metadata.parent, component2);
  }
  function get_owner(metadata) {
    return metadata?.owners?.values().next().value ?? get_owner(
      /** @type {ProxyMetadata} */
      metadata.parent
    );
  }
  var skip = false;
  function check_ownership(metadata) {
    if (skip) return;
    const component2 = get_component();
    if (component2 && !has_owner(metadata, component2)) {
      let original = get_owner(metadata);
      if (original[FILENAME] !== component2[FILENAME]) {
        ownership_invalid_mutation(component2[FILENAME], original[FILENAME]);
      } else {
        ownership_invalid_mutation();
      }
    }
  }

  // node_modules/svelte/src/internal/shared/errors.js
  function lifecycle_outside_component(name) {
    if (true_default) {
      const error = new Error(`lifecycle_outside_component
\`${name}(...)\` can only be used during component initialisation
https://svelte.dev/e/lifecycle_outside_component`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
    }
  }
  function store_invalid_shape(name) {
    if (true_default) {
      const error = new Error(`store_invalid_shape
\`${name}\` is not a store with a \`subscribe\` method
https://svelte.dev/e/store_invalid_shape`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/store_invalid_shape`);
    }
  }
  function svelte_element_invalid_this_value() {
    if (true_default) {
      const error = new Error(`svelte_element_invalid_this_value
The \`this\` prop on \`<svelte:element>\` must be a string, if defined
https://svelte.dev/e/svelte_element_invalid_this_value`);
      error.name = "Svelte error";
      throw error;
    } else {
      throw new Error(`https://svelte.dev/e/svelte_element_invalid_this_value`);
    }
  }

  // node_modules/svelte/src/internal/client/context.js
  var component_context = null;
  function set_component_context(context) {
    component_context = context;
  }
  var dev_current_component_function = null;
  function set_dev_current_component_function(fn) {
    dev_current_component_function = fn;
  }
  function push(props, runes = false, fn) {
    var ctx = component_context = {
      p: component_context,
      c: null,
      d: false,
      e: null,
      m: false,
      s: props,
      x: null,
      l: null
    };
    if (legacy_mode_flag && !runes) {
      component_context.l = {
        s: null,
        u: null,
        r1: [],
        r2: source(false)
      };
    }
    teardown(() => {
      ctx.d = true;
    });
    if (true_default) {
      component_context.function = fn;
      dev_current_component_function = fn;
    }
  }
  function pop(component2) {
    const context_stack_item = component_context;
    if (context_stack_item !== null) {
      if (component2 !== void 0) {
        context_stack_item.x = component2;
      }
      const component_effects = context_stack_item.e;
      if (component_effects !== null) {
        var previous_effect = active_effect;
        var previous_reaction = active_reaction;
        context_stack_item.e = null;
        try {
          for (var i = 0; i < component_effects.length; i++) {
            var component_effect = component_effects[i];
            set_active_effect(component_effect.effect);
            set_active_reaction(component_effect.reaction);
            effect(component_effect.fn);
          }
        } finally {
          set_active_effect(previous_effect);
          set_active_reaction(previous_reaction);
        }
      }
      component_context = context_stack_item.p;
      if (true_default) {
        dev_current_component_function = context_stack_item.p?.function ?? null;
      }
      context_stack_item.m = true;
    }
    return component2 || /** @type {T} */
    {};
  }
  function is_runes() {
    return !legacy_mode_flag || component_context !== null && component_context.l === null;
  }

  // node_modules/svelte/src/internal/client/proxy.js
  var parent_metadata = null;
  function proxy(value2, prev) {
    if (typeof value2 !== "object" || value2 === null || STATE_SYMBOL in value2) {
      return value2;
    }
    const prototype = get_prototype_of(value2);
    if (prototype !== object_prototype && prototype !== array_prototype) {
      return value2;
    }
    var sources = /* @__PURE__ */ new Map();
    var is_proxied_array = is_array(value2);
    var version2 = state(0);
    var stack2 = true_default && tracing_mode_flag ? get_stack("CreatedAt") : null;
    var reaction = active_reaction;
    var with_parent = (fn) => {
      var previous_reaction = active_reaction;
      set_active_reaction(reaction);
      var result;
      if (true_default) {
        var previous_metadata = parent_metadata;
        parent_metadata = metadata;
        result = fn();
        parent_metadata = previous_metadata;
      } else {
        result = fn();
      }
      set_active_reaction(previous_reaction);
      return result;
    };
    if (is_proxied_array) {
      sources.set("length", state(
        /** @type {any[]} */
        value2.length,
        stack2
      ));
    }
    var metadata;
    if (true_default) {
      metadata = {
        parent: parent_metadata,
        owners: null
      };
      if (prev) {
        const prev_owners = prev.v?.[STATE_SYMBOL_METADATA]?.owners;
        metadata.owners = prev_owners ? new Set(prev_owners) : null;
      } else {
        metadata.owners = parent_metadata === null ? component_context !== null ? /* @__PURE__ */ new Set([component_context.function]) : null : /* @__PURE__ */ new Set();
      }
    }
    return new Proxy(
      /** @type {any} */
      value2,
      {
        defineProperty(_, prop2, descriptor) {
          if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
            state_descriptors_fixed();
          }
          var s = sources.get(prop2);
          if (s === void 0) {
            s = with_parent(() => state(descriptor.value, stack2));
            sources.set(prop2, s);
          } else {
            set(
              s,
              with_parent(() => proxy(descriptor.value))
            );
          }
          return true;
        },
        deleteProperty(target, prop2) {
          var s = sources.get(prop2);
          if (s === void 0) {
            if (prop2 in target) {
              sources.set(
                prop2,
                with_parent(() => state(UNINITIALIZED, stack2))
              );
            }
          } else {
            if (is_proxied_array && typeof prop2 === "string") {
              var ls = (
                /** @type {Source<number>} */
                sources.get("length")
              );
              var n = Number(prop2);
              if (Number.isInteger(n) && n < ls.v) {
                set(ls, n);
              }
            }
            set(s, UNINITIALIZED);
            update_version(version2);
          }
          return true;
        },
        get(target, prop2, receiver) {
          if (true_default && prop2 === STATE_SYMBOL_METADATA) {
            return metadata;
          }
          if (prop2 === STATE_SYMBOL) {
            return value2;
          }
          var s = sources.get(prop2);
          var exists = prop2 in target;
          if (s === void 0 && (!exists || get_descriptor(target, prop2)?.writable)) {
            s = with_parent(() => state(proxy(exists ? target[prop2] : UNINITIALIZED), stack2));
            sources.set(prop2, s);
          }
          if (s !== void 0) {
            var v = get(s);
            if (true_default) {
              var prop_metadata = v?.[STATE_SYMBOL_METADATA];
              if (prop_metadata && prop_metadata?.parent !== metadata) {
                widen_ownership(metadata, prop_metadata);
              }
            }
            return v === UNINITIALIZED ? void 0 : v;
          }
          return Reflect.get(target, prop2, receiver);
        },
        getOwnPropertyDescriptor(target, prop2) {
          var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
          if (descriptor && "value" in descriptor) {
            var s = sources.get(prop2);
            if (s) descriptor.value = get(s);
          } else if (descriptor === void 0) {
            var source2 = sources.get(prop2);
            var value3 = source2?.v;
            if (source2 !== void 0 && value3 !== UNINITIALIZED) {
              return {
                enumerable: true,
                configurable: true,
                value: value3,
                writable: true
              };
            }
          }
          return descriptor;
        },
        has(target, prop2) {
          if (true_default && prop2 === STATE_SYMBOL_METADATA) {
            return true;
          }
          if (prop2 === STATE_SYMBOL) {
            return true;
          }
          var s = sources.get(prop2);
          var has = s !== void 0 && s.v !== UNINITIALIZED || Reflect.has(target, prop2);
          if (s !== void 0 || active_effect !== null && (!has || get_descriptor(target, prop2)?.writable)) {
            if (s === void 0) {
              s = with_parent(() => state(has ? proxy(target[prop2]) : UNINITIALIZED, stack2));
              sources.set(prop2, s);
            }
            var value3 = get(s);
            if (value3 === UNINITIALIZED) {
              return false;
            }
          }
          return has;
        },
        set(target, prop2, value3, receiver) {
          var s = sources.get(prop2);
          var has = prop2 in target;
          if (is_proxied_array && prop2 === "length") {
            for (var i = value3; i < /** @type {Source<number>} */
            s.v; i += 1) {
              var other_s = sources.get(i + "");
              if (other_s !== void 0) {
                set(other_s, UNINITIALIZED);
              } else if (i in target) {
                other_s = with_parent(() => state(UNINITIALIZED, stack2));
                sources.set(i + "", other_s);
              }
            }
          }
          if (s === void 0) {
            if (!has || get_descriptor(target, prop2)?.writable) {
              s = with_parent(() => state(void 0, stack2));
              set(
                s,
                with_parent(() => proxy(value3))
              );
              sources.set(prop2, s);
            }
          } else {
            has = s.v !== UNINITIALIZED;
            set(
              s,
              with_parent(() => proxy(value3))
            );
          }
          if (true_default) {
            var prop_metadata = value3?.[STATE_SYMBOL_METADATA];
            if (prop_metadata && prop_metadata?.parent !== metadata) {
              widen_ownership(metadata, prop_metadata);
            }
            check_ownership(metadata);
          }
          var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
          if (descriptor?.set) {
            descriptor.set.call(receiver, value3);
          }
          if (!has) {
            if (is_proxied_array && typeof prop2 === "string") {
              var ls = (
                /** @type {Source<number>} */
                sources.get("length")
              );
              var n = Number(prop2);
              if (Number.isInteger(n) && n >= ls.v) {
                set(ls, n + 1);
              }
            }
            update_version(version2);
          }
          return true;
        },
        ownKeys(target) {
          get(version2);
          var own_keys = Reflect.ownKeys(target).filter((key2) => {
            var source3 = sources.get(key2);
            return source3 === void 0 || source3.v !== UNINITIALIZED;
          });
          for (var [key, source2] of sources) {
            if (source2.v !== UNINITIALIZED && !(key in target)) {
              own_keys.push(key);
            }
          }
          return own_keys;
        },
        setPrototypeOf() {
          state_prototype_fixed();
        }
      }
    );
  }
  function update_version(signal, d = 1) {
    set(signal, signal.v + d);
  }
  function get_proxied_value(value2) {
    try {
      if (value2 !== null && typeof value2 === "object" && STATE_SYMBOL in value2) {
        return value2[STATE_SYMBOL];
      }
    } catch {
    }
    return value2;
  }

  // node_modules/svelte/src/internal/client/reactivity/sources.js
  var inspect_effects = /* @__PURE__ */ new Set();
  var old_values = /* @__PURE__ */ new Map();
  function set_inspect_effects(v) {
    inspect_effects = v;
  }
  function source(v, stack2) {
    var signal = {
      f: 0,
      // TODO ideally we could skip this altogether, but it causes type errors
      v,
      reactions: null,
      equals,
      rv: 0,
      wv: 0
    };
    if (true_default && tracing_mode_flag) {
      signal.created = stack2 ?? get_stack("CreatedAt");
      signal.debug = null;
    }
    return signal;
  }
  function state(v, stack2) {
    const s = source(v, stack2);
    push_reaction_value(s);
    return s;
  }
  // @__NO_SIDE_EFFECTS__
  function mutable_source(initial_value, immutable = false) {
    var _a2;
    const s = source(initial_value);
    if (!immutable) {
      s.equals = safe_equals;
    }
    if (legacy_mode_flag && component_context !== null && component_context.l !== null) {
      ((_a2 = component_context.l).s ?? (_a2.s = [])).push(s);
    }
    return s;
  }
  function mutate(source2, value2) {
    set(
      source2,
      untrack(() => get(source2))
    );
    return value2;
  }
  function set(source2, value2, should_proxy = false) {
    if (active_reaction !== null && !untracking && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 && !reaction_sources?.includes(source2)) {
      state_unsafe_mutation();
    }
    let new_value = should_proxy ? proxy(value2, source2) : value2;
    return internal_set(source2, new_value);
  }
  function internal_set(source2, value2) {
    if (!source2.equals(value2)) {
      var old_value = source2.v;
      if (is_destroying_effect) {
        old_values.set(source2, value2);
      } else {
        old_values.set(source2, old_value);
      }
      source2.v = value2;
      source2.wv = increment_write_version();
      if (true_default && tracing_mode_flag) {
        source2.updated = get_stack("UpdatedAt");
        if (active_effect != null) {
          source2.trace_need_increase = true;
          source2.trace_v ?? (source2.trace_v = old_value);
        }
      }
      mark_reactions(source2, DIRTY);
      if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
        if (untracked_writes === null) {
          set_untracked_writes([source2]);
        } else {
          untracked_writes.push(source2);
        }
      }
      if (true_default && inspect_effects.size > 0) {
        const inspects = Array.from(inspect_effects);
        for (const effect2 of inspects) {
          if ((effect2.f & CLEAN) !== 0) {
            set_signal_status(effect2, MAYBE_DIRTY);
          }
          if (check_dirtiness(effect2)) {
            update_effect(effect2);
          }
        }
        inspect_effects.clear();
      }
    }
    return value2;
  }
  function mark_reactions(signal, status) {
    var reactions = signal.reactions;
    if (reactions === null) return;
    var runes = is_runes();
    var length2 = reactions.length;
    for (var i = 0; i < length2; i++) {
      var reaction = reactions[i];
      var flags = reaction.f;
      if ((flags & DIRTY) !== 0) continue;
      if (!runes && reaction === active_effect) continue;
      if (true_default && (flags & INSPECT_EFFECT) !== 0) {
        inspect_effects.add(reaction);
        continue;
      }
      set_signal_status(reaction, status);
      if ((flags & (CLEAN | UNOWNED)) !== 0) {
        if ((flags & DERIVED) !== 0) {
          mark_reactions(
            /** @type {Derived} */
            reaction,
            MAYBE_DIRTY
          );
        } else {
          schedule_effect(
            /** @type {Effect} */
            reaction
          );
        }
      }
    }
  }

  // node_modules/svelte/src/internal/client/dom/hydration.js
  var hydrating = false;
  function set_hydrating(value2) {
    hydrating = value2;
  }
  var hydrate_node;
  function set_hydrate_node(node) {
    if (node === null) {
      hydration_mismatch();
      throw HYDRATION_ERROR;
    }
    return hydrate_node = node;
  }
  function hydrate_next() {
    return set_hydrate_node(
      /** @type {TemplateNode} */
      get_next_sibling(hydrate_node)
    );
  }
  function reset(node) {
    if (!hydrating) return;
    if (get_next_sibling(hydrate_node) !== null) {
      hydration_mismatch();
      throw HYDRATION_ERROR;
    }
    hydrate_node = node;
  }
  function next(count = 1) {
    if (hydrating) {
      var i = count;
      var node = hydrate_node;
      while (i--) {
        node = /** @type {TemplateNode} */
        get_next_sibling(node);
      }
      hydrate_node = node;
    }
  }
  function remove_nodes() {
    var depth = 0;
    var node = hydrate_node;
    while (true) {
      if (node.nodeType === 8) {
        var data = (
          /** @type {Comment} */
          node.data
        );
        if (data === HYDRATION_END) {
          if (depth === 0) return node;
          depth -= 1;
        } else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
          depth += 1;
        }
      }
      var next2 = (
        /** @type {TemplateNode} */
        get_next_sibling(node)
      );
      node.remove();
      node = next2;
    }
  }

  // node_modules/svelte/src/internal/client/dev/equality.js
  function init_array_prototype_warnings() {
    const array_prototype2 = Array.prototype;
    const cleanup = Array.__svelte_cleanup;
    if (cleanup) {
      cleanup();
    }
    const { indexOf, lastIndexOf, includes } = array_prototype2;
    array_prototype2.indexOf = function(item, from_index) {
      const index5 = indexOf.call(this, item, from_index);
      if (index5 === -1) {
        for (let i = from_index ?? 0; i < this.length; i += 1) {
          if (get_proxied_value(this[i]) === item) {
            state_proxy_equality_mismatch("array.indexOf(...)");
            break;
          }
        }
      }
      return index5;
    };
    array_prototype2.lastIndexOf = function(item, from_index) {
      const index5 = lastIndexOf.call(this, item, from_index ?? this.length - 1);
      if (index5 === -1) {
        for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
          if (get_proxied_value(this[i]) === item) {
            state_proxy_equality_mismatch("array.lastIndexOf(...)");
            break;
          }
        }
      }
      return index5;
    };
    array_prototype2.includes = function(item, from_index) {
      const has = includes.call(this, item, from_index);
      if (!has) {
        for (let i = 0; i < this.length; i += 1) {
          if (get_proxied_value(this[i]) === item) {
            state_proxy_equality_mismatch("array.includes(...)");
            break;
          }
        }
      }
      return has;
    };
    Array.__svelte_cleanup = () => {
      array_prototype2.indexOf = indexOf;
      array_prototype2.lastIndexOf = lastIndexOf;
      array_prototype2.includes = includes;
    };
  }
  function strict_equals(a, b, equal = true) {
    try {
      if (a === b !== (get_proxied_value(a) === get_proxied_value(b))) {
        state_proxy_equality_mismatch(equal ? "===" : "!==");
      }
    } catch {
    }
    return a === b === equal;
  }

  // node_modules/svelte/src/internal/client/dom/operations.js
  var $window;
  var $document;
  var is_firefox;
  var first_child_getter;
  var next_sibling_getter;
  function init_operations() {
    if ($window !== void 0) {
      return;
    }
    $window = window;
    $document = document;
    is_firefox = /Firefox/.test(navigator.userAgent);
    var element_prototype = Element.prototype;
    var node_prototype = Node.prototype;
    var text_prototype = Text.prototype;
    first_child_getter = get_descriptor(node_prototype, "firstChild").get;
    next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
    if (is_extensible(element_prototype)) {
      element_prototype.__click = void 0;
      element_prototype.__className = void 0;
      element_prototype.__attributes = null;
      element_prototype.__style = void 0;
      element_prototype.__e = void 0;
    }
    if (is_extensible(text_prototype)) {
      text_prototype.__t = void 0;
    }
    if (true_default) {
      element_prototype.__svelte_meta = null;
      init_array_prototype_warnings();
    }
  }
  function create_text(value2 = "") {
    return document.createTextNode(value2);
  }
  // @__NO_SIDE_EFFECTS__
  function get_first_child(node) {
    return first_child_getter.call(node);
  }
  // @__NO_SIDE_EFFECTS__
  function get_next_sibling(node) {
    return next_sibling_getter.call(node);
  }
  function child(node, is_text) {
    if (!hydrating) {
      return /* @__PURE__ */ get_first_child(node);
    }
    var child2 = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_first_child(hydrate_node)
    );
    if (child2 === null) {
      child2 = hydrate_node.appendChild(create_text());
    } else if (is_text && child2.nodeType !== 3) {
      var text2 = create_text();
      child2?.before(text2);
      set_hydrate_node(text2);
      return text2;
    }
    set_hydrate_node(child2);
    return child2;
  }
  function first_child(fragment, is_text) {
    if (!hydrating) {
      var first = (
        /** @type {DocumentFragment} */
        /* @__PURE__ */ get_first_child(
          /** @type {Node} */
          fragment
        )
      );
      if (first instanceof Comment && first.data === "") return /* @__PURE__ */ get_next_sibling(first);
      return first;
    }
    if (is_text && hydrate_node?.nodeType !== 3) {
      var text2 = create_text();
      hydrate_node?.before(text2);
      set_hydrate_node(text2);
      return text2;
    }
    return hydrate_node;
  }
  function sibling(node, count = 1, is_text = false) {
    let next_sibling = hydrating ? hydrate_node : node;
    var last_sibling;
    while (count--) {
      last_sibling = next_sibling;
      next_sibling = /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(next_sibling);
    }
    if (!hydrating) {
      return next_sibling;
    }
    var type = next_sibling?.nodeType;
    if (is_text && type !== 3) {
      var text2 = create_text();
      if (next_sibling === null) {
        last_sibling?.after(text2);
      } else {
        next_sibling.before(text2);
      }
      set_hydrate_node(text2);
      return text2;
    }
    set_hydrate_node(next_sibling);
    return (
      /** @type {TemplateNode} */
      next_sibling
    );
  }
  function clear_text_content(node) {
    node.textContent = "";
  }

  // node_modules/svelte/src/internal/client/reactivity/deriveds.js
  // @__NO_SIDE_EFFECTS__
  function derived(fn) {
    var flags = DERIVED | DIRTY;
    var parent_derived = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? (
      /** @type {Derived} */
      active_reaction
    ) : null;
    if (active_effect === null || parent_derived !== null && (parent_derived.f & UNOWNED) !== 0) {
      flags |= UNOWNED;
    } else {
      active_effect.f |= EFFECT_HAS_DERIVED;
    }
    const signal = {
      ctx: component_context,
      deps: null,
      effects: null,
      equals,
      f: flags,
      fn,
      reactions: null,
      rv: 0,
      v: (
        /** @type {V} */
        null
      ),
      wv: 0,
      parent: parent_derived ?? active_effect
    };
    if (true_default && tracing_mode_flag) {
      signal.created = get_stack("CreatedAt");
    }
    return signal;
  }
  // @__NO_SIDE_EFFECTS__
  function derived_safe_equal(fn) {
    const signal = /* @__PURE__ */ derived(fn);
    signal.equals = safe_equals;
    return signal;
  }
  function destroy_derived_effects(derived3) {
    var effects = derived3.effects;
    if (effects !== null) {
      derived3.effects = null;
      for (var i = 0; i < effects.length; i += 1) {
        destroy_effect(
          /** @type {Effect} */
          effects[i]
        );
      }
    }
  }
  var stack = [];
  function get_derived_parent_effect(derived3) {
    var parent = derived3.parent;
    while (parent !== null) {
      if ((parent.f & DERIVED) === 0) {
        return (
          /** @type {Effect} */
          parent
        );
      }
      parent = parent.parent;
    }
    return null;
  }
  function execute_derived(derived3) {
    var value2;
    var prev_active_effect = active_effect;
    set_active_effect(get_derived_parent_effect(derived3));
    if (true_default) {
      let prev_inspect_effects = inspect_effects;
      set_inspect_effects(/* @__PURE__ */ new Set());
      try {
        if (stack.includes(derived3)) {
          derived_references_self();
        }
        stack.push(derived3);
        destroy_derived_effects(derived3);
        value2 = update_reaction(derived3);
      } finally {
        set_active_effect(prev_active_effect);
        set_inspect_effects(prev_inspect_effects);
        stack.pop();
      }
    } else {
      try {
        destroy_derived_effects(derived3);
        value2 = update_reaction(derived3);
      } finally {
        set_active_effect(prev_active_effect);
      }
    }
    return value2;
  }
  function update_derived(derived3) {
    var value2 = execute_derived(derived3);
    var status = (skip_reaction || (derived3.f & UNOWNED) !== 0) && derived3.deps !== null ? MAYBE_DIRTY : CLEAN;
    set_signal_status(derived3, status);
    if (!derived3.equals(value2)) {
      derived3.v = value2;
      derived3.wv = increment_write_version();
    }
  }

  // node_modules/svelte/src/internal/client/reactivity/effects.js
  function validate_effect(rune) {
    if (active_effect === null && active_reaction === null) {
      effect_orphan(rune);
    }
    if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {
      effect_in_unowned_derived();
    }
    if (is_destroying_effect) {
      effect_in_teardown(rune);
    }
  }
  function push_effect(effect2, parent_effect) {
    var parent_last = parent_effect.last;
    if (parent_last === null) {
      parent_effect.last = parent_effect.first = effect2;
    } else {
      parent_last.next = effect2;
      effect2.prev = parent_last;
      parent_effect.last = effect2;
    }
  }
  function create_effect(type, fn, sync2, push3 = true) {
    var parent = active_effect;
    if (true_default) {
      while (parent !== null && (parent.f & INSPECT_EFFECT) !== 0) {
        parent = parent.parent;
      }
    }
    var effect2 = {
      ctx: component_context,
      deps: null,
      nodes_start: null,
      nodes_end: null,
      f: type | DIRTY,
      first: null,
      fn,
      last: null,
      next: null,
      parent,
      prev: null,
      teardown: null,
      transitions: null,
      wv: 0
    };
    if (true_default) {
      effect2.component_function = dev_current_component_function;
    }
    if (sync2) {
      try {
        update_effect(effect2);
        effect2.f |= EFFECT_RAN;
      } catch (e) {
        destroy_effect(effect2);
        throw e;
      }
    } else if (fn !== null) {
      schedule_effect(effect2);
    }
    var inert = sync2 && effect2.deps === null && effect2.first === null && effect2.nodes_start === null && effect2.teardown === null && (effect2.f & (EFFECT_HAS_DERIVED | BOUNDARY_EFFECT)) === 0;
    if (!inert && push3) {
      if (parent !== null) {
        push_effect(effect2, parent);
      }
      if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
        var derived3 = (
          /** @type {Derived} */
          active_reaction
        );
        (derived3.effects ?? (derived3.effects = [])).push(effect2);
      }
    }
    return effect2;
  }
  function teardown(fn) {
    const effect2 = create_effect(RENDER_EFFECT, null, false);
    set_signal_status(effect2, CLEAN);
    effect2.teardown = fn;
    return effect2;
  }
  function user_effect(fn) {
    validate_effect("$effect");
    var defer = active_effect !== null && (active_effect.f & BRANCH_EFFECT) !== 0 && component_context !== null && !component_context.m;
    if (true_default) {
      define_property(fn, "name", {
        value: "$effect"
      });
    }
    if (defer) {
      var context = (
        /** @type {ComponentContext} */
        component_context
      );
      (context.e ?? (context.e = [])).push({
        fn,
        effect: active_effect,
        reaction: active_reaction
      });
    } else {
      var signal = effect(fn);
      return signal;
    }
  }
  function user_pre_effect(fn) {
    validate_effect("$effect.pre");
    if (true_default) {
      define_property(fn, "name", {
        value: "$effect.pre"
      });
    }
    return render_effect(fn);
  }
  function effect_root(fn) {
    const effect2 = create_effect(ROOT_EFFECT, fn, true);
    return () => {
      destroy_effect(effect2);
    };
  }
  function component_root(fn) {
    const effect2 = create_effect(ROOT_EFFECT, fn, true);
    return (options = {}) => {
      return new Promise((fulfil) => {
        if (options.outro) {
          pause_effect(effect2, () => {
            destroy_effect(effect2);
            fulfil(void 0);
          });
        } else {
          destroy_effect(effect2);
          fulfil(void 0);
        }
      });
    };
  }
  function effect(fn) {
    return create_effect(EFFECT, fn, false);
  }
  function legacy_pre_effect(deps, fn) {
    var context = (
      /** @type {ComponentContextLegacy} */
      component_context
    );
    var token = { effect: null, ran: false };
    context.l.r1.push(token);
    token.effect = render_effect(() => {
      deps();
      if (token.ran) return;
      token.ran = true;
      set(context.l.r2, true);
      untrack(fn);
    });
  }
  function legacy_pre_effect_reset() {
    var context = (
      /** @type {ComponentContextLegacy} */
      component_context
    );
    render_effect(() => {
      if (!get(context.l.r2)) return;
      for (var token of context.l.r1) {
        var effect2 = token.effect;
        if ((effect2.f & CLEAN) !== 0) {
          set_signal_status(effect2, MAYBE_DIRTY);
        }
        if (check_dirtiness(effect2)) {
          update_effect(effect2);
        }
        token.ran = false;
      }
      context.l.r2.v = false;
    });
  }
  function render_effect(fn) {
    return create_effect(RENDER_EFFECT, fn, true);
  }
  function template_effect(fn, thunks = [], d = derived) {
    const deriveds = thunks.map(d);
    const effect2 = () => fn(...deriveds.map(get));
    if (true_default) {
      define_property(effect2, "name", {
        value: "{expression}"
      });
    }
    return block(effect2);
  }
  function block(fn, flags = 0) {
    return create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);
  }
  function branch(fn, push3 = true) {
    return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push3);
  }
  function execute_effect_teardown(effect2) {
    var teardown2 = effect2.teardown;
    if (teardown2 !== null) {
      const previously_destroying_effect = is_destroying_effect;
      const previous_reaction = active_reaction;
      set_is_destroying_effect(true);
      set_active_reaction(null);
      try {
        teardown2.call(null);
      } finally {
        set_is_destroying_effect(previously_destroying_effect);
        set_active_reaction(previous_reaction);
      }
    }
  }
  function destroy_effect_children(signal, remove_dom = false) {
    var effect2 = signal.first;
    signal.first = signal.last = null;
    while (effect2 !== null) {
      var next2 = effect2.next;
      if ((effect2.f & ROOT_EFFECT) !== 0) {
        effect2.parent = null;
      } else {
        destroy_effect(effect2, remove_dom);
      }
      effect2 = next2;
    }
  }
  function destroy_block_effect_children(signal) {
    var effect2 = signal.first;
    while (effect2 !== null) {
      var next2 = effect2.next;
      if ((effect2.f & BRANCH_EFFECT) === 0) {
        destroy_effect(effect2);
      }
      effect2 = next2;
    }
  }
  function destroy_effect(effect2, remove_dom = true) {
    var removed = false;
    if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes_start !== null) {
      var node = effect2.nodes_start;
      var end = effect2.nodes_end;
      while (node !== null) {
        var next2 = node === end ? null : (
          /** @type {TemplateNode} */
          get_next_sibling(node)
        );
        node.remove();
        node = next2;
      }
      removed = true;
    }
    destroy_effect_children(effect2, remove_dom && !removed);
    remove_reactions(effect2, 0);
    set_signal_status(effect2, DESTROYED);
    var transitions = effect2.transitions;
    if (transitions !== null) {
      for (const transition2 of transitions) {
        transition2.stop();
      }
    }
    execute_effect_teardown(effect2);
    var parent = effect2.parent;
    if (parent !== null && parent.first !== null) {
      unlink_effect(effect2);
    }
    if (true_default) {
      effect2.component_function = null;
    }
    effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes_start = effect2.nodes_end = null;
  }
  function unlink_effect(effect2) {
    var parent = effect2.parent;
    var prev = effect2.prev;
    var next2 = effect2.next;
    if (prev !== null) prev.next = next2;
    if (next2 !== null) next2.prev = prev;
    if (parent !== null) {
      if (parent.first === effect2) parent.first = next2;
      if (parent.last === effect2) parent.last = prev;
    }
  }
  function pause_effect(effect2, callback) {
    var transitions = [];
    pause_children(effect2, transitions, true);
    run_out_transitions(transitions, () => {
      destroy_effect(effect2);
      if (callback) callback();
    });
  }
  function run_out_transitions(transitions, fn) {
    var remaining = transitions.length;
    if (remaining > 0) {
      var check = () => --remaining || fn();
      for (var transition2 of transitions) {
        transition2.out(check);
      }
    } else {
      fn();
    }
  }
  function pause_children(effect2, transitions, local) {
    if ((effect2.f & INERT) !== 0) return;
    effect2.f ^= INERT;
    if (effect2.transitions !== null) {
      for (const transition2 of effect2.transitions) {
        if (transition2.is_global || local) {
          transitions.push(transition2);
        }
      }
    }
    var child2 = effect2.first;
    while (child2 !== null) {
      var sibling2 = child2.next;
      var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
      pause_children(child2, transitions, transparent ? local : false);
      child2 = sibling2;
    }
  }
  function resume_effect(effect2) {
    resume_children(effect2, true);
  }
  function resume_children(effect2, local) {
    if ((effect2.f & INERT) === 0) return;
    effect2.f ^= INERT;
    if ((effect2.f & CLEAN) === 0) {
      effect2.f ^= CLEAN;
    }
    if (check_dirtiness(effect2)) {
      set_signal_status(effect2, DIRTY);
      schedule_effect(effect2);
    }
    var child2 = effect2.first;
    while (child2 !== null) {
      var sibling2 = child2.next;
      var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
      resume_children(child2, transparent ? local : false);
      child2 = sibling2;
    }
    if (effect2.transitions !== null) {
      for (const transition2 of effect2.transitions) {
        if (transition2.is_global || local) {
          transition2.in();
        }
      }
    }
  }

  // node_modules/svelte/src/internal/client/dom/task.js
  var request_idle_callback = typeof requestIdleCallback === "undefined" ? (cb) => setTimeout(cb, 1) : requestIdleCallback;
  var micro_tasks = [];
  var idle_tasks = [];
  function run_micro_tasks() {
    var tasks = micro_tasks;
    micro_tasks = [];
    run_all(tasks);
  }
  function run_idle_tasks() {
    var tasks = idle_tasks;
    idle_tasks = [];
    run_all(tasks);
  }
  function queue_micro_task(fn) {
    if (micro_tasks.length === 0) {
      queueMicrotask(run_micro_tasks);
    }
    micro_tasks.push(fn);
  }
  function queue_idle_task(fn) {
    if (idle_tasks.length === 0) {
      request_idle_callback(run_idle_tasks);
    }
    idle_tasks.push(fn);
  }
  function flush_tasks() {
    if (micro_tasks.length > 0) {
      run_micro_tasks();
    }
    if (idle_tasks.length > 0) {
      run_idle_tasks();
    }
  }

  // node_modules/svelte/src/internal/client/runtime.js
  var handled_errors = /* @__PURE__ */ new WeakSet();
  var is_throwing_error = false;
  var is_flushing = false;
  var last_scheduled_effect = null;
  var is_updating_effect = false;
  var is_destroying_effect = false;
  function set_is_destroying_effect(value2) {
    is_destroying_effect = value2;
  }
  var queued_root_effects = [];
  var dev_effect_stack = [];
  var active_reaction = null;
  var untracking = false;
  function set_active_reaction(reaction) {
    active_reaction = reaction;
  }
  var active_effect = null;
  function set_active_effect(effect2) {
    active_effect = effect2;
  }
  var reaction_sources = null;
  function set_reaction_sources(sources) {
    reaction_sources = sources;
  }
  function push_reaction_value(value2) {
    if (active_reaction !== null && active_reaction.f & EFFECT_IS_UPDATING) {
      if (reaction_sources === null) {
        set_reaction_sources([value2]);
      } else {
        reaction_sources.push(value2);
      }
    }
  }
  var new_deps = null;
  var skipped_deps = 0;
  var untracked_writes = null;
  function set_untracked_writes(value2) {
    untracked_writes = value2;
  }
  var write_version = 1;
  var read_version = 0;
  var skip_reaction = false;
  var captured_signals = null;
  function increment_write_version() {
    return ++write_version;
  }
  function check_dirtiness(reaction) {
    var flags = reaction.f;
    if ((flags & DIRTY) !== 0) {
      return true;
    }
    if ((flags & MAYBE_DIRTY) !== 0) {
      var dependencies = reaction.deps;
      var is_unowned = (flags & UNOWNED) !== 0;
      if (dependencies !== null) {
        var i;
        var dependency;
        var is_disconnected = (flags & DISCONNECTED) !== 0;
        var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
        var length2 = dependencies.length;
        if (is_disconnected || is_unowned_connected) {
          var derived3 = (
            /** @type {Derived} */
            reaction
          );
          var parent = derived3.parent;
          for (i = 0; i < length2; i++) {
            dependency = dependencies[i];
            if (is_disconnected || !dependency?.reactions?.includes(derived3)) {
              (dependency.reactions ?? (dependency.reactions = [])).push(derived3);
            }
          }
          if (is_disconnected) {
            derived3.f ^= DISCONNECTED;
          }
          if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
            derived3.f ^= UNOWNED;
          }
        }
        for (i = 0; i < length2; i++) {
          dependency = dependencies[i];
          if (check_dirtiness(
            /** @type {Derived} */
            dependency
          )) {
            update_derived(
              /** @type {Derived} */
              dependency
            );
          }
          if (dependency.wv > reaction.wv) {
            return true;
          }
        }
      }
      if (!is_unowned || active_effect !== null && !skip_reaction) {
        set_signal_status(reaction, CLEAN);
      }
    }
    return false;
  }
  function propagate_error(error, effect2) {
    var current = effect2;
    while (current !== null) {
      if ((current.f & BOUNDARY_EFFECT) !== 0) {
        try {
          current.fn(error);
          return;
        } catch {
          current.f ^= BOUNDARY_EFFECT;
        }
      }
      current = current.parent;
    }
    is_throwing_error = false;
    throw error;
  }
  function should_rethrow_error(effect2) {
    return (effect2.f & DESTROYED) === 0 && (effect2.parent === null || (effect2.parent.f & BOUNDARY_EFFECT) === 0);
  }
  function handle_error(error, effect2, previous_effect, component_context2) {
    if (is_throwing_error) {
      if (previous_effect === null) {
        is_throwing_error = false;
      }
      if (should_rethrow_error(effect2)) {
        throw error;
      }
      return;
    }
    if (previous_effect !== null) {
      is_throwing_error = true;
    }
    if (!true_default || component_context2 === null || !(error instanceof Error) || handled_errors.has(error)) {
      propagate_error(error, effect2);
      return;
    }
    handled_errors.add(error);
    const component_stack = [];
    const effect_name = effect2.fn?.name;
    if (effect_name) {
      component_stack.push(effect_name);
    }
    let current_context = component_context2;
    while (current_context !== null) {
      if (true_default) {
        var filename = current_context.function?.[FILENAME];
        if (filename) {
          const file = filename.split("/").pop();
          component_stack.push(file);
        }
      }
      current_context = current_context.p;
    }
    const indent = is_firefox ? "  " : "	";
    define_property(error, "message", {
      value: error.message + `
${component_stack.map((name) => `
${indent}in ${name}`).join("")}
`
    });
    define_property(error, "component_stack", {
      value: component_stack
    });
    const stack2 = error.stack;
    if (stack2) {
      const lines = stack2.split("\n");
      const new_lines = [];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.includes("svelte/src/internal")) {
          continue;
        }
        new_lines.push(line);
      }
      define_property(error, "stack", {
        value: new_lines.join("\n")
      });
    }
    propagate_error(error, effect2);
    if (should_rethrow_error(effect2)) {
      throw error;
    }
  }
  function schedule_possible_effect_self_invalidation(signal, effect2, root12 = true) {
    var reactions = signal.reactions;
    if (reactions === null) return;
    for (var i = 0; i < reactions.length; i++) {
      var reaction = reactions[i];
      if (reaction_sources?.includes(signal)) continue;
      if ((reaction.f & DERIVED) !== 0) {
        schedule_possible_effect_self_invalidation(
          /** @type {Derived} */
          reaction,
          effect2,
          false
        );
      } else if (effect2 === reaction) {
        if (root12) {
          set_signal_status(reaction, DIRTY);
        } else if ((reaction.f & CLEAN) !== 0) {
          set_signal_status(reaction, MAYBE_DIRTY);
        }
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
  function update_reaction(reaction) {
    var _a2;
    var previous_deps = new_deps;
    var previous_skipped_deps = skipped_deps;
    var previous_untracked_writes = untracked_writes;
    var previous_reaction = active_reaction;
    var previous_skip_reaction = skip_reaction;
    var previous_reaction_sources = reaction_sources;
    var previous_component_context = component_context;
    var previous_untracking = untracking;
    var flags = reaction.f;
    new_deps = /** @type {null | Value[]} */
    null;
    skipped_deps = 0;
    untracked_writes = null;
    skip_reaction = (flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
    active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
    reaction_sources = null;
    set_component_context(reaction.ctx);
    untracking = false;
    read_version++;
    reaction.f |= EFFECT_IS_UPDATING;
    try {
      var result = (
        /** @type {Function} */
        (0, reaction.fn)()
      );
      var deps = reaction.deps;
      if (new_deps !== null) {
        var i;
        remove_reactions(reaction, skipped_deps);
        if (deps !== null && skipped_deps > 0) {
          deps.length = skipped_deps + new_deps.length;
          for (i = 0; i < new_deps.length; i++) {
            deps[skipped_deps + i] = new_deps[i];
          }
        } else {
          reaction.deps = deps = new_deps;
        }
        if (!skip_reaction) {
          for (i = skipped_deps; i < deps.length; i++) {
            ((_a2 = deps[i]).reactions ?? (_a2.reactions = [])).push(reaction);
          }
        }
      } else if (deps !== null && skipped_deps < deps.length) {
        remove_reactions(reaction, skipped_deps);
        deps.length = skipped_deps;
      }
      if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
        for (i = 0; i < /** @type {Source[]} */
        untracked_writes.length; i++) {
          schedule_possible_effect_self_invalidation(
            untracked_writes[i],
            /** @type {Effect} */
            reaction
          );
        }
      }
      if (previous_reaction !== null) {
        read_version++;
        if (untracked_writes !== null) {
          if (previous_untracked_writes === null) {
            previous_untracked_writes = untracked_writes;
          } else {
            previous_untracked_writes.push(.../** @type {Source[]} */
            untracked_writes);
          }
        }
      }
      return result;
    } finally {
      new_deps = previous_deps;
      skipped_deps = previous_skipped_deps;
      untracked_writes = previous_untracked_writes;
      active_reaction = previous_reaction;
      skip_reaction = previous_skip_reaction;
      reaction_sources = previous_reaction_sources;
      set_component_context(previous_component_context);
      untracking = previous_untracking;
      reaction.f ^= EFFECT_IS_UPDATING;
    }
  }
  function remove_reaction(signal, dependency) {
    let reactions = dependency.reactions;
    if (reactions !== null) {
      var index5 = index_of.call(reactions, signal);
      if (index5 !== -1) {
        var new_length = reactions.length - 1;
        if (new_length === 0) {
          reactions = dependency.reactions = null;
        } else {
          reactions[index5] = reactions[new_length];
          reactions.pop();
        }
      }
    }
    if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
    // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
    // allows us to skip the expensive work of disconnecting and immediately reconnecting it
    (new_deps === null || !new_deps.includes(dependency))) {
      set_signal_status(dependency, MAYBE_DIRTY);
      if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
        dependency.f ^= DISCONNECTED;
      }
      destroy_derived_effects(
        /** @type {Derived} **/
        dependency
      );
      remove_reactions(
        /** @type {Derived} **/
        dependency,
        0
      );
    }
  }
  function remove_reactions(signal, start_index) {
    var dependencies = signal.deps;
    if (dependencies === null) return;
    for (var i = start_index; i < dependencies.length; i++) {
      remove_reaction(signal, dependencies[i]);
    }
  }
  function update_effect(effect2) {
    var flags = effect2.f;
    if ((flags & DESTROYED) !== 0) {
      return;
    }
    set_signal_status(effect2, CLEAN);
    var previous_effect = active_effect;
    var previous_component_context = component_context;
    var was_updating_effect = is_updating_effect;
    active_effect = effect2;
    is_updating_effect = true;
    if (true_default) {
      var previous_component_fn = dev_current_component_function;
      set_dev_current_component_function(effect2.component_function);
    }
    try {
      if ((flags & BLOCK_EFFECT) !== 0) {
        destroy_block_effect_children(effect2);
      } else {
        destroy_effect_children(effect2);
      }
      execute_effect_teardown(effect2);
      var teardown2 = update_reaction(effect2);
      effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
      effect2.wv = write_version;
      var deps = effect2.deps;
      if (true_default && tracing_mode_flag && (effect2.f & DIRTY) !== 0 && deps !== null) {
        for (let i = 0; i < deps.length; i++) {
          var dep = deps[i];
          if (dep.trace_need_increase) {
            dep.wv = increment_write_version();
            dep.trace_need_increase = void 0;
            dep.trace_v = void 0;
          }
        }
      }
      if (true_default) {
        dev_effect_stack.push(effect2);
      }
    } catch (error) {
      handle_error(error, effect2, previous_effect, previous_component_context || effect2.ctx);
    } finally {
      is_updating_effect = was_updating_effect;
      active_effect = previous_effect;
      if (true_default) {
        set_dev_current_component_function(previous_component_fn);
      }
    }
  }
  function log_effect_stack() {
    console.error(
      "Last ten effects were: ",
      dev_effect_stack.slice(-10).map((d) => d.fn)
    );
    dev_effect_stack = [];
  }
  function infinite_loop_guard() {
    try {
      effect_update_depth_exceeded();
    } catch (error) {
      if (true_default) {
        define_property(error, "stack", {
          value: ""
        });
      }
      if (last_scheduled_effect !== null) {
        if (true_default) {
          try {
            handle_error(error, last_scheduled_effect, null, null);
          } catch (e) {
            log_effect_stack();
            throw e;
          }
        } else {
          handle_error(error, last_scheduled_effect, null, null);
        }
      } else {
        if (true_default) {
          log_effect_stack();
        }
        throw error;
      }
    }
  }
  function flush_queued_root_effects() {
    var was_updating_effect = is_updating_effect;
    try {
      var flush_count = 0;
      is_updating_effect = true;
      while (queued_root_effects.length > 0) {
        if (flush_count++ > 1e3) {
          infinite_loop_guard();
        }
        var root_effects = queued_root_effects;
        var length2 = root_effects.length;
        queued_root_effects = [];
        for (var i = 0; i < length2; i++) {
          var collected_effects = process_effects(root_effects[i]);
          flush_queued_effects(collected_effects);
        }
      }
    } finally {
      is_flushing = false;
      is_updating_effect = was_updating_effect;
      last_scheduled_effect = null;
      if (true_default) {
        dev_effect_stack = [];
      }
      old_values.clear();
    }
  }
  function flush_queued_effects(effects) {
    var length2 = effects.length;
    if (length2 === 0) return;
    for (var i = 0; i < length2; i++) {
      var effect2 = effects[i];
      if ((effect2.f & (DESTROYED | INERT)) === 0) {
        try {
          if (check_dirtiness(effect2)) {
            update_effect(effect2);
            if (effect2.deps === null && effect2.first === null && effect2.nodes_start === null) {
              if (effect2.teardown === null) {
                unlink_effect(effect2);
              } else {
                effect2.fn = null;
              }
            }
          }
        } catch (error) {
          handle_error(error, effect2, null, effect2.ctx);
        }
      }
    }
  }
  function schedule_effect(signal) {
    if (!is_flushing) {
      is_flushing = true;
      queueMicrotask(flush_queued_root_effects);
    }
    var effect2 = last_scheduled_effect = signal;
    while (effect2.parent !== null) {
      effect2 = effect2.parent;
      var flags = effect2.f;
      if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
        if ((flags & CLEAN) === 0) return;
        effect2.f ^= CLEAN;
      }
    }
    queued_root_effects.push(effect2);
  }
  function process_effects(root12) {
    var effects = [];
    var effect2 = root12;
    while (effect2 !== null) {
      var flags = effect2.f;
      var is_branch = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
      var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;
      if (!is_skippable_branch && (flags & INERT) === 0) {
        if ((flags & EFFECT) !== 0) {
          effects.push(effect2);
        } else if (is_branch) {
          effect2.f ^= CLEAN;
        } else {
          var previous_active_reaction = active_reaction;
          try {
            active_reaction = effect2;
            if (check_dirtiness(effect2)) {
              update_effect(effect2);
            }
          } catch (error) {
            handle_error(error, effect2, null, effect2.ctx);
          } finally {
            active_reaction = previous_active_reaction;
          }
        }
        var child2 = effect2.first;
        if (child2 !== null) {
          effect2 = child2;
          continue;
        }
      }
      var parent = effect2.parent;
      effect2 = effect2.next;
      while (effect2 === null && parent !== null) {
        effect2 = parent.next;
        parent = parent.parent;
      }
    }
    return effects;
  }
  function flushSync(fn) {
    var result;
    if (fn) {
      is_flushing = true;
      flush_queued_root_effects();
      result = fn();
    }
    flush_tasks();
    while (queued_root_effects.length > 0) {
      is_flushing = true;
      flush_queued_root_effects();
      flush_tasks();
    }
    return (
      /** @type {T} */
      result
    );
  }
  async function tick() {
    await Promise.resolve();
    flushSync();
  }
  function get(signal) {
    var flags = signal.f;
    var is_derived = (flags & DERIVED) !== 0;
    if (captured_signals !== null) {
      captured_signals.add(signal);
    }
    if (active_reaction !== null && !untracking) {
      if (!reaction_sources?.includes(signal)) {
        var deps = active_reaction.deps;
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else if (!skip_reaction || !new_deps.includes(signal)) {
            new_deps.push(signal);
          }
        }
      }
    } else if (is_derived && /** @type {Derived} */
    signal.deps === null && /** @type {Derived} */
    signal.effects === null) {
      var derived3 = (
        /** @type {Derived} */
        signal
      );
      var parent = derived3.parent;
      if (parent !== null && (parent.f & UNOWNED) === 0) {
        derived3.f ^= UNOWNED;
      }
    }
    if (is_derived) {
      derived3 = /** @type {Derived} */
      signal;
      if (check_dirtiness(derived3)) {
        update_derived(derived3);
      }
    }
    if (true_default && tracing_mode_flag && tracing_expressions !== null && active_reaction !== null && tracing_expressions.reaction === active_reaction) {
      if (signal.debug) {
        signal.debug();
      } else if (signal.created) {
        var entry = tracing_expressions.entries.get(signal);
        if (entry === void 0) {
          entry = { read: [] };
          tracing_expressions.entries.set(signal, entry);
        }
        entry.read.push(get_stack("TracedAt"));
      }
    }
    if (is_destroying_effect && old_values.has(signal)) {
      return old_values.get(signal);
    }
    return signal.v;
  }
  function untrack(fn) {
    var previous_untracking = untracking;
    try {
      untracking = true;
      return fn();
    } finally {
      untracking = previous_untracking;
    }
  }
  var STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
  function set_signal_status(signal, status) {
    signal.f = signal.f & STATUS_MASK | status;
  }
  function deep_read_state(value2) {
    if (typeof value2 !== "object" || !value2 || value2 instanceof EventTarget) {
      return;
    }
    if (STATE_SYMBOL in value2) {
      deep_read(value2);
    } else if (!Array.isArray(value2)) {
      for (let key in value2) {
        const prop2 = value2[key];
        if (typeof prop2 === "object" && prop2 && STATE_SYMBOL in prop2) {
          deep_read(prop2);
        }
      }
    }
  }
  function deep_read(value2, visited = /* @__PURE__ */ new Set()) {
    if (typeof value2 === "object" && value2 !== null && // We don't want to traverse DOM elements
    !(value2 instanceof EventTarget) && !visited.has(value2)) {
      visited.add(value2);
      if (value2 instanceof Date) {
        value2.getTime();
      }
      for (let key in value2) {
        try {
          deep_read(value2[key], visited);
        } catch (e) {
        }
      }
      const proto = get_prototype_of(value2);
      if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {
        const descriptors = get_descriptors(proto);
        for (let key in descriptors) {
          const get3 = descriptors[key].get;
          if (get3) {
            try {
              get3.call(value2);
            } catch (e) {
            }
          }
        }
      }
    }
  }

  // node_modules/svelte/src/utils.js
  var regex_return_characters = /\r/g;
  function hash(str) {
    str = str.replace(regex_return_characters, "");
    let hash2 = 5381;
    let i = str.length;
    while (i--) hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
    return (hash2 >>> 0).toString(36);
  }
  var VOID_ELEMENT_NAMES = [
    "area",
    "base",
    "br",
    "col",
    "command",
    "embed",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ];
  function is_void(name) {
    return VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === "!doctype";
  }
  function is_capture_event(name) {
    return name.endsWith("capture") && name !== "gotpointercapture" && name !== "lostpointercapture";
  }
  var DELEGATED_EVENTS = [
    "beforeinput",
    "click",
    "change",
    "dblclick",
    "contextmenu",
    "focusin",
    "focusout",
    "input",
    "keydown",
    "keyup",
    "mousedown",
    "mousemove",
    "mouseout",
    "mouseover",
    "mouseup",
    "pointerdown",
    "pointermove",
    "pointerout",
    "pointerover",
    "pointerup",
    "touchend",
    "touchmove",
    "touchstart"
  ];
  function is_delegated(event_name) {
    return DELEGATED_EVENTS.includes(event_name);
  }
  var DOM_BOOLEAN_ATTRIBUTES = [
    "allowfullscreen",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "disabled",
    "formnovalidate",
    "hidden",
    "indeterminate",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "seamless",
    "selected",
    "webkitdirectory",
    "defer",
    "disablepictureinpicture",
    "disableremoteplayback"
  ];
  var ATTRIBUTE_ALIASES = {
    // no `class: 'className'` because we handle that separately
    formnovalidate: "formNoValidate",
    ismap: "isMap",
    nomodule: "noModule",
    playsinline: "playsInline",
    readonly: "readOnly",
    defaultvalue: "defaultValue",
    defaultchecked: "defaultChecked",
    srcobject: "srcObject",
    novalidate: "noValidate",
    allowfullscreen: "allowFullscreen",
    disablepictureinpicture: "disablePictureInPicture",
    disableremoteplayback: "disableRemotePlayback"
  };
  function normalize_attribute(name) {
    name = name.toLowerCase();
    return ATTRIBUTE_ALIASES[name] ?? name;
  }
  var DOM_PROPERTIES = [
    ...DOM_BOOLEAN_ATTRIBUTES,
    "formNoValidate",
    "isMap",
    "noModule",
    "playsInline",
    "readOnly",
    "value",
    "volume",
    "defaultValue",
    "defaultChecked",
    "srcObject",
    "noValidate",
    "allowFullscreen",
    "disablePictureInPicture",
    "disableRemotePlayback"
  ];
  var PASSIVE_EVENTS = ["touchstart", "touchmove"];
  function is_passive_event(name) {
    return PASSIVE_EVENTS.includes(name);
  }
  var RAW_TEXT_ELEMENTS = (
    /** @type {const} */
    ["textarea", "script", "style", "title"]
  );
  function is_raw_text_element(name) {
    return RAW_TEXT_ELEMENTS.includes(
      /** @type {RAW_TEXT_ELEMENTS[number]} */
      name
    );
  }
  function sanitize_location(location) {
    return location?.replace(/\//g, "/\u200B");
  }

  // node_modules/svelte/src/internal/client/dev/assign.js
  function compare(a, b, property, location) {
    if (a !== b) {
      assignment_value_stale(
        property,
        /** @type {string} */
        sanitize_location(location)
      );
    }
    return a;
  }
  function assign(object, property, value2, location) {
    return compare(
      object[property] = value2,
      untrack(() => object[property]),
      property,
      location
    );
  }

  // node_modules/svelte/src/internal/client/dev/css.js
  var all_styles = /* @__PURE__ */ new Map();
  function register_style(hash2, style) {
    var styles = all_styles.get(hash2);
    if (!styles) {
      styles = /* @__PURE__ */ new Set();
      all_styles.set(hash2, styles);
    }
    styles.add(style);
  }

  // node_modules/svelte/src/internal/client/dev/elements.js
  function add_locations(fn, filename, locations) {
    return (...args) => {
      const dom = fn(...args);
      var node = hydrating ? dom : dom.nodeType === 11 ? dom.firstChild : dom;
      assign_locations(node, filename, locations);
      return dom;
    };
  }
  function assign_location(element2, filename, location) {
    element2.__svelte_meta = {
      loc: { file: filename, line: location[0], column: location[1] }
    };
    if (location[2]) {
      assign_locations(element2.firstChild, filename, location[2]);
    }
  }
  function assign_locations(node, filename, locations) {
    var i = 0;
    var depth = 0;
    while (node && i < locations.length) {
      if (hydrating && node.nodeType === 8) {
        var comment3 = (
          /** @type {Comment} */
          node
        );
        if (comment3.data === HYDRATION_START || comment3.data === HYDRATION_START_ELSE) depth += 1;
        else if (comment3.data[0] === HYDRATION_END) depth -= 1;
      }
      if (depth === 0 && node.nodeType === 1) {
        assign_location(
          /** @type {Element} */
          node,
          filename,
          locations[i++]
        );
      }
      node = node.nextSibling;
    }
  }

  // node_modules/svelte/src/internal/client/dom/elements/misc.js
  function autofocus(dom, value2) {
    if (value2) {
      const body = document.body;
      dom.autofocus = true;
      queue_micro_task(() => {
        if (document.activeElement === body) {
          dom.focus();
        }
      });
    }
  }
  function remove_textarea_child(dom) {
    if (hydrating && get_first_child(dom) !== null) {
      clear_text_content(dom);
    }
  }
  var listening_to_form_reset = false;
  function add_form_reset_listener() {
    if (!listening_to_form_reset) {
      listening_to_form_reset = true;
      document.addEventListener(
        "reset",
        (evt) => {
          Promise.resolve().then(() => {
            if (!evt.defaultPrevented) {
              for (
                const e of
                /**@type {HTMLFormElement} */
                evt.target.elements
              ) {
                e.__on_r?.();
              }
            }
          });
        },
        // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
        { capture: true }
      );
    }
  }

  // node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js
  function without_reactive_context(fn) {
    var previous_reaction = active_reaction;
    var previous_effect = active_effect;
    set_active_reaction(null);
    set_active_effect(null);
    try {
      return fn();
    } finally {
      set_active_reaction(previous_reaction);
      set_active_effect(previous_effect);
    }
  }

  // node_modules/svelte/src/internal/client/dom/elements/events.js
  var all_registered_events = /* @__PURE__ */ new Set();
  var root_event_handles = /* @__PURE__ */ new Set();
  function create_event(event_name, dom, handler, options = {}) {
    function target_handler(event2) {
      if (!options.capture) {
        handle_event_propagation.call(dom, event2);
      }
      if (!event2.cancelBubble) {
        return without_reactive_context(() => {
          return handler?.call(this, event2);
        });
      }
    }
    if (event_name.startsWith("pointer") || event_name.startsWith("touch") || event_name === "wheel") {
      queue_micro_task(() => {
        dom.addEventListener(event_name, target_handler, options);
      });
    } else {
      dom.addEventListener(event_name, target_handler, options);
    }
    return target_handler;
  }
  function event(event_name, dom, handler, capture, passive2) {
    var options = { capture, passive: passive2 };
    var target_handler = create_event(event_name, dom, handler, options);
    if (dom === document.body || dom === window || dom === document) {
      teardown(() => {
        dom.removeEventListener(event_name, target_handler, options);
      });
    }
  }
  function delegate(events) {
    for (var i = 0; i < events.length; i++) {
      all_registered_events.add(events[i]);
    }
    for (var fn of root_event_handles) {
      fn(events);
    }
  }
  function handle_event_propagation(event2) {
    var handler_element = this;
    var owner_document = (
      /** @type {Node} */
      handler_element.ownerDocument
    );
    var event_name = event2.type;
    var path = event2.composedPath?.() || [];
    var current_target = (
      /** @type {null | Element} */
      path[0] || event2.target
    );
    var path_idx = 0;
    var handled_at = event2.__root;
    if (handled_at) {
      var at_idx = path.indexOf(handled_at);
      if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
      window)) {
        event2.__root = handler_element;
        return;
      }
      var handler_idx = path.indexOf(handler_element);
      if (handler_idx === -1) {
        return;
      }
      if (at_idx <= handler_idx) {
        path_idx = at_idx;
      }
    }
    current_target = /** @type {Element} */
    path[path_idx] || event2.target;
    if (current_target === handler_element) return;
    define_property(event2, "currentTarget", {
      configurable: true,
      get() {
        return current_target || owner_document;
      }
    });
    var previous_reaction = active_reaction;
    var previous_effect = active_effect;
    set_active_reaction(null);
    set_active_effect(null);
    try {
      var throw_error;
      var other_errors = [];
      while (current_target !== null) {
        var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
        current_target.host || null;
        try {
          var delegated = current_target["__" + event_name];
          if (delegated != null && (!/** @type {any} */
          current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          event2.target === current_target)) {
            if (is_array(delegated)) {
              var [fn, ...data] = delegated;
              fn.apply(current_target, [event2, ...data]);
            } else {
              delegated.call(current_target, event2);
            }
          }
        } catch (error) {
          if (throw_error) {
            other_errors.push(error);
          } else {
            throw_error = error;
          }
        }
        if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
          break;
        }
        current_target = parent_element;
      }
      if (throw_error) {
        for (let error of other_errors) {
          queueMicrotask(() => {
            throw error;
          });
        }
        throw throw_error;
      }
    } finally {
      event2.__root = handler_element;
      delete event2.currentTarget;
      set_active_reaction(previous_reaction);
      set_active_effect(previous_effect);
    }
  }
  function apply(thunk, element2, args, component2, loc, has_side_effects = false, remove_parens = false) {
    let handler;
    let error;
    try {
      handler = thunk();
    } catch (e) {
      error = e;
    }
    if (typeof handler !== "function" && (has_side_effects || handler != null || error)) {
      const filename = component2?.[FILENAME];
      const location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;
      const phase = args[0]?.eventPhase < Event.BUBBLING_PHASE ? "capture" : "";
      const event_name = args[0]?.type + phase;
      const description = `\`${event_name}\` handler${location}`;
      const suggestion = remove_parens ? "remove the trailing `()`" : "add a leading `() =>`";
      event_handler_invalid(description, suggestion);
      if (error) {
        throw error;
      }
    }
    handler?.apply(element2, args);
  }

  // node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js
  var head_anchor;
  function reset_head_anchor() {
    head_anchor = void 0;
  }

  // node_modules/svelte/src/internal/client/dom/reconciler.js
  function create_fragment_from_html(html3) {
    var elem = document.createElement("template");
    elem.innerHTML = html3;
    return elem.content;
  }

  // node_modules/svelte/src/internal/client/dom/template.js
  function assign_nodes(start, end) {
    var effect2 = (
      /** @type {Effect} */
      active_effect
    );
    if (effect2.nodes_start === null) {
      effect2.nodes_start = start;
      effect2.nodes_end = end;
    }
  }
  // @__NO_SIDE_EFFECTS__
  function template(content, flags) {
    var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
    var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;
    var node;
    var has_start = !content.startsWith("<!>");
    return () => {
      if (hydrating) {
        assign_nodes(hydrate_node, null);
        return hydrate_node;
      }
      if (node === void 0) {
        node = create_fragment_from_html(has_start ? content : "<!>" + content);
        if (!is_fragment) node = /** @type {Node} */
        get_first_child(node);
      }
      var clone = (
        /** @type {TemplateNode} */
        use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
      );
      if (is_fragment) {
        var start = (
          /** @type {TemplateNode} */
          get_first_child(clone)
        );
        var end = (
          /** @type {TemplateNode} */
          clone.lastChild
        );
        assign_nodes(start, end);
      } else {
        assign_nodes(clone, clone);
      }
      return clone;
    };
  }
  function text(value2 = "") {
    if (!hydrating) {
      var t = create_text(value2 + "");
      assign_nodes(t, t);
      return t;
    }
    var node = hydrate_node;
    if (node.nodeType !== 3) {
      node.before(node = create_text());
      set_hydrate_node(node);
    }
    assign_nodes(node, node);
    return node;
  }
  function comment() {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    var frag = document.createDocumentFragment();
    var start = document.createComment("");
    var anchor = create_text();
    frag.append(start, anchor);
    assign_nodes(start, anchor);
    return frag;
  }
  function append(anchor, dom) {
    if (hydrating) {
      active_effect.nodes_end = hydrate_node;
      hydrate_next();
      return;
    }
    if (anchor === null) {
      return;
    }
    anchor.before(
      /** @type {Node} */
      dom
    );
  }

  // node_modules/svelte/src/internal/client/render.js
  var should_intro = true;
  function set_should_intro(value2) {
    should_intro = value2;
  }
  function set_text(text2, value2) {
    var str = value2 == null ? "" : typeof value2 === "object" ? value2 + "" : value2;
    if (str !== (text2.__t ?? (text2.__t = text2.nodeValue))) {
      text2.__t = str;
      text2.nodeValue = str + "";
    }
  }
  function mount(component2, options) {
    return _mount(component2, options);
  }
  function hydrate(component2, options) {
    init_operations();
    options.intro = options.intro ?? false;
    const target = options.target;
    const was_hydrating = hydrating;
    const previous_hydrate_node = hydrate_node;
    try {
      var anchor = (
        /** @type {TemplateNode} */
        get_first_child(target)
      );
      while (anchor && (anchor.nodeType !== 8 || /** @type {Comment} */
      anchor.data !== HYDRATION_START)) {
        anchor = /** @type {TemplateNode} */
        get_next_sibling(anchor);
      }
      if (!anchor) {
        throw HYDRATION_ERROR;
      }
      set_hydrating(true);
      set_hydrate_node(
        /** @type {Comment} */
        anchor
      );
      hydrate_next();
      const instance = _mount(component2, { ...options, anchor });
      if (hydrate_node === null || hydrate_node.nodeType !== 8 || /** @type {Comment} */
      hydrate_node.data !== HYDRATION_END) {
        hydration_mismatch();
        throw HYDRATION_ERROR;
      }
      set_hydrating(false);
      return (
        /**  @type {Exports} */
        instance
      );
    } catch (error) {
      if (error === HYDRATION_ERROR) {
        if (options.recover === false) {
          hydration_failed();
        }
        init_operations();
        clear_text_content(target);
        set_hydrating(false);
        return mount(component2, options);
      }
      throw error;
    } finally {
      set_hydrating(was_hydrating);
      set_hydrate_node(previous_hydrate_node);
      reset_head_anchor();
    }
  }
  var document_listeners = /* @__PURE__ */ new Map();
  function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
    init_operations();
    var registered_events = /* @__PURE__ */ new Set();
    var event_handle = (events2) => {
      for (var i = 0; i < events2.length; i++) {
        var event_name = events2[i];
        if (registered_events.has(event_name)) continue;
        registered_events.add(event_name);
        var passive2 = is_passive_event(event_name);
        target.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
        var n = document_listeners.get(event_name);
        if (n === void 0) {
          document.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
          document_listeners.set(event_name, 1);
        } else {
          document_listeners.set(event_name, n + 1);
        }
      }
    };
    event_handle(array_from(all_registered_events));
    root_event_handles.add(event_handle);
    var component2 = void 0;
    var unmount2 = component_root(() => {
      var anchor_node = anchor ?? target.appendChild(create_text());
      branch(() => {
        if (context) {
          push({});
          var ctx = (
            /** @type {ComponentContext} */
            component_context
          );
          ctx.c = context;
        }
        if (events) {
          props.$$events = events;
        }
        if (hydrating) {
          assign_nodes(
            /** @type {TemplateNode} */
            anchor_node,
            null
          );
        }
        should_intro = intro;
        component2 = Component(anchor_node, props) || {};
        should_intro = true;
        if (hydrating) {
          active_effect.nodes_end = hydrate_node;
        }
        if (context) {
          pop();
        }
      });
      return () => {
        for (var event_name of registered_events) {
          target.removeEventListener(event_name, handle_event_propagation);
          var n = (
            /** @type {number} */
            document_listeners.get(event_name)
          );
          if (--n === 0) {
            document.removeEventListener(event_name, handle_event_propagation);
            document_listeners.delete(event_name);
          } else {
            document_listeners.set(event_name, n);
          }
        }
        root_event_handles.delete(event_handle);
        if (anchor_node !== anchor) {
          anchor_node.parentNode?.removeChild(anchor_node);
        }
      };
    });
    mounted_components.set(component2, unmount2);
    return component2;
  }
  var mounted_components = /* @__PURE__ */ new WeakMap();
  function unmount(component2, options) {
    const fn = mounted_components.get(component2);
    if (fn) {
      mounted_components.delete(component2);
      return fn(options);
    }
    if (true_default) {
      lifecycle_double_unmount();
    }
    return Promise.resolve();
  }

  // node_modules/svelte/src/internal/client/dev/legacy.js
  function check_target(target) {
    if (target) {
      component_api_invalid_new(target[FILENAME] ?? "a component", target.name);
    }
  }
  function legacy_api() {
    const component2 = component_context?.function;
    function error(method) {
      const parent = get_component()?.[FILENAME] ?? "Something";
      component_api_changed(parent, method, component2[FILENAME]);
    }
    return {
      $destroy: () => error("$destroy()"),
      $on: () => error("$on(...)"),
      $set: () => error("$set(...)")
    };
  }

  // node_modules/svelte/src/internal/client/dom/blocks/if.js
  function if_block(node, fn, [root_index, hydrate_index] = [0, 0]) {
    if (hydrating && root_index === 0) {
      hydrate_next();
    }
    var anchor = node;
    var consequent_effect = null;
    var alternate_effect = null;
    var condition = UNINITIALIZED;
    var flags = root_index > 0 ? EFFECT_TRANSPARENT : 0;
    var has_branch = false;
    const set_branch = (fn2, flag = true) => {
      has_branch = true;
      update_branch(flag, fn2);
    };
    const update_branch = (new_condition, fn2) => {
      if (condition === (condition = new_condition)) return;
      let mismatch = false;
      if (hydrating && hydrate_index !== -1) {
        if (root_index === 0) {
          const data = (
            /** @type {Comment} */
            anchor.data
          );
          if (data === HYDRATION_START) {
            hydrate_index = 0;
          } else if (data === HYDRATION_START_ELSE) {
            hydrate_index = Infinity;
          } else {
            hydrate_index = parseInt(data.substring(1));
            if (hydrate_index !== hydrate_index) {
              hydrate_index = condition ? Infinity : -1;
            }
          }
        }
        const is_else = hydrate_index > root_index;
        if (!!condition === is_else) {
          anchor = remove_nodes();
          set_hydrate_node(anchor);
          set_hydrating(false);
          mismatch = true;
          hydrate_index = -1;
        }
      }
      if (condition) {
        if (consequent_effect) {
          resume_effect(consequent_effect);
        } else if (fn2) {
          consequent_effect = branch(() => fn2(anchor));
        }
        if (alternate_effect) {
          pause_effect(alternate_effect, () => {
            alternate_effect = null;
          });
        }
      } else {
        if (alternate_effect) {
          resume_effect(alternate_effect);
        } else if (fn2) {
          alternate_effect = branch(() => fn2(anchor, [root_index + 1, hydrate_index]));
        }
        if (consequent_effect) {
          pause_effect(consequent_effect, () => {
            consequent_effect = null;
          });
        }
      }
      if (mismatch) {
        set_hydrating(true);
      }
    };
    block(() => {
      has_branch = false;
      fn(set_branch);
      if (!has_branch) {
        update_branch(null, null);
      }
    }, flags);
    if (hydrating) {
      anchor = hydrate_node;
    }
  }

  // node_modules/svelte/src/internal/client/dom/blocks/each.js
  var current_each_item = null;
  function set_current_each_item(item) {
    current_each_item = item;
  }
  function index2(_, i) {
    return i;
  }
  function pause_effects(state2, items, controlled_anchor, items_map) {
    var transitions = [];
    var length2 = items.length;
    for (var i = 0; i < length2; i++) {
      pause_children(items[i].e, transitions, true);
    }
    var is_controlled = length2 > 0 && transitions.length === 0 && controlled_anchor !== null;
    if (is_controlled) {
      var parent_node = (
        /** @type {Element} */
        /** @type {Element} */
        controlled_anchor.parentNode
      );
      clear_text_content(parent_node);
      parent_node.append(
        /** @type {Element} */
        controlled_anchor
      );
      items_map.clear();
      link(state2, items[0].prev, items[length2 - 1].next);
    }
    run_out_transitions(transitions, () => {
      for (var i2 = 0; i2 < length2; i2++) {
        var item = items[i2];
        if (!is_controlled) {
          items_map.delete(item.k);
          link(state2, item.prev, item.next);
        }
        destroy_effect(item.e, !is_controlled);
      }
    });
  }
  function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
    var anchor = node;
    var state2 = { flags, items: /* @__PURE__ */ new Map(), first: null };
    var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;
    if (is_controlled) {
      var parent_node = (
        /** @type {Element} */
        node
      );
      anchor = hydrating ? set_hydrate_node(
        /** @type {Comment | Text} */
        get_first_child(parent_node)
      ) : parent_node.appendChild(create_text());
    }
    if (hydrating) {
      hydrate_next();
    }
    var fallback2 = null;
    var was_empty = false;
    var each_array = derived_safe_equal(() => {
      var collection = get_collection();
      return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
    });
    block(() => {
      var array = get(each_array);
      var length2 = array.length;
      if (was_empty && length2 === 0) {
        return;
      }
      was_empty = length2 === 0;
      let mismatch = false;
      if (hydrating) {
        var is_else = (
          /** @type {Comment} */
          anchor.data === HYDRATION_START_ELSE
        );
        if (is_else !== (length2 === 0)) {
          anchor = remove_nodes();
          set_hydrate_node(anchor);
          set_hydrating(false);
          mismatch = true;
        }
      }
      if (hydrating) {
        var prev = null;
        var item;
        for (var i = 0; i < length2; i++) {
          if (hydrate_node.nodeType === 8 && /** @type {Comment} */
          hydrate_node.data === HYDRATION_END) {
            anchor = /** @type {Comment} */
            hydrate_node;
            mismatch = true;
            set_hydrating(false);
            break;
          }
          var value2 = array[i];
          var key = get_key(value2, i);
          item = create_item(
            hydrate_node,
            state2,
            prev,
            null,
            value2,
            key,
            i,
            render_fn,
            flags,
            get_collection
          );
          state2.items.set(key, item);
          prev = item;
        }
        if (length2 > 0) {
          set_hydrate_node(remove_nodes());
        }
      }
      if (!hydrating) {
        reconcile(array, state2, anchor, render_fn, flags, get_key, get_collection);
      }
      if (fallback_fn !== null) {
        if (length2 === 0) {
          if (fallback2) {
            resume_effect(fallback2);
          } else {
            fallback2 = branch(() => fallback_fn(anchor));
          }
        } else if (fallback2 !== null) {
          pause_effect(fallback2, () => {
            fallback2 = null;
          });
        }
      }
      if (mismatch) {
        set_hydrating(true);
      }
      get(each_array);
    });
    if (hydrating) {
      anchor = hydrate_node;
    }
  }
  function reconcile(array, state2, anchor, render_fn, flags, get_key, get_collection) {
    var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
    var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;
    var length2 = array.length;
    var items = state2.items;
    var first = state2.first;
    var current = first;
    var seen;
    var prev = null;
    var to_animate;
    var matched = [];
    var stashed = [];
    var value2;
    var key;
    var item;
    var i;
    if (is_animated) {
      for (i = 0; i < length2; i += 1) {
        value2 = array[i];
        key = get_key(value2, i);
        item = items.get(key);
        if (item !== void 0) {
          item.a?.measure();
          (to_animate ?? (to_animate = /* @__PURE__ */ new Set())).add(item);
        }
      }
    }
    for (i = 0; i < length2; i += 1) {
      value2 = array[i];
      key = get_key(value2, i);
      item = items.get(key);
      if (item === void 0) {
        var child_anchor = current ? (
          /** @type {TemplateNode} */
          current.e.nodes_start
        ) : anchor;
        prev = create_item(
          child_anchor,
          state2,
          prev,
          prev === null ? state2.first : prev.next,
          value2,
          key,
          i,
          render_fn,
          flags,
          get_collection
        );
        items.set(key, prev);
        matched = [];
        stashed = [];
        current = prev.next;
        continue;
      }
      if (should_update) {
        update_item(item, value2, i, flags);
      }
      if ((item.e.f & INERT) !== 0) {
        resume_effect(item.e);
        if (is_animated) {
          item.a?.unfix();
          (to_animate ?? (to_animate = /* @__PURE__ */ new Set())).delete(item);
        }
      }
      if (item !== current) {
        if (seen !== void 0 && seen.has(item)) {
          if (matched.length < stashed.length) {
            var start = stashed[0];
            var j;
            prev = start.prev;
            var a = matched[0];
            var b = matched[matched.length - 1];
            for (j = 0; j < matched.length; j += 1) {
              move(matched[j], start, anchor);
            }
            for (j = 0; j < stashed.length; j += 1) {
              seen.delete(stashed[j]);
            }
            link(state2, a.prev, b.next);
            link(state2, prev, a);
            link(state2, b, start);
            current = start;
            prev = b;
            i -= 1;
            matched = [];
            stashed = [];
          } else {
            seen.delete(item);
            move(item, current, anchor);
            link(state2, item.prev, item.next);
            link(state2, item, prev === null ? state2.first : prev.next);
            link(state2, prev, item);
            prev = item;
          }
          continue;
        }
        matched = [];
        stashed = [];
        while (current !== null && current.k !== key) {
          if ((current.e.f & INERT) === 0) {
            (seen ?? (seen = /* @__PURE__ */ new Set())).add(current);
          }
          stashed.push(current);
          current = current.next;
        }
        if (current === null) {
          continue;
        }
        item = current;
      }
      matched.push(item);
      prev = item;
      current = item.next;
    }
    if (current !== null || seen !== void 0) {
      var to_destroy = seen === void 0 ? [] : array_from(seen);
      while (current !== null) {
        if ((current.e.f & INERT) === 0) {
          to_destroy.push(current);
        }
        current = current.next;
      }
      var destroy_length = to_destroy.length;
      if (destroy_length > 0) {
        var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length2 === 0 ? anchor : null;
        if (is_animated) {
          for (i = 0; i < destroy_length; i += 1) {
            to_destroy[i].a?.measure();
          }
          for (i = 0; i < destroy_length; i += 1) {
            to_destroy[i].a?.fix();
          }
        }
        pause_effects(state2, to_destroy, controlled_anchor, items);
      }
    }
    if (is_animated) {
      queue_micro_task(() => {
        if (to_animate === void 0) return;
        for (item of to_animate) {
          item.a?.apply();
        }
      });
    }
    active_effect.first = state2.first && state2.first.e;
    active_effect.last = prev && prev.e;
  }
  function update_item(item, value2, index5, type) {
    if ((type & EACH_ITEM_REACTIVE) !== 0) {
      internal_set(item.v, value2);
    }
    if ((type & EACH_INDEX_REACTIVE) !== 0) {
      internal_set(
        /** @type {Value<number>} */
        item.i,
        index5
      );
    } else {
      item.i = index5;
    }
  }
  function create_item(anchor, state2, prev, next2, value2, key, index5, render_fn, flags, get_collection) {
    var previous_each_item = current_each_item;
    var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
    var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;
    var v = reactive ? mutable ? mutable_source(value2) : source(value2) : value2;
    var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index5 : source(index5);
    if (true_default && reactive) {
      v.debug = () => {
        var collection_index = typeof i === "number" ? index5 : i.v;
        get_collection()[collection_index];
      };
    }
    var item = {
      i,
      v,
      k: key,
      a: null,
      // @ts-expect-error
      e: null,
      prev,
      next: next2
    };
    current_each_item = item;
    try {
      item.e = branch(() => render_fn(anchor, v, i, get_collection), hydrating);
      item.e.prev = prev && prev.e;
      item.e.next = next2 && next2.e;
      if (prev === null) {
        state2.first = item;
      } else {
        prev.next = item;
        prev.e.next = item.e;
      }
      if (next2 !== null) {
        next2.prev = item;
        next2.e.prev = item.e;
      }
      return item;
    } finally {
      current_each_item = previous_each_item;
    }
  }
  function move(item, next2, anchor) {
    var end = item.next ? (
      /** @type {TemplateNode} */
      item.next.e.nodes_start
    ) : anchor;
    var dest = next2 ? (
      /** @type {TemplateNode} */
      next2.e.nodes_start
    ) : anchor;
    var node = (
      /** @type {TemplateNode} */
      item.e.nodes_start
    );
    while (node !== end) {
      var next_node = (
        /** @type {TemplateNode} */
        get_next_sibling(node)
      );
      dest.before(node);
      node = next_node;
    }
  }
  function link(state2, prev, next2) {
    if (prev === null) {
      state2.first = next2;
    } else {
      prev.next = next2;
      prev.e.next = next2 && next2.e;
    }
    if (next2 !== null) {
      next2.prev = prev;
      next2.e.prev = prev && prev.e;
    }
  }

  // node_modules/svelte/src/internal/client/dom/blocks/html.js
  function check_hash(element2, server_hash, value2) {
    if (!server_hash || server_hash === hash(String(value2 ?? ""))) return;
    let location;
    const loc = element2.__svelte_meta?.loc;
    if (loc) {
      location = `near ${loc.file}:${loc.line}:${loc.column}`;
    } else if (dev_current_component_function?.[FILENAME]) {
      location = `in ${dev_current_component_function[FILENAME]}`;
    }
    hydration_html_changed(sanitize_location(location));
  }
  function html(node, get_value, svg, mathml, skip_warning) {
    var anchor = node;
    var value2 = "";
    var effect2;
    block(() => {
      if (value2 === (value2 = get_value() ?? "")) {
        if (hydrating) {
          hydrate_next();
        }
        return;
      }
      if (effect2 !== void 0) {
        destroy_effect(effect2);
        effect2 = void 0;
      }
      if (value2 === "") return;
      effect2 = branch(() => {
        if (hydrating) {
          var hash2 = (
            /** @type {Comment} */
            hydrate_node.data
          );
          var next2 = hydrate_next();
          var last = next2;
          while (next2 !== null && (next2.nodeType !== 8 || /** @type {Comment} */
          next2.data !== "")) {
            last = next2;
            next2 = /** @type {TemplateNode} */
            get_next_sibling(next2);
          }
          if (next2 === null) {
            hydration_mismatch();
            throw HYDRATION_ERROR;
          }
          if (true_default && !skip_warning) {
            check_hash(
              /** @type {Element} */
              next2.parentNode,
              hash2,
              value2
            );
          }
          assign_nodes(hydrate_node, last);
          anchor = set_hydrate_node(next2);
          return;
        }
        var html3 = value2 + "";
        if (svg) html3 = `<svg>${html3}</svg>`;
        else if (mathml) html3 = `<math>${html3}</math>`;
        var node2 = create_fragment_from_html(html3);
        if (svg || mathml) {
          node2 = /** @type {Element} */
          get_first_child(node2);
        }
        assign_nodes(
          /** @type {TemplateNode} */
          get_first_child(node2),
          /** @type {TemplateNode} */
          node2.lastChild
        );
        if (svg || mathml) {
          while (get_first_child(node2)) {
            anchor.before(
              /** @type {Node} */
              get_first_child(node2)
            );
          }
        } else {
          anchor.before(node2);
        }
      });
    });
  }

  // node_modules/svelte/src/internal/client/dom/blocks/slot.js
  function slot(anchor, $$props, name, slot_props, fallback_fn) {
    if (hydrating) {
      hydrate_next();
    }
    var slot_fn = $$props.$$slots?.[name];
    var is_interop = false;
    if (slot_fn === true) {
      slot_fn = $$props[name === "default" ? "children" : name];
      is_interop = true;
    }
    if (slot_fn === void 0) {
      if (fallback_fn !== null) {
        fallback_fn(anchor);
      }
    } else {
      slot_fn(anchor, is_interop ? () => slot_props : slot_props);
    }
  }
  function sanitize_slots(props) {
    const sanitized = {};
    if (props.children) sanitized.default = true;
    for (const key in props.$$slots) {
      sanitized[key] = true;
    }
    return sanitized;
  }

  // node_modules/svelte/src/internal/client/dom/blocks/snippet.js
  function wrap_snippet(component2, fn) {
    return (node, ...args) => {
      var previous_component_function = dev_current_component_function;
      set_dev_current_component_function(component2);
      try {
        return fn(node, ...args);
      } finally {
        set_dev_current_component_function(previous_component_function);
      }
    };
  }
  function createRawSnippet(fn) {
    return (anchor, ...params) => {
      var snippet2 = fn(...params);
      var element2;
      if (hydrating) {
        element2 = /** @type {Element} */
        hydrate_node;
        hydrate_next();
      } else {
        var html3 = snippet2.render().trim();
        var fragment = create_fragment_from_html(html3);
        element2 = /** @type {Element} */
        get_first_child(fragment);
        if (true_default && (get_next_sibling(element2) !== null || element2.nodeType !== 1)) {
          invalid_raw_snippet_render();
        }
        anchor.before(element2);
      }
      const result = snippet2.setup?.(element2);
      assign_nodes(element2, element2);
      if (typeof result === "function") {
        teardown(result);
      }
    };
  }

  // node_modules/svelte/src/internal/client/dom/blocks/svelte-element.js
  function element(node, get_tag, is_svg, render_fn, get_namespace, location) {
    let was_hydrating = hydrating;
    if (hydrating) {
      hydrate_next();
    }
    var filename = true_default && location && component_context?.function[FILENAME];
    var tag;
    var current_tag;
    var element2 = null;
    if (hydrating && hydrate_node.nodeType === 1) {
      element2 = /** @type {Element} */
      hydrate_node;
      hydrate_next();
    }
    var anchor = (
      /** @type {TemplateNode} */
      hydrating ? hydrate_node : node
    );
    var effect2;
    var each_item_block = current_each_item;
    block(() => {
      const next_tag = get_tag() || null;
      var ns = get_namespace ? get_namespace() : is_svg || next_tag === "svg" ? NAMESPACE_SVG : null;
      if (next_tag === tag) return;
      var previous_each_item = current_each_item;
      set_current_each_item(each_item_block);
      if (effect2) {
        if (next_tag === null) {
          pause_effect(effect2, () => {
            effect2 = null;
            current_tag = null;
          });
        } else if (next_tag === current_tag) {
          resume_effect(effect2);
        } else {
          destroy_effect(effect2);
          set_should_intro(false);
        }
      }
      if (next_tag && next_tag !== current_tag) {
        effect2 = branch(() => {
          element2 = hydrating ? (
            /** @type {Element} */
            element2
          ) : ns ? document.createElementNS(ns, next_tag) : document.createElement(next_tag);
          if (true_default && location) {
            element2.__svelte_meta = {
              loc: {
                file: filename,
                line: location[0],
                column: location[1]
              }
            };
          }
          assign_nodes(element2, element2);
          if (render_fn) {
            if (hydrating && is_raw_text_element(next_tag)) {
              element2.append(document.createComment(""));
            }
            var child_anchor = (
              /** @type {TemplateNode} */
              hydrating ? get_first_child(element2) : element2.appendChild(create_text())
            );
            if (hydrating) {
              if (child_anchor === null) {
                set_hydrating(false);
              } else {
                set_hydrate_node(child_anchor);
              }
            }
            render_fn(element2, child_anchor);
          }
          active_effect.nodes_end = element2;
          anchor.before(element2);
        });
      }
      tag = next_tag;
      if (tag) current_tag = tag;
      set_should_intro(true);
      set_current_each_item(previous_each_item);
    }, EFFECT_TRANSPARENT);
    if (was_hydrating) {
      set_hydrating(true);
      set_hydrate_node(anchor);
    }
  }

  // node_modules/svelte/src/internal/client/dom/css.js
  function append_styles2(anchor, css) {
    queue_micro_task(() => {
      var root12 = anchor.getRootNode();
      var target = (
        /** @type {ShadowRoot} */
        root12.host ? (
          /** @type {ShadowRoot} */
          root12
        ) : (
          /** @type {Document} */
          root12.head ?? /** @type {Document} */
          root12.ownerDocument.head
        )
      );
      if (!target.querySelector("#" + css.hash)) {
        const style = document.createElement("style");
        style.id = css.hash;
        style.textContent = css.code;
        target.appendChild(style);
        if (true_default) {
          register_style(css.hash, style);
        }
      }
    });
  }

  // node_modules/svelte/src/internal/client/dom/elements/actions.js
  function action(dom, action2, get_value) {
    effect(() => {
      var payload = untrack(() => action2(dom, get_value?.()) || {});
      if (get_value && payload?.update) {
        var inited = false;
        var prev = (
          /** @type {any} */
          {}
        );
        render_effect(() => {
          var value2 = get_value();
          deep_read_state(value2);
          if (inited && safe_not_equal(prev, value2)) {
            prev = value2;
            payload.update(value2);
          }
        });
        inited = true;
      }
      if (payload?.destroy) {
        return () => (
          /** @type {Function} */
          payload.destroy()
        );
      }
    });
  }

  // node_modules/svelte/src/internal/client/dom/elements/class.js
  function set_class(dom, is_html, value2, hash2, prev_classes, next_classes) {
    var prev = dom.__className;
    if (hydrating || prev !== value2) {
      var next_class_name = to_class(value2, hash2, next_classes);
      if (!hydrating || next_class_name !== dom.getAttribute("class")) {
        if (next_class_name == null) {
          dom.removeAttribute("class");
        } else if (is_html) {
          dom.className = next_class_name;
        } else {
          dom.setAttribute("class", next_class_name);
        }
      }
      dom.__className = value2;
    } else if (next_classes && prev_classes !== next_classes) {
      for (var key in next_classes) {
        var is_present = !!next_classes[key];
        if (prev_classes == null || is_present !== !!prev_classes[key]) {
          dom.classList.toggle(key, is_present);
        }
      }
    }
    return next_classes;
  }

  // node_modules/svelte/src/internal/client/dom/elements/style.js
  function update_styles(dom, prev = {}, next2, priority) {
    for (var key in next2) {
      var value2 = next2[key];
      if (prev[key] !== value2) {
        if (next2[key] == null) {
          dom.style.removeProperty(key);
        } else {
          dom.style.setProperty(key, value2, priority);
        }
      }
    }
  }
  function set_style(dom, value2, prev_styles, next_styles) {
    var prev = dom.__style;
    if (hydrating || prev !== value2) {
      var next_style_attr = to_style(value2, next_styles);
      if (!hydrating || next_style_attr !== dom.getAttribute("style")) {
        if (next_style_attr == null) {
          dom.removeAttribute("style");
        } else {
          dom.style.cssText = next_style_attr;
        }
      }
      dom.__style = value2;
    } else if (next_styles) {
      if (Array.isArray(next_styles)) {
        update_styles(dom, prev_styles?.[0], next_styles[0]);
        update_styles(dom, prev_styles?.[1], next_styles[1], "important");
      } else {
        update_styles(dom, prev_styles, next_styles);
      }
    }
    return next_styles;
  }

  // node_modules/svelte/src/internal/client/dom/elements/attributes.js
  var CLASS = Symbol("class");
  var STYLE = Symbol("style");
  var IS_CUSTOM_ELEMENT = Symbol("is custom element");
  var IS_HTML = Symbol("is html");
  function remove_input_defaults(input) {
    if (!hydrating) return;
    var already_removed = false;
    var remove_defaults = () => {
      if (already_removed) return;
      already_removed = true;
      if (input.hasAttribute("value")) {
        var value2 = input.value;
        set_attribute(input, "value", null);
        input.value = value2;
      }
      if (input.hasAttribute("checked")) {
        var checked = input.checked;
        set_attribute(input, "checked", null);
        input.checked = checked;
      }
    };
    input.__on_r = remove_defaults;
    queue_idle_task(remove_defaults);
    add_form_reset_listener();
  }
  function set_value(element2, value2) {
    var attributes = get_attributes(element2);
    if (attributes.value === (attributes.value = // treat null and undefined the same for the initial value
    value2 ?? void 0) || // @ts-expect-error
    // `progress` elements always need their value set when it's `0`
    element2.value === value2 && (value2 !== 0 || element2.nodeName !== "PROGRESS")) {
      return;
    }
    element2.value = value2 ?? "";
  }
  function set_selected(element2, selected) {
    if (selected) {
      if (!element2.hasAttribute("selected")) {
        element2.setAttribute("selected", "");
      }
    } else {
      element2.removeAttribute("selected");
    }
  }
  function set_attribute(element2, attribute, value2, skip_warning) {
    var attributes = get_attributes(element2);
    if (hydrating) {
      attributes[attribute] = element2.getAttribute(attribute);
      if (attribute === "src" || attribute === "srcset" || attribute === "href" && element2.nodeName === "LINK") {
        if (!skip_warning) {
          check_src_in_dev_hydration(element2, attribute, value2 ?? "");
        }
        return;
      }
    }
    if (attributes[attribute] === (attributes[attribute] = value2)) return;
    if (attribute === "loading") {
      element2[LOADING_ATTR_SYMBOL] = value2;
    }
    if (value2 == null) {
      element2.removeAttribute(attribute);
    } else if (typeof value2 !== "string" && get_setters(element2).includes(attribute)) {
      element2[attribute] = value2;
    } else {
      element2.setAttribute(attribute, value2);
    }
  }
  function set_attributes(element2, prev, next2, css_hash, skip_warning = false) {
    var attributes = get_attributes(element2);
    var is_custom_element = attributes[IS_CUSTOM_ELEMENT];
    var preserve_attribute_case = !attributes[IS_HTML];
    let is_hydrating_custom_element = hydrating && is_custom_element;
    if (is_hydrating_custom_element) {
      set_hydrating(false);
    }
    var current = prev || {};
    var is_option_element = element2.tagName === "OPTION";
    for (var key in prev) {
      if (!(key in next2)) {
        next2[key] = null;
      }
    }
    if (next2.class) {
      next2.class = clsx2(next2.class);
    } else if (css_hash || next2[CLASS]) {
      next2.class = null;
    }
    if (next2[STYLE]) {
      next2.style ?? (next2.style = null);
    }
    var setters = get_setters(element2);
    for (const key2 in next2) {
      let value2 = next2[key2];
      if (is_option_element && key2 === "value" && value2 == null) {
        element2.value = element2.__value = "";
        current[key2] = value2;
        continue;
      }
      if (key2 === "class") {
        var is_html = element2.namespaceURI === "http://www.w3.org/1999/xhtml";
        set_class(element2, is_html, value2, css_hash, prev?.[CLASS], next2[CLASS]);
        current[key2] = value2;
        current[CLASS] = next2[CLASS];
        continue;
      }
      if (key2 === "style") {
        set_style(element2, value2, prev?.[STYLE], next2[STYLE]);
        current[key2] = value2;
        current[STYLE] = next2[STYLE];
        continue;
      }
      var prev_value = current[key2];
      if (value2 === prev_value) continue;
      current[key2] = value2;
      var prefix3 = key2[0] + key2[1];
      if (prefix3 === "$$") continue;
      if (prefix3 === "on") {
        const opts = {};
        const event_handle_key = "$$" + key2;
        let event_name = key2.slice(2);
        var delegated = is_delegated(event_name);
        if (is_capture_event(event_name)) {
          event_name = event_name.slice(0, -7);
          opts.capture = true;
        }
        if (!delegated && prev_value) {
          if (value2 != null) continue;
          element2.removeEventListener(event_name, current[event_handle_key], opts);
          current[event_handle_key] = null;
        }
        if (value2 != null) {
          if (!delegated) {
            let handle = function(evt) {
              current[key2].call(this, evt);
            };
            current[event_handle_key] = create_event(event_name, element2, handle, opts);
          } else {
            element2[`__${event_name}`] = value2;
            delegate([event_name]);
          }
        } else if (delegated) {
          element2[`__${event_name}`] = void 0;
        }
      } else if (key2 === "style") {
        set_attribute(element2, key2, value2);
      } else if (key2 === "autofocus") {
        autofocus(
          /** @type {HTMLElement} */
          element2,
          Boolean(value2)
        );
      } else if (!is_custom_element && (key2 === "__value" || key2 === "value" && value2 != null)) {
        element2.value = element2.__value = value2;
      } else if (key2 === "selected" && is_option_element) {
        set_selected(
          /** @type {HTMLOptionElement} */
          element2,
          value2
        );
      } else {
        var name = key2;
        if (!preserve_attribute_case) {
          name = normalize_attribute(name);
        }
        var is_default = name === "defaultValue" || name === "defaultChecked";
        if (value2 == null && !is_custom_element && !is_default) {
          attributes[key2] = null;
          if (name === "value" || name === "checked") {
            let input = (
              /** @type {HTMLInputElement} */
              element2
            );
            const use_default = prev === void 0;
            if (name === "value") {
              let previous = input.defaultValue;
              input.removeAttribute(name);
              input.defaultValue = previous;
              input.value = input.__value = use_default ? previous : null;
            } else {
              let previous = input.defaultChecked;
              input.removeAttribute(name);
              input.defaultChecked = previous;
              input.checked = use_default ? previous : false;
            }
          } else {
            element2.removeAttribute(key2);
          }
        } else if (is_default || setters.includes(name) && (is_custom_element || typeof value2 !== "string")) {
          element2[name] = value2;
        } else if (typeof value2 !== "function") {
          set_attribute(element2, name, value2, skip_warning);
        }
      }
    }
    if (is_hydrating_custom_element) {
      set_hydrating(true);
    }
    return current;
  }
  function get_attributes(element2) {
    return (
      /** @type {Record<string | symbol, unknown>} **/
      // @ts-expect-error
      element2.__attributes ?? (element2.__attributes = {
        [IS_CUSTOM_ELEMENT]: element2.nodeName.includes("-"),
        [IS_HTML]: element2.namespaceURI === NAMESPACE_HTML
      })
    );
  }
  var setters_cache = /* @__PURE__ */ new Map();
  function get_setters(element2) {
    var setters = setters_cache.get(element2.nodeName);
    if (setters) return setters;
    setters_cache.set(element2.nodeName, setters = []);
    var descriptors;
    var proto = element2;
    var element_proto = Element.prototype;
    while (element_proto !== proto) {
      descriptors = get_descriptors(proto);
      for (var key in descriptors) {
        if (descriptors[key].set) {
          setters.push(key);
        }
      }
      proto = get_prototype_of(proto);
    }
    return setters;
  }
  function check_src_in_dev_hydration(element2, attribute, value2) {
    if (!true_default) return;
    if (attribute === "srcset" && srcset_url_equal(element2, value2)) return;
    if (src_url_equal(element2.getAttribute(attribute) ?? "", value2)) return;
    hydration_attribute_changed(
      attribute,
      element2.outerHTML.replace(element2.innerHTML, element2.innerHTML && "..."),
      String(value2)
    );
  }
  function src_url_equal(element_src, url2) {
    if (element_src === url2) return true;
    return new URL(element_src, document.baseURI).href === new URL(url2, document.baseURI).href;
  }
  function split_srcset(srcset) {
    return srcset.split(",").map((src) => src.trim().split(" ").filter(Boolean));
  }
  function srcset_url_equal(element2, srcset) {
    var element_urls = split_srcset(element2.srcset);
    var urls = split_srcset(srcset);
    return urls.length === element_urls.length && urls.every(
      ([url2, width], i) => width === element_urls[i][1] && // We need to test both ways because Vite will create an a full URL with
      // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
      // relative URLs inside srcset are not automatically resolved to absolute URLs by
      // browsers (in contrast to img.src). This means both SSR and DOM code could
      // contain relative or absolute URLs.
      (src_url_equal(element_urls[i][0], url2) || src_url_equal(url2, element_urls[i][0]))
    );
  }

  // node_modules/svelte/src/internal/client/timing.js
  var now = true_default ? () => performance.now() : () => Date.now();
  var raf = {
    // don't access requestAnimationFrame eagerly outside method
    // this allows basic testing of user code without JSDOM
    // bunder will eval and remove ternary when the user's app is built
    tick: (
      /** @param {any} _ */
      (_) => (true_default ? requestAnimationFrame : noop)(_)
    ),
    now: () => now(),
    tasks: /* @__PURE__ */ new Set()
  };

  // node_modules/svelte/src/internal/client/loop.js
  function run_tasks() {
    const now2 = raf.now();
    raf.tasks.forEach((task) => {
      if (!task.c(now2)) {
        raf.tasks.delete(task);
        task.f();
      }
    });
    if (raf.tasks.size !== 0) {
      raf.tick(run_tasks);
    }
  }
  function loop(callback) {
    let task;
    if (raf.tasks.size === 0) {
      raf.tick(run_tasks);
    }
    return {
      promise: new Promise((fulfill) => {
        raf.tasks.add(task = { c: callback, f: fulfill });
      }),
      abort() {
        raf.tasks.delete(task);
      }
    };
  }

  // node_modules/svelte/src/internal/client/dom/elements/transitions.js
  function dispatch_event(element2, type) {
    without_reactive_context(() => {
      element2.dispatchEvent(new CustomEvent(type));
    });
  }
  function css_property_to_camelcase(style) {
    if (style === "float") return "cssFloat";
    if (style === "offset") return "cssOffset";
    if (style.startsWith("--")) return style;
    const parts = style.split("-");
    if (parts.length === 1) return parts[0];
    return parts[0] + parts.slice(1).map(
      /** @param {any} word */
      (word) => word[0].toUpperCase() + word.slice(1)
    ).join("");
  }
  function css_to_keyframe(css) {
    const keyframe = {};
    const parts = css.split(";");
    for (const part of parts) {
      const [property, value2] = part.split(":");
      if (!property || value2 === void 0) break;
      const formatted_property = css_property_to_camelcase(property.trim());
      keyframe[formatted_property] = value2.trim();
    }
    return keyframe;
  }
  var linear = (t) => t;
  function transition(flags, element2, get_fn, get_params) {
    var is_intro = (flags & TRANSITION_IN) !== 0;
    var is_outro = (flags & TRANSITION_OUT) !== 0;
    var is_both = is_intro && is_outro;
    var is_global = (flags & TRANSITION_GLOBAL) !== 0;
    var direction = is_both ? "both" : is_intro ? "in" : "out";
    var current_options;
    var inert = element2.inert;
    var overflow = element2.style.overflow;
    var intro;
    var outro;
    function get_options() {
      var previous_reaction = active_reaction;
      var previous_effect = active_effect;
      set_active_reaction(null);
      set_active_effect(null);
      try {
        return current_options ?? (current_options = get_fn()(element2, get_params?.() ?? /** @type {P} */
        {}, {
          direction
        }));
      } finally {
        set_active_reaction(previous_reaction);
        set_active_effect(previous_effect);
      }
    }
    var transition2 = {
      is_global,
      in() {
        element2.inert = inert;
        if (!is_intro) {
          outro?.abort();
          outro?.reset?.();
          return;
        }
        if (!is_outro) {
          intro?.abort();
        }
        dispatch_event(element2, "introstart");
        intro = animate(element2, get_options(), outro, 1, () => {
          dispatch_event(element2, "introend");
          intro?.abort();
          intro = current_options = void 0;
          element2.style.overflow = overflow;
        });
      },
      out(fn) {
        if (!is_outro) {
          fn?.();
          current_options = void 0;
          return;
        }
        element2.inert = true;
        dispatch_event(element2, "outrostart");
        outro = animate(element2, get_options(), intro, 0, () => {
          dispatch_event(element2, "outroend");
          fn?.();
        });
      },
      stop: () => {
        intro?.abort();
        outro?.abort();
      }
    };
    var e = (
      /** @type {Effect} */
      active_effect
    );
    (e.transitions ?? (e.transitions = [])).push(transition2);
    if (is_intro && should_intro) {
      var run2 = is_global;
      if (!run2) {
        var block2 = (
          /** @type {Effect | null} */
          e.parent
        );
        while (block2 && (block2.f & EFFECT_TRANSPARENT) !== 0) {
          while (block2 = block2.parent) {
            if ((block2.f & BLOCK_EFFECT) !== 0) break;
          }
        }
        run2 = !block2 || (block2.f & EFFECT_RAN) !== 0;
      }
      if (run2) {
        effect(() => {
          untrack(() => transition2.in());
        });
      }
    }
  }
  function animate(element2, options, counterpart, t2, on_finish) {
    var is_intro = t2 === 1;
    if (is_function(options)) {
      var a;
      var aborted = false;
      queue_micro_task(() => {
        if (aborted) return;
        var o = options({ direction: is_intro ? "in" : "out" });
        a = animate(element2, o, counterpart, t2, on_finish);
      });
      return {
        abort: () => {
          aborted = true;
          a?.abort();
        },
        deactivate: () => a.deactivate(),
        reset: () => a.reset(),
        t: () => a.t()
      };
    }
    counterpart?.deactivate();
    if (!options?.duration) {
      on_finish();
      return {
        abort: noop,
        deactivate: noop,
        reset: noop,
        t: () => t2
      };
    }
    const { delay = 0, css, tick: tick2, easing = linear } = options;
    var keyframes = [];
    if (is_intro && counterpart === void 0) {
      if (tick2) {
        tick2(0, 1);
      }
      if (css) {
        var styles = css_to_keyframe(css(0, 1));
        keyframes.push(styles, styles);
      }
    }
    var get_t = () => 1 - t2;
    var animation2 = element2.animate(keyframes, { duration: delay });
    animation2.onfinish = () => {
      var t1 = counterpart?.t() ?? 1 - t2;
      counterpart?.abort();
      var delta = t2 - t1;
      var duration = (
        /** @type {number} */
        options.duration * Math.abs(delta)
      );
      var keyframes2 = [];
      if (duration > 0) {
        var needs_overflow_hidden = false;
        if (css) {
          var n = Math.ceil(duration / (1e3 / 60));
          for (var i = 0; i <= n; i += 1) {
            var t = t1 + delta * easing(i / n);
            var styles2 = css_to_keyframe(css(t, 1 - t));
            keyframes2.push(styles2);
            needs_overflow_hidden || (needs_overflow_hidden = styles2.overflow === "hidden");
          }
        }
        if (needs_overflow_hidden) {
          element2.style.overflow = "hidden";
        }
        get_t = () => {
          var time = (
            /** @type {number} */
            /** @type {globalThis.Animation} */
            animation2.currentTime
          );
          return t1 + delta * easing(time / duration);
        };
        if (tick2) {
          loop(() => {
            if (animation2.playState !== "running") return false;
            var t3 = get_t();
            tick2(t3, 1 - t3);
            return true;
          });
        }
      }
      animation2 = element2.animate(keyframes2, { duration, fill: "forwards" });
      animation2.onfinish = () => {
        get_t = () => t2;
        tick2?.(t2, 1 - t2);
        on_finish();
      };
    };
    return {
      abort: () => {
        if (animation2) {
          animation2.cancel();
          animation2.effect = null;
          animation2.onfinish = noop;
        }
      },
      deactivate: () => {
        on_finish = noop;
      },
      reset: () => {
        if (t2 === 0) {
          tick2?.(1, 0);
        }
      },
      t: () => get_t()
    };
  }

  // node_modules/svelte/src/internal/client/dom/elements/bindings/this.js
  function is_bound_this(bound_value, element_or_component) {
    return bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component;
  }
  function bind_this(element_or_component = {}, update2, get_value, get_parts) {
    effect(() => {
      var old_parts;
      var parts;
      render_effect(() => {
        old_parts = parts;
        parts = get_parts?.() || [];
        untrack(() => {
          if (element_or_component !== get_value(...parts)) {
            update2(element_or_component, ...parts);
            if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
              update2(null, ...old_parts);
            }
          }
        });
      });
      return () => {
        queue_micro_task(() => {
          if (parts && is_bound_this(get_value(...parts), element_or_component)) {
            update2(null, ...parts);
          }
        });
      };
    });
    return element_or_component;
  }

  // node_modules/svelte/src/internal/client/dom/legacy/event-modifiers.js
  function stopPropagation(fn) {
    return function(...args) {
      var event2 = (
        /** @type {Event} */
        args[0]
      );
      event2.stopPropagation();
      return fn?.apply(this, args);
    };
  }
  function preventDefault(fn) {
    return function(...args) {
      var event2 = (
        /** @type {Event} */
        args[0]
      );
      event2.preventDefault();
      return fn?.apply(this, args);
    };
  }

  // node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js
  function init2(immutable = false) {
    const context = (
      /** @type {ComponentContextLegacy} */
      component_context
    );
    const callbacks = context.l.u;
    if (!callbacks) return;
    let props = () => deep_read_state(context.s);
    if (immutable) {
      let version2 = 0;
      let prev = (
        /** @type {Record<string, any>} */
        {}
      );
      const d = derived(() => {
        let changed = false;
        const props2 = context.s;
        for (const key in props2) {
          if (props2[key] !== prev[key]) {
            prev[key] = props2[key];
            changed = true;
          }
        }
        if (changed) version2++;
        return version2;
      });
      props = () => get(d);
    }
    if (callbacks.b.length) {
      user_pre_effect(() => {
        observe_all(context, props);
        run_all(callbacks.b);
      });
    }
    user_effect(() => {
      const fns = untrack(() => callbacks.m.map(run));
      return () => {
        for (const fn of fns) {
          if (typeof fn === "function") {
            fn();
          }
        }
      };
    });
    if (callbacks.a.length) {
      user_effect(() => {
        observe_all(context, props);
        run_all(callbacks.a);
      });
    }
  }
  function observe_all(context, props) {
    if (context.l.s) {
      for (const signal of context.l.s) get(signal);
    }
    props();
  }

  // node_modules/svelte/src/store/shared/index.js
  var subscriber_queue = [];
  function readable(value2, start) {
    return {
      subscribe: writable(value2, start).subscribe
    };
  }
  function writable(value2, start = noop) {
    let stop = null;
    const subscribers = /* @__PURE__ */ new Set();
    function set2(new_value) {
      if (safe_not_equal(value2, new_value)) {
        value2 = new_value;
        if (stop) {
          const run_queue = !subscriber_queue.length;
          for (const subscriber of subscribers) {
            subscriber[1]();
            subscriber_queue.push(subscriber, value2);
          }
          if (run_queue) {
            for (let i = 0; i < subscriber_queue.length; i += 2) {
              subscriber_queue[i][0](subscriber_queue[i + 1]);
            }
            subscriber_queue.length = 0;
          }
        }
      }
    }
    function update2(fn) {
      set2(fn(
        /** @type {T} */
        value2
      ));
    }
    function subscribe(run2, invalidate = noop) {
      const subscriber = [run2, invalidate];
      subscribers.add(subscriber);
      if (subscribers.size === 1) {
        stop = start(set2, update2) || noop;
      }
      run2(
        /** @type {T} */
        value2
      );
      return () => {
        subscribers.delete(subscriber);
        if (subscribers.size === 0 && stop) {
          stop();
          stop = null;
        }
      };
    }
    return { set: set2, update: update2, subscribe };
  }
  function derived2(stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single ? [stores] : stores;
    if (!stores_array.every(Boolean)) {
      throw new Error("derived() expects stores as input, got a falsy value");
    }
    const auto = fn.length < 2;
    return readable(initial_value, (set2, update2) => {
      let started = false;
      const values = [];
      let pending = 0;
      let cleanup = noop;
      const sync2 = () => {
        if (pending) {
          return;
        }
        cleanup();
        const result = fn(single ? values[0] : values, set2, update2);
        if (auto) {
          set2(result);
        } else {
          cleanup = typeof result === "function" ? result : noop;
        }
      };
      const unsubscribers = stores_array.map(
        (store, i) => subscribe_to_store(
          store,
          (value2) => {
            values[i] = value2;
            pending &= ~(1 << i);
            if (started) {
              sync2();
            }
          },
          () => {
            pending |= 1 << i;
          }
        )
      );
      started = true;
      sync2();
      return function stop() {
        run_all(unsubscribers);
        cleanup();
        started = false;
      };
    });
  }
  function get2(store) {
    let value2;
    subscribe_to_store(store, (_) => value2 = _)();
    return value2;
  }

  // node_modules/svelte/src/internal/client/reactivity/store.js
  var is_store_binding = false;
  var IS_UNMOUNTED = Symbol();
  function store_get(store, store_name, stores) {
    const entry = stores[store_name] ?? (stores[store_name] = {
      store: null,
      source: mutable_source(void 0),
      unsubscribe: noop
    });
    if (entry.store !== store && !(IS_UNMOUNTED in stores)) {
      entry.unsubscribe();
      entry.store = store ?? null;
      if (store == null) {
        entry.source.v = void 0;
        entry.unsubscribe = noop;
      } else {
        var is_synchronous_callback = true;
        entry.unsubscribe = subscribe_to_store(store, (v) => {
          if (is_synchronous_callback) {
            entry.source.v = v;
          } else {
            set(entry.source, v);
          }
        });
        is_synchronous_callback = false;
      }
    }
    if (store && IS_UNMOUNTED in stores) {
      return get2(store);
    }
    return get(entry.source);
  }
  function store_set(store, value2) {
    store.set(value2);
    return value2;
  }
  function setup_stores() {
    const stores = {};
    function cleanup() {
      teardown(() => {
        for (var store_name in stores) {
          const ref = stores[store_name];
          ref.unsubscribe();
        }
        define_property(stores, IS_UNMOUNTED, {
          enumerable: false,
          value: true
        });
      });
    }
    return [stores, cleanup];
  }
  function capture_store_binding(fn) {
    var previous_is_store_binding = is_store_binding;
    try {
      is_store_binding = false;
      return [fn(), is_store_binding];
    } finally {
      is_store_binding = previous_is_store_binding;
    }
  }

  // node_modules/svelte/src/internal/client/reactivity/props.js
  function has_destroyed_component_ctx(current_value) {
    return current_value.ctx?.d ?? false;
  }
  function prop(props, key, flags, fallback2) {
    var immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;
    var runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;
    var bindable = (flags & PROPS_IS_BINDABLE) !== 0;
    var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;
    var is_store_sub = false;
    var prop_value;
    if (bindable) {
      [prop_value, is_store_sub] = capture_store_binding(() => (
        /** @type {V} */
        props[key]
      ));
    } else {
      prop_value = /** @type {V} */
      props[key];
    }
    var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
    var setter = bindable && (get_descriptor(props, key)?.set ?? (is_entry_props && key in props && ((v) => props[key] = v))) || void 0;
    var fallback_value = (
      /** @type {V} */
      fallback2
    );
    var fallback_dirty = true;
    var fallback_used = false;
    var get_fallback = () => {
      fallback_used = true;
      if (fallback_dirty) {
        fallback_dirty = false;
        if (lazy) {
          fallback_value = untrack(
            /** @type {() => V} */
            fallback2
          );
        } else {
          fallback_value = /** @type {V} */
          fallback2;
        }
      }
      return fallback_value;
    };
    if (prop_value === void 0 && fallback2 !== void 0) {
      if (setter && runes) {
        props_invalid_value(key);
      }
      prop_value = get_fallback();
      if (setter) setter(prop_value);
    }
    var getter;
    if (runes) {
      getter = () => {
        var value2 = (
          /** @type {V} */
          props[key]
        );
        if (value2 === void 0) return get_fallback();
        fallback_dirty = true;
        fallback_used = false;
        return value2;
      };
    } else {
      var derived_getter = (immutable ? derived : derived_safe_equal)(
        () => (
          /** @type {V} */
          props[key]
        )
      );
      derived_getter.f |= LEGACY_DERIVED_PROP;
      getter = () => {
        var value2 = get(derived_getter);
        if (value2 !== void 0) fallback_value = /** @type {V} */
        void 0;
        return value2 === void 0 ? fallback_value : value2;
      };
    }
    if ((flags & PROPS_IS_UPDATED) === 0) {
      return getter;
    }
    if (setter) {
      var legacy_parent = props.$$legacy;
      return function(value2, mutation) {
        if (arguments.length > 0) {
          if (!runes || !mutation || legacy_parent || is_store_sub) {
            setter(mutation ? getter() : value2);
          }
          return value2;
        } else {
          return getter();
        }
      };
    }
    var from_child = false;
    var was_from_child = false;
    var inner_current_value = mutable_source(prop_value);
    var current_value = derived(() => {
      var parent_value = getter();
      var child_value = get(inner_current_value);
      if (from_child) {
        from_child = false;
        was_from_child = true;
        return child_value;
      }
      was_from_child = false;
      return inner_current_value.v = parent_value;
    });
    if (bindable) {
      get(current_value);
    }
    if (!immutable) current_value.equals = safe_equals;
    return function(value2, mutation) {
      if (captured_signals !== null) {
        from_child = was_from_child;
        getter();
        get(inner_current_value);
      }
      if (arguments.length > 0) {
        const new_value = mutation ? get(current_value) : runes && bindable ? proxy(value2) : value2;
        if (!current_value.equals(new_value)) {
          from_child = true;
          set(inner_current_value, new_value);
          if (fallback_used && fallback_value !== void 0) {
            fallback_value = new_value;
          }
          if (has_destroyed_component_ctx(current_value)) {
            return value2;
          }
          untrack(() => get(current_value));
        }
        return value2;
      }
      if (has_destroyed_component_ctx(current_value)) {
        return current_value.v;
      }
      return get(current_value);
    };
  }

  // node_modules/svelte/src/legacy/legacy-client.js
  function createClassComponent(options) {
    return new Svelte4Component(options);
  }
  var _events, _instance;
  var Svelte4Component = class {
    /**
     * @param {ComponentConstructorOptions & {
     *  component: any;
     * }} options
     */
    constructor(options) {
      /** @type {any} */
      __privateAdd(this, _events);
      /** @type {Record<string, any>} */
      __privateAdd(this, _instance);
      var sources = /* @__PURE__ */ new Map();
      var add_source = (key, value2) => {
        var s = mutable_source(value2);
        sources.set(key, s);
        return s;
      };
      const props = new Proxy(
        { ...options.props || {}, $$events: {} },
        {
          get(target, prop2) {
            return get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
          },
          has(target, prop2) {
            if (prop2 === LEGACY_PROPS) return true;
            get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
            return Reflect.has(target, prop2);
          },
          set(target, prop2, value2) {
            set(sources.get(prop2) ?? add_source(prop2, value2), value2);
            return Reflect.set(target, prop2, value2);
          }
        }
      );
      __privateSet(this, _instance, (options.hydrate ? hydrate : mount)(options.component, {
        target: options.target,
        anchor: options.anchor,
        props,
        context: options.context,
        intro: options.intro ?? false,
        recover: options.recover
      }));
      if (!options?.props?.$$host || options.sync === false) {
        flushSync();
      }
      __privateSet(this, _events, props.$$events);
      for (const key of Object.keys(__privateGet(this, _instance))) {
        if (key === "$set" || key === "$destroy" || key === "$on") continue;
        define_property(this, key, {
          get() {
            return __privateGet(this, _instance)[key];
          },
          /** @param {any} value */
          set(value2) {
            __privateGet(this, _instance)[key] = value2;
          },
          enumerable: true
        });
      }
      __privateGet(this, _instance).$set = /** @param {Record<string, any>} next */
      (next2) => {
        Object.assign(props, next2);
      };
      __privateGet(this, _instance).$destroy = () => {
        unmount(__privateGet(this, _instance));
      };
    }
    /** @param {Record<string, any>} props */
    $set(props) {
      __privateGet(this, _instance).$set(props);
    }
    /**
     * @param {string} event
     * @param {(...args: any[]) => any} callback
     * @returns {any}
     */
    $on(event2, callback) {
      __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2] || [];
      const cb = (...args) => callback.call(this, ...args);
      __privateGet(this, _events)[event2].push(cb);
      return () => {
        __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2].filter(
          /** @param {any} fn */
          (fn) => fn !== cb
        );
      };
    }
    $destroy() {
      __privateGet(this, _instance).$destroy();
    }
  };
  _events = new WeakMap();
  _instance = new WeakMap();

  // node_modules/svelte/src/internal/client/dom/elements/custom-element.js
  var SvelteElement;
  if (typeof HTMLElement === "function") {
    SvelteElement = class extends HTMLElement {
      /**
       * @param {*} $$componentCtor
       * @param {*} $$slots
       * @param {*} use_shadow_dom
       */
      constructor($$componentCtor, $$slots, use_shadow_dom) {
        super();
        /** The Svelte component constructor */
        __publicField(this, "$$ctor");
        /** Slots */
        __publicField(this, "$$s");
        /** @type {any} The Svelte component instance */
        __publicField(this, "$$c");
        /** Whether or not the custom element is connected */
        __publicField(this, "$$cn", false);
        /** @type {Record<string, any>} Component props data */
        __publicField(this, "$$d", {});
        /** `true` if currently in the process of reflecting component props back to attributes */
        __publicField(this, "$$r", false);
        /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
        __publicField(this, "$$p_d", {});
        /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
        __publicField(this, "$$l", {});
        /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
        __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
        /** @type {any} The managed render effect for reflecting attributes */
        __publicField(this, "$$me");
        this.$$ctor = $$componentCtor;
        this.$$s = $$slots;
        if (use_shadow_dom) {
          this.attachShadow({ mode: "open" });
        }
      }
      /**
       * @param {string} type
       * @param {EventListenerOrEventListenerObject} listener
       * @param {boolean | AddEventListenerOptions} [options]
       */
      addEventListener(type, listener, options) {
        this.$$l[type] = this.$$l[type] || [];
        this.$$l[type].push(listener);
        if (this.$$c) {
          const unsub = this.$$c.$on(type, listener);
          this.$$l_u.set(listener, unsub);
        }
        super.addEventListener(type, listener, options);
      }
      /**
       * @param {string} type
       * @param {EventListenerOrEventListenerObject} listener
       * @param {boolean | AddEventListenerOptions} [options]
       */
      removeEventListener(type, listener, options) {
        super.removeEventListener(type, listener, options);
        if (this.$$c) {
          const unsub = this.$$l_u.get(listener);
          if (unsub) {
            unsub();
            this.$$l_u.delete(listener);
          }
        }
      }
      async connectedCallback() {
        this.$$cn = true;
        if (!this.$$c) {
          let create_slot = function(name) {
            return (anchor) => {
              const slot2 = document.createElement("slot");
              if (name !== "default") slot2.name = name;
              append(anchor, slot2);
            };
          };
          await Promise.resolve();
          if (!this.$$cn || this.$$c) {
            return;
          }
          const $$slots = {};
          const existing_slots = get_custom_elements_slots(this);
          for (const name of this.$$s) {
            if (name in existing_slots) {
              if (name === "default" && !this.$$d.children) {
                this.$$d.children = create_slot(name);
                $$slots.default = true;
              } else {
                $$slots[name] = create_slot(name);
              }
            }
          }
          for (const attribute of this.attributes) {
            const name = this.$$g_p(attribute.name);
            if (!(name in this.$$d)) {
              this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
            }
          }
          for (const key in this.$$p_d) {
            if (!(key in this.$$d) && this[key] !== void 0) {
              this.$$d[key] = this[key];
              delete this[key];
            }
          }
          this.$$c = createClassComponent({
            component: this.$$ctor,
            target: this.shadowRoot || this,
            props: {
              ...this.$$d,
              $$slots,
              $$host: this
            }
          });
          this.$$me = effect_root(() => {
            render_effect(() => {
              this.$$r = true;
              for (const key of object_keys(this.$$c)) {
                if (!this.$$p_d[key]?.reflect) continue;
                this.$$d[key] = this.$$c[key];
                const attribute_value = get_custom_element_value(
                  key,
                  this.$$d[key],
                  this.$$p_d,
                  "toAttribute"
                );
                if (attribute_value == null) {
                  this.removeAttribute(this.$$p_d[key].attribute || key);
                } else {
                  this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
                }
              }
              this.$$r = false;
            });
          });
          for (const type in this.$$l) {
            for (const listener of this.$$l[type]) {
              const unsub = this.$$c.$on(type, listener);
              this.$$l_u.set(listener, unsub);
            }
          }
          this.$$l = {};
        }
      }
      // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
      // and setting attributes through setAttribute etc, this is helpful
      /**
       * @param {string} attr
       * @param {string} _oldValue
       * @param {string} newValue
       */
      attributeChangedCallback(attr2, _oldValue, newValue) {
        if (this.$$r) return;
        attr2 = this.$$g_p(attr2);
        this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
        this.$$c?.$set({ [attr2]: this.$$d[attr2] });
      }
      disconnectedCallback() {
        this.$$cn = false;
        Promise.resolve().then(() => {
          if (!this.$$cn && this.$$c) {
            this.$$c.$destroy();
            this.$$me();
            this.$$c = void 0;
          }
        });
      }
      /**
       * @param {string} attribute_name
       */
      $$g_p(attribute_name) {
        return object_keys(this.$$p_d).find(
          (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
        ) || attribute_name;
      }
    };
  }
  function get_custom_element_value(prop2, value2, props_definition, transform) {
    const type = props_definition[prop2]?.type;
    value2 = type === "Boolean" && typeof value2 !== "boolean" ? value2 != null : value2;
    if (!transform || !props_definition[prop2]) {
      return value2;
    } else if (transform === "toAttribute") {
      switch (type) {
        case "Object":
        case "Array":
          return value2 == null ? null : JSON.stringify(value2);
        case "Boolean":
          return value2 ? "" : null;
        case "Number":
          return value2 == null ? null : value2;
        default:
          return value2;
      }
    } else {
      switch (type) {
        case "Object":
        case "Array":
          return value2 && JSON.parse(value2);
        case "Boolean":
          return value2;
        // conversion already handled above
        case "Number":
          return value2 != null ? +value2 : value2;
        default:
          return value2;
      }
    }
  }
  function get_custom_elements_slots(element2) {
    const result = {};
    element2.childNodes.forEach((node) => {
      result[
        /** @type {Element} node */
        node.slot || "default"
      ] = true;
    });
    return result;
  }
  function create_custom_element(Component, props_definition, slots, exports, use_shadow_dom, extend) {
    let Class = class extends SvelteElement {
      constructor() {
        super(Component, slots, use_shadow_dom);
        this.$$p_d = props_definition;
      }
      static get observedAttributes() {
        return object_keys(props_definition).map(
          (key) => (props_definition[key].attribute || key).toLowerCase()
        );
      }
    };
    object_keys(props_definition).forEach((prop2) => {
      define_property(Class.prototype, prop2, {
        get() {
          return this.$$c && prop2 in this.$$c ? this.$$c[prop2] : this.$$d[prop2];
        },
        set(value2) {
          value2 = get_custom_element_value(prop2, value2, props_definition);
          this.$$d[prop2] = value2;
          var component2 = this.$$c;
          if (component2) {
            var setter = get_descriptor(component2, prop2)?.get;
            if (setter) {
              component2[prop2] = value2;
            } else {
              component2.$set({ [prop2]: value2 });
            }
          }
        }
      });
    });
    exports.forEach((property) => {
      define_property(Class.prototype, property, {
        get() {
          return this.$$c?.[property];
        }
      });
    });
    if (extend) {
      Class = extend(Class);
    }
    Component.element = /** @type {any} */
    Class;
    return Class;
  }

  // node_modules/svelte/src/internal/shared/validate.js
  function validate_void_dynamic_element(tag_fn) {
    const tag = tag_fn();
    if (tag && is_void(tag)) {
      dynamic_void_element_content(tag);
    }
  }
  function validate_dynamic_element_tag(tag_fn) {
    const tag = tag_fn();
    const is_string = typeof tag === "string";
    if (tag && !is_string) {
      svelte_element_invalid_this_value();
    }
  }
  function validate_store(store, name) {
    if (store != null && typeof store.subscribe !== "function") {
      store_invalid_shape(name);
    }
  }

  // node_modules/svelte/src/index-client.js
  if (true_default) {
    let throw_rune_error = function(rune) {
      if (!(rune in globalThis)) {
        let value2;
        Object.defineProperty(globalThis, rune, {
          configurable: true,
          // eslint-disable-next-line getter-return
          get: () => {
            if (value2 !== void 0) {
              return value2;
            }
            rune_outside_svelte(rune);
          },
          set: (v) => {
            value2 = v;
          }
        });
      }
    };
    throw_rune_error("$state");
    throw_rune_error("$effect");
    throw_rune_error("$derived");
    throw_rune_error("$inspect");
    throw_rune_error("$props");
    throw_rune_error("$bindable");
  }
  function onMount(fn) {
    if (component_context === null) {
      lifecycle_outside_component("onMount");
    }
    if (legacy_mode_flag && component_context.l !== null) {
      init_update_callbacks(component_context).m.push(fn);
    } else {
      user_effect(() => {
        const cleanup = untrack(fn);
        if (typeof cleanup === "function") return (
          /** @type {() => void} */
          cleanup
        );
      });
    }
  }
  function onDestroy(fn) {
    if (component_context === null) {
      lifecycle_outside_component("onDestroy");
    }
    onMount(() => () => untrack(fn));
  }
  function create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
    return new CustomEvent(type, { detail, bubbles, cancelable });
  }
  function createEventDispatcher() {
    const active_component_context = component_context;
    if (active_component_context === null) {
      lifecycle_outside_component("createEventDispatcher");
    }
    return (type, detail, options) => {
      const events = (
        /** @type {Record<string, Function | Function[]>} */
        active_component_context.s.$$events?.[
          /** @type {any} */
          type
        ]
      );
      if (events) {
        const callbacks = is_array(events) ? events.slice() : [events];
        const event2 = create_custom_event(
          /** @type {string} */
          type,
          detail,
          options
        );
        for (const fn of callbacks) {
          fn.call(active_component_context.x, event2);
        }
        return !event2.defaultPrevented;
      }
      return true;
    };
  }
  function init_update_callbacks(context) {
    var l = (
      /** @type {ComponentContextLegacy} */
      context.l
    );
    return l.u ?? (l.u = { a: [], b: [], m: [] });
  }

  // node_modules/svelte/src/store/utils.js
  function subscribe_to_store(store, run2, invalidate) {
    if (store == null) {
      run2(void 0);
      if (invalidate) invalidate(void 0);
      return noop;
    }
    const unsub = untrack(
      () => store.subscribe(
        run2,
        // @ts-expect-error
        invalidate
      )
    );
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
  }

  // node_modules/svelte/src/internal/server/hydration.js
  var BLOCK_OPEN = `<!--${HYDRATION_START}-->`;
  var BLOCK_OPEN_ELSE = `<!--${HYDRATION_START_ELSE}-->`;
  var BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;

  // node_modules/svelte/src/html-tree-validation.js
  var autoclosing_children = {
    // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
    li: { direct: ["li"] },
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt#technical_summary
    dt: { descendant: ["dt", "dd"], reset_by: ["dl"] },
    dd: { descendant: ["dt", "dd"], reset_by: ["dl"] },
    p: {
      descendant: [
        "address",
        "article",
        "aside",
        "blockquote",
        "div",
        "dl",
        "fieldset",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "hr",
        "main",
        "menu",
        "nav",
        "ol",
        "p",
        "pre",
        "section",
        "table",
        "ul"
      ]
    },
    rt: { descendant: ["rt", "rp"] },
    rp: { descendant: ["rt", "rp"] },
    optgroup: { descendant: ["optgroup"] },
    option: { descendant: ["option", "optgroup"] },
    thead: { direct: ["tbody", "tfoot"] },
    tbody: { direct: ["tbody", "tfoot"] },
    tfoot: { direct: ["tbody"] },
    tr: { direct: ["tr", "tbody"] },
    td: { direct: ["td", "th", "tr"] },
    th: { direct: ["td", "th", "tr"] }
  };
  var disallowed_children = {
    ...autoclosing_children,
    optgroup: { only: ["option", "#text"] },
    // Strictly speaking, seeing an <option> doesn't mean we're in a <select>, but we assume it here
    option: { only: ["#text"] },
    form: { descendant: ["form"] },
    a: { descendant: ["a"] },
    button: { descendant: ["button"] },
    h1: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
    h2: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
    h3: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
    h4: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
    h5: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
    h6: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
    select: { only: ["option", "optgroup", "#text", "hr", "script", "template"] },
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
    // No special behavior since these rules fall back to "in body" mode for
    // all except special table nodes which cause bad parsing behavior anyway.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
    tr: { only: ["th", "td", "style", "script", "template"] },
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
    tbody: { only: ["tr", "style", "script", "template"] },
    thead: { only: ["tr", "style", "script", "template"] },
    tfoot: { only: ["tr", "style", "script", "template"] },
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
    colgroup: { only: ["col", "template"] },
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
    table: {
      only: ["caption", "colgroup", "tbody", "thead", "tfoot", "style", "script", "template"]
    },
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
    head: {
      only: [
        "base",
        "basefont",
        "bgsound",
        "link",
        "meta",
        "title",
        "noscript",
        "noframes",
        "style",
        "script",
        "template"
      ]
    },
    // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
    html: { only: ["head", "body", "frameset"] },
    frameset: { only: ["frame"] },
    "#document": { only: ["html"] }
  };

  // ../deps/live_svelte/priv/static/live_svelte.esm.js
  function normalizeComponents(components) {
    if (!Array.isArray(components.default) || !Array.isArray(components.filenames)) return components;
    const normalized = {};
    for (const [index5, module] of components.default.entries()) {
      const Component = module.default;
      const name = components.filenames[index5].replace("../svelte/", "").replace(".svelte", "");
      normalized[name] = Component;
    }
    return normalized;
  }
  function getAttributeJson(ref, attributeName) {
    const data = ref.el.getAttribute(attributeName);
    return data ? JSON.parse(data) : {};
  }
  function getSlots(ref) {
    let snippets = {};
    for (const slotName in getAttributeJson(ref, "data-slots")) {
      const base64 = getAttributeJson(ref, "data-slots")[slotName];
      const element2 = document.createElement("div");
      element2.innerHTML = atob(base64).trim();
      const snippet2 = createRawSnippet((name) => {
        return { render: () => element2.outerHTML };
      });
      if (slotName === "default") snippets["children"] = snippet2;
      else snippets[slotName] = snippet2;
    }
    return snippets;
  }
  function getLiveJsonProps(ref) {
    const json = getAttributeJson(ref, "data-live-json");
    if (!Array.isArray(json)) return json;
    const liveJsonData = {};
    for (const liveJsonVariable of json) {
      const data = window[liveJsonVariable];
      if (data) liveJsonData[liveJsonVariable] = data;
    }
    return liveJsonData;
  }
  function getProps(ref) {
    return {
      ...getAttributeJson(ref, "data-props"),
      ...getLiveJsonProps(ref),
      ...getSlots(ref),
      live: ref
    };
  }
  function update_state(ref) {
    const newProps = getProps(ref);
    for (const key in newProps) {
      ref._instance.state[key] = newProps[key];
    }
  }
  function getHooks(components) {
    components = normalizeComponents(components);
    const SvelteHook = {
      mounted() {
        let state2 = proxy(getProps(this));
        const componentName = this.el.getAttribute("data-name");
        if (!componentName) throw new Error("Component name must be provided");
        const Component = components[componentName];
        if (!Component) throw new Error(`Unable to find ${componentName} component.`);
        for (const liveJsonElement of Object.keys(getAttributeJson(this, "data-live-json"))) {
          window.addEventListener(`${liveJsonElement}_initialized`, (_event) => update_state(this), false);
          window.addEventListener(`${liveJsonElement}_patched`, (_event) => update_state(this), false);
        }
        const hydrateOrMount = this.el.hasAttribute("data-ssr") ? hydrate : mount;
        this._instance = hydrateOrMount(Component, { target: this.el, props: state2 });
        this._instance.state = state2;
      },
      updated() {
        update_state(this);
      },
      destroyed() {
        if (this._instance) window.addEventListener("phx:page-loading-stop", () => unmount(this._instance), { once: true });
      }
    };
    return { SvelteHook };
  }

  // import-glob:../svelte/**/*.svelte
  var __exports = {};
  __export(__exports, {
    default: () => __default,
    filenames: () => filenames
  });

  // svelte/components/Backdrop.svelte
  var Backdrop_exports = {};
  __export(Backdrop_exports, {
    backdropVisible: () => backdropVisible,
    default: () => Backdrop
  });

  // node_modules/svelte/src/version.js
  var PUBLIC_VERSION = "5";

  // node_modules/svelte/src/internal/disclose-version.js
  var _a;
  if (typeof window !== "undefined") {
    ((_a = window.__svelte ?? (window.__svelte = {})).v ?? (_a.v = /* @__PURE__ */ new Set())).add(PUBLIC_VERSION);
  }

  // node_modules/svelte/src/internal/flags/legacy.js
  enable_legacy_mode_flag();

  // node_modules/svelte/src/transition/index.js
  var linear2 = (x) => x;
  function fade(node, { delay = 0, duration = 400, easing = linear2 } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
      delay,
      duration,
      easing,
      css: (t) => `opacity: ${t * o}`
    };
  }

  // svelte/components/Backdrop.svelte
  mark_module_start();
  Backdrop[FILENAME] = "svelte/components/Backdrop.svelte";
  var backdropVisible = writable(false);
  var root_1 = add_locations(template(`<div class="bg-black/50 absolute inset-0 z-30" data-testid="backdrop"></div>`), Backdrop[FILENAME], [[7, 2]]);
  function Backdrop($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, Backdrop);
    const [$$stores, $$cleanup] = setup_stores();
    const $backdropVisible = () => (validate_store(backdropVisible, "backdropVisible"), store_get(backdropVisible, "$backdropVisible", $$stores));
    init2();
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var div = root_1();
        transition(3, div, () => fade);
        append($$anchor2, div);
      };
      if_block(node, ($$render) => {
        if ($backdropVisible()) $$render(consequent);
      });
    }
    append($$anchor, fragment);
    var $$pop = pop({ ...legacy_api() });
    $$cleanup();
    return $$pop;
  }
  mark_module_end(Backdrop);
  create_custom_element(Backdrop, {}, [], [], true);

  // svelte/components/BrowserFrame.svelte
  var BrowserFrame_exports = {};
  __export(BrowserFrame_exports, {
    default: () => BrowserFrame
  });
  mark_module_start();
  BrowserFrame[FILENAME] = "svelte/components/BrowserFrame.svelte";
  var root = add_locations(template(`<div class="flex-1 flex flex-col" data-testid="fake-browser"><div class="bg-gray-50 border-b border-gray-200 border-solid rounded-t-xl h-12 px-3.5 flex" data-testid="address-bar"><div class="py-2"><span class="inline-block h-2 w-2 ml-2 rounded-full bg-red-800"></span> <span class="inline-block h-2 w-2 ml-2 rounded-full bg-amber-400"></span> <span class="inline-block h-2 w-2 ml-2 rounded-full bg-lime-600"></span></div> <div class="py-3"></div></div> <!></div>`), BrowserFrame[FILENAME], [
    [
      1,
      0,
      [
        [
          2,
          2,
          [
            [
              3,
              4,
              [[4, 6], [5, 6], [6, 6]]
            ],
            [8, 4]
          ]
        ]
      ]
    ]
  ]);
  function BrowserFrame($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, BrowserFrame);
    var div = root();
    var node = sibling(child(div), 2);
    slot(node, $$props, "default", {}, null);
    reset(div);
    append($$anchor, div);
    return pop({ ...legacy_api() });
  }
  mark_module_end(BrowserFrame);
  create_custom_element(BrowserFrame, {}, ["default"], [], true);

  // svelte/components/CodeEditor.svelte
  var CodeEditor_exports = {};
  __export(CodeEditor_exports, {
    default: () => CodeEditor2
  });

  // node_modules/@monaco-editor/loader/lib/es/_virtual/_rollupPluginBabelHelpers.js
  function _defineProperty3(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function ownKeys3(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread23(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source2 = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys3(Object(source2), true).forEach(function(key) {
          _defineProperty3(target, key, source2[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
      } else {
        ownKeys3(Object(source2)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
        });
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose2(source2, excluded) {
    if (source2 == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source2);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source2[key];
    }
    return target;
  }
  function _objectWithoutProperties2(source2, excluded) {
    if (source2 == null) return {};
    var target = _objectWithoutPropertiesLoose2(source2, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source2, key)) continue;
        target[key] = source2[key];
      }
    }
    return target;
  }
  function _slicedToArray2(arr, i) {
    return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
  }
  function _arrayWithHoles2(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArrayLimit2(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableRest2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // node_modules/state-local/lib/es/state-local.js
  function _defineProperty4(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function ownKeys4(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread24(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source2 = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys4(Object(source2), true).forEach(function(key) {
          _defineProperty4(target, key, source2[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
      } else {
        ownKeys4(Object(source2)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
        });
      }
    }
    return target;
  }
  function compose4() {
    for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
      fns[_key] = arguments[_key];
    }
    return function(x) {
      return fns.reduceRight(function(y, f) {
        return f(y);
      }, x);
    };
  }
  function curry3(fn) {
    return function curried() {
      var _this = this;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return args.length >= fn.length ? fn.apply(this, args) : function() {
        for (var _len3 = arguments.length, nextArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          nextArgs[_key3] = arguments[_key3];
        }
        return curried.apply(_this, [].concat(args, nextArgs));
      };
    };
  }
  function isObject3(value2) {
    return {}.toString.call(value2).includes("Object");
  }
  function isEmpty2(obj) {
    return !Object.keys(obj).length;
  }
  function isFunction2(value2) {
    return typeof value2 === "function";
  }
  function hasOwnProperty2(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }
  function validateChanges2(initial, changes) {
    if (!isObject3(changes)) errorHandler3("changeType");
    if (Object.keys(changes).some(function(field) {
      return !hasOwnProperty2(initial, field);
    })) errorHandler3("changeField");
    return changes;
  }
  function validateSelector2(selector) {
    if (!isFunction2(selector)) errorHandler3("selectorType");
  }
  function validateHandler2(handler) {
    if (!(isFunction2(handler) || isObject3(handler))) errorHandler3("handlerType");
    if (isObject3(handler) && Object.values(handler).some(function(_handler) {
      return !isFunction2(_handler);
    })) errorHandler3("handlersType");
  }
  function validateInitial2(initial) {
    if (!initial) errorHandler3("initialIsRequired");
    if (!isObject3(initial)) errorHandler3("initialType");
    if (isEmpty2(initial)) errorHandler3("initialContent");
  }
  function throwError3(errorMessages5, type) {
    throw new Error(errorMessages5[type] || errorMessages5["default"]);
  }
  var errorMessages3 = {
    initialIsRequired: "initial state is required",
    initialType: "initial state should be an object",
    initialContent: "initial state shouldn't be an empty object",
    handlerType: "handler should be an object or a function",
    handlersType: "all handlers should be a functions",
    selectorType: "selector should be a function",
    changeType: "provided value of changes should be an object",
    changeField: 'it seams you want to change a field in the state which is not specified in the "initial" state',
    "default": "an unknown error accured in `state-local` package"
  };
  var errorHandler3 = curry3(throwError3)(errorMessages3);
  var validators3 = {
    changes: validateChanges2,
    selector: validateSelector2,
    handler: validateHandler2,
    initial: validateInitial2
  };
  function create2(initial) {
    var handler = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    validators3.initial(initial);
    validators3.handler(handler);
    var state2 = {
      current: initial
    };
    var didUpdate = curry3(didStateUpdate2)(state2, handler);
    var update2 = curry3(updateState2)(state2);
    var validate = curry3(validators3.changes)(initial);
    var getChanges = curry3(extractChanges2)(state2);
    function getState3() {
      var selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function(state3) {
        return state3;
      };
      validators3.selector(selector);
      return selector(state2.current);
    }
    function setState3(causedChanges) {
      compose4(didUpdate, update2, validate, getChanges)(causedChanges);
    }
    return [getState3, setState3];
  }
  function extractChanges2(state2, causedChanges) {
    return isFunction2(causedChanges) ? causedChanges(state2.current) : causedChanges;
  }
  function updateState2(state2, changes) {
    state2.current = _objectSpread24(_objectSpread24({}, state2.current), changes);
    return changes;
  }
  function didStateUpdate2(state2, handler, changes) {
    isFunction2(handler) ? handler(state2.current) : Object.keys(changes).forEach(function(field) {
      var _handler$field;
      return (_handler$field = handler[field]) === null || _handler$field === void 0 ? void 0 : _handler$field.call(handler, state2.current[field]);
    });
    return changes;
  }
  var index3 = {
    create: create2
  };
  var state_local_default2 = index3;

  // node_modules/@monaco-editor/loader/lib/es/config/index.js
  var config3 = {
    paths: {
      vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs"
    }
  };
  var config_default2 = config3;

  // node_modules/@monaco-editor/loader/lib/es/utils/curry.js
  function curry4(fn) {
    return function curried() {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return args.length >= fn.length ? fn.apply(this, args) : function() {
        for (var _len2 = arguments.length, nextArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          nextArgs[_key2] = arguments[_key2];
        }
        return curried.apply(_this, [].concat(args, nextArgs));
      };
    };
  }
  var curry_default2 = curry4;

  // node_modules/@monaco-editor/loader/lib/es/utils/isObject.js
  function isObject4(value2) {
    return {}.toString.call(value2).includes("Object");
  }
  var isObject_default2 = isObject4;

  // node_modules/@monaco-editor/loader/lib/es/validators/index.js
  function validateConfig2(config5) {
    if (!config5) errorHandler4("configIsRequired");
    if (!isObject_default2(config5)) errorHandler4("configType");
    if (config5.urls) {
      informAboutDeprecation2();
      return {
        paths: {
          vs: config5.urls.monacoBase
        }
      };
    }
    return config5;
  }
  function informAboutDeprecation2() {
    console.warn(errorMessages4.deprecation);
  }
  function throwError4(errorMessages5, type) {
    throw new Error(errorMessages5[type] || errorMessages5["default"]);
  }
  var errorMessages4 = {
    configIsRequired: "the configuration object is required",
    configType: "the configuration object should be an object",
    "default": "an unknown error accured in `@monaco-editor/loader` package",
    deprecation: "Deprecation warning!\n    You are using deprecated way of configuration.\n\n    Instead of using\n      monaco.config({ urls: { monacoBase: '...' } })\n    use\n      monaco.config({ paths: { vs: '...' } })\n\n    For more please check the link https://github.com/suren-atoyan/monaco-loader#config\n  "
  };
  var errorHandler4 = curry_default2(throwError4)(errorMessages4);
  var validators4 = {
    config: validateConfig2
  };
  var validators_default2 = validators4;

  // node_modules/@monaco-editor/loader/lib/es/utils/compose.js
  var compose5 = function compose6() {
    for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
      fns[_key] = arguments[_key];
    }
    return function(x) {
      return fns.reduceRight(function(y, f) {
        return f(y);
      }, x);
    };
  };
  var compose_default2 = compose5;

  // node_modules/@monaco-editor/loader/lib/es/utils/deepMerge.js
  function merge2(target, source2) {
    Object.keys(source2).forEach(function(key) {
      if (source2[key] instanceof Object) {
        if (target[key]) {
          Object.assign(source2[key], merge2(target[key], source2[key]));
        }
      }
    });
    return _objectSpread23(_objectSpread23({}, target), source2);
  }
  var deepMerge_default2 = merge2;

  // node_modules/@monaco-editor/loader/lib/es/utils/makeCancelable.js
  var CANCELATION_MESSAGE2 = {
    type: "cancelation",
    msg: "operation is manually canceled"
  };
  function makeCancelable2(promise) {
    var hasCanceled_ = false;
    var wrappedPromise = new Promise(function(resolve, reject) {
      promise.then(function(val) {
        return hasCanceled_ ? reject(CANCELATION_MESSAGE2) : resolve(val);
      });
      promise["catch"](reject);
    });
    return wrappedPromise.cancel = function() {
      return hasCanceled_ = true;
    }, wrappedPromise;
  }
  var makeCancelable_default2 = makeCancelable2;

  // node_modules/@monaco-editor/loader/lib/es/loader/index.js
  var _state$create3 = state_local_default2.create({
    config: config_default2,
    isInitialized: false,
    resolve: null,
    reject: null,
    monaco: null
  });
  var _state$create22 = _slicedToArray2(_state$create3, 2);
  var getState2 = _state$create22[0];
  var setState2 = _state$create22[1];
  function config4(globalConfig) {
    var _validators$config = validators_default2.config(globalConfig), monaco = _validators$config.monaco, config5 = _objectWithoutProperties2(_validators$config, ["monaco"]);
    setState2(function(state2) {
      return {
        config: deepMerge_default2(state2.config, config5),
        monaco
      };
    });
  }
  function init3() {
    var state2 = getState2(function(_ref) {
      var monaco = _ref.monaco, isInitialized = _ref.isInitialized, resolve = _ref.resolve;
      return {
        monaco,
        isInitialized,
        resolve
      };
    });
    if (!state2.isInitialized) {
      setState2({
        isInitialized: true
      });
      if (state2.monaco) {
        state2.resolve(state2.monaco);
        return makeCancelable_default2(wrapperPromise2);
      }
      if (window.monaco && window.monaco.editor) {
        storeMonacoInstance2(window.monaco);
        state2.resolve(window.monaco);
        return makeCancelable_default2(wrapperPromise2);
      }
      compose_default2(injectScripts2, getMonacoLoaderScript2)(configureLoader2);
    }
    return makeCancelable_default2(wrapperPromise2);
  }
  function injectScripts2(script) {
    return document.body.appendChild(script);
  }
  function createScript2(src) {
    var script = document.createElement("script");
    return src && (script.src = src), script;
  }
  function getMonacoLoaderScript2(configureLoader3) {
    var state2 = getState2(function(_ref2) {
      var config5 = _ref2.config, reject = _ref2.reject;
      return {
        config: config5,
        reject
      };
    });
    var loaderScript = createScript2("".concat(state2.config.paths.vs, "/loader.js"));
    loaderScript.onload = function() {
      return configureLoader3();
    };
    loaderScript.onerror = state2.reject;
    return loaderScript;
  }
  function configureLoader2() {
    var state2 = getState2(function(_ref3) {
      var config5 = _ref3.config, resolve = _ref3.resolve, reject = _ref3.reject;
      return {
        config: config5,
        resolve,
        reject
      };
    });
    var require2 = window.require;
    require2.config(state2.config);
    require2(["vs/editor/editor.main"], function(monaco) {
      storeMonacoInstance2(monaco);
      state2.resolve(monaco);
    }, function(error) {
      state2.reject(error);
    });
  }
  function storeMonacoInstance2(monaco) {
    if (!getState2().monaco) {
      setState2({
        monaco
      });
    }
  }
  function __getMonacoInstance2() {
    return getState2(function(_ref4) {
      var monaco = _ref4.monaco;
      return monaco;
    });
  }
  var wrapperPromise2 = new Promise(function(resolve, reject) {
    return setState2({
      resolve,
      reject
    });
  });
  var loader2 = {
    config: config4,
    init: init3,
    __getMonacoInstance: __getMonacoInstance2
  };
  var loader_default2 = loader2;

  // svelte/components/CodeEditor.svelte
  mark_module_start();
  CodeEditor2[FILENAME] = "svelte/components/CodeEditor.svelte";
  var root2 = add_locations(template(`<div class="w-52 h-24 py-0.5 px-0.5 bg-gray-100"></div>`), CodeEditor2[FILENAME], [[34, 0]]);
  function CodeEditor2($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, CodeEditor2);
    let value2 = prop($$props, "value", 12);
    let dispatch = createEventDispatcher();
    let editor;
    let monaco;
    let editorContainer = mutable_source();
    onMount(async () => {
      loader_default2.config({
        paths: { vs: "/node_modules/monaco-editor/min/vs" }
      });
      monaco = await loader_default2.init();
      const editor2 = monaco.editor.create(get(editorContainer), {
        value: value2(),
        language: "elixir",
        minimap: { enabled: false },
        lineNumbers: "off",
        automaticLayout: true
      });
      editor2.onDidBlurEditorWidget((e) => {
        let content = editor2.getValue();
        dispatch("change", content);
      });
    });
    onDestroy(() => {
      monaco?.editor.getModels().forEach((model) => model.dispose());
    });
    legacy_pre_effect(() => deep_read_state(value2()), () => {
      if (editor) {
        editor.setValue(value2());
      }
    });
    legacy_pre_effect_reset();
    init2();
    var div = root2();
    bind_this(div, ($$value) => set(editorContainer, $$value), () => get(editorContainer));
    append($$anchor, div);
    return pop({
      get value() {
        return value2();
      },
      set value($$value) {
        value2($$value);
        flushSync();
      },
      ...legacy_api()
    });
  }
  mark_module_end(CodeEditor2);
  create_custom_element(CodeEditor2, { value: {} }, [], [], true);

  // svelte/components/ComponentsSidebar.svelte
  var ComponentsSidebar_exports = {};
  __export(ComponentsSidebar_exports, {
    default: () => ComponentsSidebar
  });

  // svelte/utils/animations.ts
  function translate(_node, { delay = 0, duration = 300, x = 0, y = 0 }) {
    return {
      delay,
      duration,
      css: (t) => `transform: translate(${x * t}px, ${y * t}px)`
    };
  }

  // svelte/stores/currentComponentCategory.ts
  var currentComponentCategory = writable(null);

  // svelte/stores/dragAndDrop.ts
  var draggedComponentDefinition = writable(null);
  var resetDrag = () => {
    draggedComponentDefinition.update(() => null);
  };

  // svelte/components/ComponentsSidebar.svelte
  mark_module_start();
  ComponentsSidebar[FILENAME] = "svelte/components/ComponentsSidebar.svelte";
  var root_2 = add_locations(template(`<li class="mb-1 px-4" data-testid="nav-item"><h3 class="text-xs font-bold uppercase"> </h3></li>`), ComponentsSidebar[FILENAME], [[76, 10, [[77, 12]]]]);
  var root_3 = add_locations(template(`<li class="p-2 pl-6 hover:bg-slate-50 hover:cursor-pointer" data-testid="nav-item"><div> </div></li>`), ComponentsSidebar[FILENAME], [[81, 10, [[87, 12]]]]);
  var root_12 = add_locations(template(`<!> <!>`, 1), ComponentsSidebar[FILENAME], []);
  var root_5 = add_locations(template(`<div draggable="true" class="pt-6" data-testid="component-preview-card"><p class="mb-1 text-xs font-bold uppercase tracking-wider"> </p> <img class="w-full h-auto rounded ring-offset-2 ring-blue-500 transition hover:cursor-grab hover:ring-2"></div>`), ComponentsSidebar[FILENAME], [
    [109, 10, [[116, 12], [118, 12]]]
  ]);
  var root_6 = add_locations(template(`<div class="bg-black/50 absolute inset-0 z-50 svelte-uvq63b" id="backdrop" data-testid="backdrop"></div>`), ComponentsSidebar[FILENAME], [[131, 2]]);
  var root3 = add_locations(template(`<div class="w-64 bg-white border-slate-100 border-solid border-r svelte-uvq63b" id="left-sidebar" data-testid="left-sidebar"><div class="sticky top-0"><div class="border-b border-slate-100 border-solid py-4 px-4" data-testid="logo"><h2 class="text-lg font-bold">Components</h2></div> <ul class="py-4 h-[calc(100vh_-_61px)] overflow-y-auto" data-testid="component-tree"></ul> <div id="component-previews" data-testid="component-previews"><h4 class="mb-4 font-bold text-2xl"> </h4> <p class="font-medium">Drag and drop an element into the page</p> <!></div></div></div> <!>`, 1), ComponentsSidebar[FILENAME], [
    [
      68,
      0,
      [
        [
          69,
          2,
          [
            [70, 4, [[71, 6]]],
            [73, 4],
            [93, 4, [[104, 6], [105, 6]]]
          ]
        ]
      ]
    ]
  ]);
  var $$css = {
    hash: "svelte-uvq63b",
    code: "\n  #left-sidebar.svelte-uvq63b {\n    z-index: 1000;\n  }\n  #backdrop.svelte-uvq63b {\n    z-index: 999;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29tcG9uZW50c1NpZGViYXIuc3ZlbHRlIiwibWFwcGluZ3MiOiI7QUFxSkEsRUFBRSwyQkFBYSxDQUFDO0FBQ2hCLElBQUksYUFBYTtBQUNqQjtBQUNBLEVBQUUsdUJBQVMsQ0FBQztBQUNaLElBQUksWUFBWTtBQUNoQiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiQ29tcG9uZW50c1NpZGViYXIuc3ZlbHRlIl19 */"
  };
  function ComponentsSidebar($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, ComponentsSidebar);
    append_styles2($$anchor, $$css);
    const [$$stores, $$cleanup] = setup_stores();
    const $currentComponentCategory = () => (validate_store(currentComponentCategory, "currentComponentCategory"), store_get(currentComponentCategory, "$currentComponentCategory", $$stores));
    const $draggedComponentDefinition = () => (validate_store(draggedComponentDefinition, "draggedComponentDefinition"), store_get(draggedComponentDefinition, "$draggedComponentDefinition", $$stores));
    const componentDefinitions = mutable_source();
    const componentDefinitionsByCategory = mutable_source();
    const currentDefinitions = mutable_source();
    let components = prop($$props, "components", 12);
    let menuCategories = mutable_source([]);
    const sectionTitles = {
      basic: "Basics",
      html_tag: "HTML Tags",
      data: "Data",
      element: "Elements",
      media: "Media",
      section: "Section"
    };
    let showExamples = mutable_source(false);
    let hideComponentTimer;
    let changeCategoryTimer;
    function collapseCategoryMenu() {
      clearTimeout(changeCategoryTimer);
      hideComponentTimer = setTimeout(
        () => {
          set(showExamples, false);
        },
        400
      );
    }
    function abortCollapseCategoryMenu() {
      clearTimeout(hideComponentTimer);
    }
    function expandCategoryMenu(componentCategory) {
      if ($draggedComponentDefinition()) return;
      clearTimeout(hideComponentTimer);
      if (get(showExamples)) {
        changeCategoryTimer = setTimeout(
          () => {
            store_set(currentComponentCategory, componentCategory);
            set(showExamples, true);
          },
          100
        );
      } else {
        store_set(currentComponentCategory, componentCategory);
        set(showExamples, true);
      }
    }
    function dragStart(componentDefinition, e) {
      setTimeout(
        () => {
          store_set(draggedComponentDefinition, componentDefinition);
          set(showExamples, false);
        },
        100
      );
    }
    function dragEnd() {
      resetDrag();
    }
    legacy_pre_effect(() => deep_read_state(components()), () => {
      set(componentDefinitions, components());
    });
    legacy_pre_effect(() => get(componentDefinitions), () => {
      set(menuCategories, [
        {
          name: "Base",
          items: Array.from(new Set(get(componentDefinitions).map((d) => d.category))).map((id) => ({ id, name: id }))
        }
      ]);
    });
    legacy_pre_effect(() => get(componentDefinitions), () => {
      set(componentDefinitionsByCategory, (get(componentDefinitions) || []).reduce(
        (acc, comp) => {
          var _a2;
          acc[_a2 = comp.category] || assign(acc, _a2, [], "svelte/\u200Bcomponents/\u200BComponentsSidebar.svelte:16:32");
          acc[comp.category].push(comp);
          return acc;
        },
        {}
      ));
    });
    legacy_pre_effect(
      () => ($currentComponentCategory(), get(componentDefinitionsByCategory)),
      () => {
        set(currentDefinitions, $currentComponentCategory() ? get(componentDefinitionsByCategory)[$currentComponentCategory().id] : []);
      }
    );
    legacy_pre_effect_reset();
    init2();
    var fragment = root3();
    var div = first_child(fragment);
    var div_1 = child(div);
    var ul = sibling(child(div_1), 2);
    each(ul, 5, () => get(menuCategories), index2, ($$anchor2, category) => {
      var fragment_1 = root_12();
      var node = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var li = root_2();
          var h3 = child(li);
          var text2 = child(h3, true);
          reset(h3);
          reset(li);
          template_effect(() => set_text(text2, get(category).name));
          append($$anchor3, li);
        };
        if_block(node, ($$render) => {
          if (get(menuCategories).length > 1) $$render(consequent);
        });
      }
      var node_1 = sibling(node, 2);
      each(node_1, 1, () => get(category).items, index2, ($$anchor3, item) => {
        var li_1 = root_3();
        var div_2 = child(li_1);
        var text_1 = child(div_2, true);
        reset(div_2);
        reset(li_1);
        template_effect(() => set_text(text_1, sectionTitles[get(item).name]));
        event("mouseenter", li_1, () => expandCategoryMenu(get(item)));
        event("mouseleave", li_1, collapseCategoryMenu);
        append($$anchor3, li_1);
      });
      append($$anchor2, fragment_1);
    });
    reset(ul);
    var div_3 = sibling(ul, 2);
    let classes;
    var h4 = child(div_3);
    var text_2 = child(h4, true);
    reset(h4);
    var node_2 = sibling(h4, 4);
    {
      var consequent_1 = ($$anchor2) => {
        var fragment_2 = comment();
        var node_3 = first_child(fragment_2);
        each(node_3, 1, () => get(currentDefinitions), index2, ($$anchor3, example) => {
          var div_4 = root_5();
          var p = child(div_4);
          var text_3 = child(p, true);
          reset(p);
          var img = sibling(p, 2);
          reset(div_4);
          template_effect(() => {
            set_text(text_3, get(example).name);
            set_attribute(img, "src", get(example).thumbnail ? get(example).thumbnail : `https://placehold.co/400x75?text=${get(example).name}`);
            set_attribute(img, "alt", get(example).name);
          });
          event("dragstart", div_4, (e) => dragStart(get(example), e));
          event("dragend", div_4, dragEnd);
          append($$anchor3, div_4);
        });
        append($$anchor2, fragment_2);
      };
      if_block(node_2, ($$render) => {
        if (get(currentDefinitions)) $$render(consequent_1);
      });
    }
    reset(div_3);
    reset(div_1);
    reset(div);
    var node_4 = sibling(div, 2);
    {
      var consequent_2 = ($$anchor2) => {
        var div_5 = root_6();
        transition(3, div_5, () => fade, () => ({ duration: 300 }));
        append($$anchor2, div_5);
      };
      if_block(node_4, ($$render) => {
        if (get(showExamples)) $$render(consequent_2);
      });
    }
    template_effect(
      ($0) => {
        classes = set_class(div_3, 1, "absolute w-96 left-0 bg-slate-50 inset-y-0 shadow-sm z-50 pt-3 pb-4 px-5 transition-transform duration-500 opacity-0 invisible overflow-y-auto min-h-screen", null, classes, $0);
        set_text(text_2, sectionTitles[$currentComponentCategory()?.name]);
      },
      [
        () => ({
          "translate-x-[255px]": get(showExamples),
          "!opacity-100": get(showExamples),
          "!visible": get(showExamples)
        })
      ],
      derived_safe_equal
    );
    transition(3, div_3, () => translate, () => ({ x: 384 }));
    event("mouseenter", div_3, abortCollapseCategoryMenu);
    event("mouseleave", div_3, collapseCategoryMenu);
    append($$anchor, fragment);
    var $$pop = pop({
      get components() {
        return components();
      },
      set components($$value) {
        components($$value);
        flushSync();
      },
      ...legacy_api()
    });
    $$cleanup();
    return $$pop;
  }
  mark_module_end(ComponentsSidebar);
  create_custom_element(ComponentsSidebar, { components: {} }, [], [], true);

  // svelte/components/GoToParentButton.svelte
  var GoToParentButton_exports = {};
  __export(GoToParentButton_exports, {
    default: () => GoToParentButton
  });

  // svelte/stores/live.ts
  var live = writable();

  // svelte/stores/page.ts
  var pageAst = writable();
  var layoutAst = writable();
  var selectedAstElementId = writable();
  var highlightedAstElement = writable();
  var slotTargetElement = writable();
  var rootAstElement = derived2([pageAst], ([$pageAst]) => {
    if ($pageAst) {
      return { tag: "root", attrs: {}, content: $pageAst };
    }
  });
  var selectedAstElement = derived2(
    [pageAst, selectedAstElementId],
    ([$pageAst, $selectedAstElementId]) => {
      if ($pageAst && $selectedAstElementId) {
        const element2 = findAstElement($pageAst, $selectedAstElementId);
        get2(live).pushEventTo("#heex-visual-editor", "select_element", { path: $selectedAstElementId });
        return element2;
      } else {
        get2(live).pushEventTo("#heex-visual-editor", "select_element", { path: null });
      }
    }
  );
  function getParentId(id) {
    if (id === null || id === "root") return null;
    let levels = id.split(".");
    if (levels.length === 1) return "root";
    levels.pop();
    return levels.join(".");
  }
  var parentSelectedAstElementId = derived2(
    [selectedAstElementId],
    ([$selectedAstElementId]) => {
      return getParentId($selectedAstElementId);
    }
  );
  var grandParentSelectedAstElementId = derived2(
    [parentSelectedAstElementId],
    ([$parentSelectedAstElementId]) => {
      return getParentId($parentSelectedAstElementId);
    }
  );
  var parentOfSelectedAstElement = derived2(
    [pageAst, parentSelectedAstElementId],
    ([$pageAst, $parentSelectedAstElementId]) => findAstElement($pageAst, $parentSelectedAstElementId)
  );
  var grandParentOfSelectedAstElement = derived2(
    [pageAst, grandParentSelectedAstElementId],
    ([$pageAst, $grandParentSelectedAstElementId]) => findAstElement($pageAst, $grandParentSelectedAstElementId)
  );
  var selectedDomElement = writable(null);
  function setSelection(selectedId) {
    selectedAstElementId.update(() => selectedId);
  }
  function setSelectedDom(selectedDom) {
    selectedDomElement.update(() => selectedDom);
  }
  function resetSelection() {
    selectedAstElementId.update(() => null);
    selectedDomElement.update(() => null);
  }
  function isAstElement(maybeNode) {
    return typeof maybeNode !== "string";
  }
  function findAstElement(ast, id) {
    if (id === "root") return get2(rootAstElement);
    if (!id) return null;
    let indexes = id.split(".").map((s) => parseInt(s, 10));
    let node = ast[indexes[0]];
    ast = node.content;
    for (let i = 1; i < indexes.length; i++) {
      node = ast[indexes[i]];
      ast = node.content;
    }
    return node;
  }
  function findAstElementId(astNode) {
    let ast = get2(pageAst);
    return _findAstElementId(ast, astNode, "");
  }
  function _findAstElementId(ast, astNode, id) {
    for (let i = 0; i < ast.length; i++) {
      let currentNode = ast[i];
      if (currentNode === astNode) {
        return id + i;
      } else if (isAstElement(currentNode)) {
        let result = currentNode.content && _findAstElementId(currentNode.content, astNode, id + i + ".");
        if (result) {
          return result;
        }
      }
    }
  }
  function resetStores() {
    pageAst.set(null);
    layoutAst.set(null);
    selectedAstElementId.set(null);
    highlightedAstElement.set(null);
    slotTargetElement.set(null);
    selectedDomElement.set(null);
  }

  // svelte/utils/ast-helpers.ts
  function getParentNodeId(astElementId = null) {
    if (astElementId) {
      let parts = astElementId.split(".");
      if (parts.length === 1) return "root";
      return parts.slice(0, -1).join(".");
    }
  }

  // svelte/components/GoToParentButton.svelte
  mark_module_start();
  GoToParentButton[FILENAME] = "svelte/components/GoToParentButton.svelte";
  var root4 = add_locations(template(`<button type="button" class="absolute p-2 top-2 right-9 group"><span class="sr-only">Up one level</span> <span class="absolute opacity-0 invisible right-9 min-w-[100px] bg-amber-100 py-1 px-1.5 rounded text-xs text-medium transition group-hover:opacity-100 group-hover:visible">Up one level</span> <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 hover:text-blue-700 active:text-blue-900"><path stroke-linecap="round" stroke-linejoin="round" d="M3 4.5h14.25M3 9h9.75M3 13.5h5.25m5.25-.75L17.25 9m0 0L21 12.75M17.25 9v12"></path></svg></button>`), GoToParentButton[FILENAME], [
    [
      9,
      0,
      [
        [10, 2],
        [11, 2],
        [15, 2, [[23, 4]]]
      ]
    ]
  ]);
  function GoToParentButton($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, GoToParentButton);
    const [$$stores, $$cleanup] = setup_stores();
    const $selectedAstElementId = () => (validate_store(selectedAstElementId, "selectedAstElementId"), store_get(selectedAstElementId, "$selectedAstElementId", $$stores));
    function selectParentNode() {
      let parentId = getParentNodeId($selectedAstElementId());
      setSelection(parentId);
    }
    init2();
    var button = root4();
    event("click", button, selectParentNode);
    append($$anchor, button);
    var $$pop = pop({ ...legacy_api() });
    $$cleanup();
    return $$pop;
  }
  mark_module_end(GoToParentButton);
  create_custom_element(GoToParentButton, {}, [], [], true);

  // svelte/components/LayoutAstNode.svelte
  var LayoutAstNode_exports = {};
  __export(LayoutAstNode_exports, {
    default: () => LayoutAstNode
  });
  mark_module_start();
  LayoutAstNode[FILENAME] = "svelte/components/LayoutAstNode.svelte";
  function LayoutAstNode($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, LayoutAstNode);
    let node = prop($$props, "node", 12);
    init2();
    var fragment = comment();
    var node_1 = first_child(fragment);
    {
      var consequent_6 = ($$anchor2) => {
        var fragment_1 = comment();
        var node_2 = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            html(node_3, () => "<!--" + node().content + "-->", false, false);
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3, $$elseif) => {
            {
              var consequent_1 = ($$anchor4) => {
                var fragment_3 = comment();
                var node_4 = first_child(fragment_3);
                html(node_4, () => "<!--" + node().content + "-->", false, false);
                append($$anchor4, fragment_3);
              };
              var alternate_1 = ($$anchor4, $$elseif2) => {
                {
                  var consequent_2 = ($$anchor5) => {
                    var fragment_4 = comment();
                    var node_5 = first_child(fragment_4);
                    slot(node_5, $$props, "default", {}, null);
                    append($$anchor5, fragment_4);
                  };
                  var alternate_2 = ($$anchor5, $$elseif3) => {
                    {
                      var consequent_3 = ($$anchor6) => {
                        var fragment_5 = comment();
                        var node_6 = first_child(fragment_5);
                        html(node_6, () => node().rendered_html, false, false);
                        append($$anchor6, fragment_5);
                      };
                      var alternate_3 = ($$anchor6, $$elseif4) => {
                        {
                          var consequent_4 = ($$anchor7) => {
                            var fragment_6 = comment();
                            var node_7 = first_child(fragment_6);
                            validate_dynamic_element_tag(() => node().tag);
                            element(
                              node_7,
                              () => node().tag,
                              false,
                              ($$element, $$anchor8) => {
                                let attributes;
                                template_effect(() => attributes = set_attributes($$element, attributes, { ...node().attrs }));
                              },
                              void 0,
                              [15, 4]
                            );
                            append($$anchor7, fragment_6);
                          };
                          var alternate_4 = ($$anchor7) => {
                            var fragment_7 = comment();
                            var node_8 = first_child(fragment_7);
                            validate_void_dynamic_element(() => node().tag);
                            validate_dynamic_element_tag(() => node().tag);
                            element(
                              node_8,
                              () => node().tag,
                              false,
                              ($$element_1, $$anchor8) => {
                                let attributes_1;
                                template_effect(() => attributes_1 = set_attributes($$element_1, attributes_1, { ...node().attrs }));
                                var fragment_8 = comment();
                                var node_9 = first_child(fragment_8);
                                {
                                  var consequent_5 = ($$anchor9) => {
                                    var fragment_9 = comment();
                                    var node_10 = first_child(fragment_9);
                                    each(node_10, 1, () => node().content, index2, ($$anchor10, subnode) => {
                                      var fragment_10 = comment();
                                      var node_11 = first_child(fragment_10);
                                      LayoutAstNode(node_11, {
                                        get node() {
                                          return get(subnode);
                                        },
                                        children: wrap_snippet(LayoutAstNode, ($$anchor11, $$slotProps) => {
                                          var fragment_11 = comment();
                                          var node_12 = first_child(fragment_11);
                                          slot(node_12, $$props, "default", {}, null);
                                          append($$anchor11, fragment_11);
                                        }),
                                        $$slots: { default: true }
                                      });
                                      append($$anchor10, fragment_10);
                                    });
                                    append($$anchor9, fragment_9);
                                  };
                                  if_block(node_9, ($$render) => {
                                    if (node().content) $$render(consequent_5);
                                  });
                                }
                                append($$anchor8, fragment_8);
                              },
                              void 0,
                              [17, 4]
                            );
                            append($$anchor7, fragment_7);
                          };
                          if_block(
                            $$anchor6,
                            ($$render) => {
                              if (node().attrs?.selfClose) $$render(consequent_4);
                              else $$render(alternate_4, false);
                            },
                            $$elseif4
                          );
                        }
                      };
                      if_block(
                        $$anchor5,
                        ($$render) => {
                          if (node().rendered_html) $$render(consequent_3);
                          else $$render(alternate_3, false);
                        },
                        $$elseif3
                      );
                    }
                  };
                  if_block(
                    $$anchor4,
                    ($$render) => {
                      if (strict_equals(node().tag, "eex") && strict_equals(node().content[0], "@inner_content")) $$render(consequent_2);
                      else $$render(alternate_2, false);
                    },
                    $$elseif2
                  );
                }
              };
              if_block(
                $$anchor3,
                ($$render) => {
                  if (strict_equals(node().tag, "eex_comment")) $$render(consequent_1);
                  else $$render(alternate_1, false);
                },
                $$elseif
              );
            }
          };
          if_block(node_2, ($$render) => {
            if (strict_equals(node().tag, "html_comment")) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor2, fragment_1);
      };
      var alternate_5 = ($$anchor2) => {
        var text2 = text();
        template_effect(() => set_text(text2, node()));
        append($$anchor2, text2);
      };
      if_block(node_1, ($$render) => {
        if (isAstElement(node())) $$render(consequent_6);
        else $$render(alternate_5, false);
      });
    }
    append($$anchor, fragment);
    return pop({
      get node() {
        return node();
      },
      set node($$value) {
        node($$value);
        flushSync();
      },
      ...legacy_api()
    });
  }
  mark_module_end(LayoutAstNode);
  create_custom_element(LayoutAstNode, { node: {} }, ["default"], [], true);

  // svelte/components/PageAstNode.svelte
  var PageAstNode_exports = {};
  __export(PageAstNode_exports, {
    default: () => PageAstNode
  });

  // svelte/utils/ast-manipulation.ts
  function updateNodeContent(node, text2) {
    if (node && isAstElement(node)) {
      node.content = [text2];
      updateAst();
    }
  }
  function updateAst() {
    let ast = get2(pageAst);
    let live2 = get2(live);
    live2.pushEventTo("#heex-visual-editor", "update_page_ast", { ast });
  }
  function deleteAstNode(astElementId) {
    let ast = get2(pageAst);
    let astElement = findAstElement(ast, astElementId);
    let parentId = getParentNodeId(astElementId);
    let content = parentId && parentId !== "root" ? findAstElement(ast, parentId)?.content : ast;
    if (content) {
      let targetIndex = content.indexOf(astElement);
      content.splice(targetIndex, 1);
      updateAst();
    }
  }

  // svelte/components/SelectedElementFloatingMenu/DragMenuOption.svelte
  var DragMenuOption_exports = {};
  __export(DragMenuOption_exports, {
    default: () => DragMenuOption,
    isDragging: () => isDragging
  });
  mark_module_start();
  DragMenuOption[FILENAME] = "svelte/components/SelectedElementFloatingMenu/DragMenuOption.svelte";
  var isDragging = writable(false);
  function calculateHandleXPosition(rect, position2) {
    if (strict_equals(position2, "bottom")) {
      return rect.x + rect.width / 2 - 5;
    } else {
      return rect.x - 25;
    }
  }
  function calculateHandleYPosition(rect, position2) {
    if (strict_equals(position2, "bottom")) {
      return rect.y + rect.height + 5;
    } else {
      return rect.y + rect.height / 2 - 5;
    }
  }
  var root_22 = add_locations(template(`<div class="absolute transition-all" data-testid="drag-placeholder"></div>`), DragMenuOption[FILENAME], [[306, 4]]);
  var root_13 = add_locations(template(`<!> <button class="rounded-full w-6 h-6 flex justify-center items-center absolute bg-blue-600 text-white hover:bg-blue-700 focus:outline-none focus-visible:ring-4 focus-visible:ring-blue-200 active:bg-blue-800 transform"><span></span></button>`, 1), DragMenuOption[FILENAME], [[313, 2, [[321, 4]]]]);
  function DragMenuOption($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, DragMenuOption);
    const [$$stores, $$cleanup] = setup_stores();
    const $isDragging = () => (validate_store(isDragging, "isDragging"), store_get(isDragging, "$isDragging", $$stores));
    const $grandParentOfSelectedAstElement = () => (validate_store(grandParentOfSelectedAstElement, "grandParentOfSelectedAstElement"), store_get(grandParentOfSelectedAstElement, "$grandParentOfSelectedAstElement", $$stores));
    const $parentOfSelectedAstElement = () => (validate_store(parentOfSelectedAstElement, "parentOfSelectedAstElement"), store_get(parentOfSelectedAstElement, "$parentOfSelectedAstElement", $$stores));
    const $selectedAstElementId = () => (validate_store(selectedAstElementId, "selectedAstElementId"), store_get(selectedAstElementId, "$selectedAstElementId", $$stores));
    const $pageAst = () => (validate_store(pageAst, "pageAst"), store_get(pageAst, "$pageAst", $$stores));
    const $live = () => (validate_store(live, "live"), store_get(live, "$live", $$stores));
    const canBeDragged = mutable_source();
    const dragDirection = mutable_source();
    let element2 = prop($$props, "element", 12);
    let isParent = prop($$props, "isParent", 12, false);
    let originalSiblings;
    let dragHandleElement = mutable_source();
    let dragHandleStyle = mutable_source("");
    let currentHandleCoords;
    let relativeWrapperRect;
    let dragElementInfo;
    function updateHandleCoords(currentRect, isParent2) {
      let appContainer = document.getElementById("ui-builder-app-container");
      if (!appContainer) return;
      relativeWrapperRect = appContainer.closest(".relative").getBoundingClientRect();
      const handlePosition = isParent2 ? "left" : "bottom";
      currentHandleCoords = {
        x: calculateHandleXPosition(currentRect, handlePosition) - relativeWrapperRect.x,
        y: calculateHandleYPosition(currentRect, handlePosition) - relativeWrapperRect.y
      };
    }
    function initSelectedElementDragMenuPosition(selectedDomEl, isParent2 = false) {
      let rect = dragElementInfo ? dragElementInfo.originalSiblingRects[dragElementInfo.selectedIndex] : getBoundingRect(selectedDomEl);
      updateHandleCoords(rect, isParent2);
      let styles = [];
      if (currentHandleCoords?.y) {
        styles.push(`top: ${currentHandleCoords.y}px`);
      }
      if (currentHandleCoords?.x) {
        styles.push(`left: ${currentHandleCoords.x}px`);
      }
      set(dragHandleStyle, styles.join(";"));
    }
    function snapshotSelectedElementSiblings() {
      let siblings = Array.from(element2().parentElement.children);
      let selectedIndex = siblings.indexOf(element2());
      let el = element2().parentElement.cloneNode(true);
      let elChildren = Array.from(el.children);
      for (let i = 0; i < elChildren.length; i++) {
        elChildren[i].setAttribute("data-is-clone", "true");
      }
      dragElementInfo = {
        parentElementClone: el,
        selectedIndex,
        originalSiblingRects: siblings.map((el2, i) => {
          let {
            x,
            y,
            width,
            height,
            top,
            right,
            bottom,
            left
          } = getBoundingRect(el2);
          return {
            x,
            y,
            width,
            height,
            top,
            right,
            bottom,
            left
          };
        }),
        newSiblingRects: null
      };
      const style = element2().parentElement.style;
      style.display = "none";
      element2().parentElement.parentNode.insertBefore(el, element2().parentElement);
      originalSiblings = Array.from(dragElementInfo.parentElementClone.children);
    }
    let mouseDownEvent;
    async function handleMousedown(e) {
      store_set(isDragging, true);
      mouseDownEvent = e;
      document.addEventListener("mousemove", handleMousemove);
      document.addEventListener("mouseup", handleMouseup);
      snapshotSelectedElementSiblings();
    }
    function isComment(n) {
      return strict_equals(n.nodeType, Node.COMMENT_NODE);
    }
    function isElement(n) {
      return strict_equals(n.nodeType, Node.ELEMENT_NODE);
    }
    function isCommentOrElement(n) {
      return isElement(n) || isComment(n);
    }
    function correctIndex(index5) {
      const nodes = Array.from(element2().parentElement.childNodes).filter(isCommentOrElement);
      const elements = Array.from(element2().parentElement.children);
      const targetElement = elements[index5];
      let startIndex = -1;
      let endIndex = -1;
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (isComment(node) && startIndex < 0) {
          startIndex = i;
          continue;
        }
        if (strict_equals(node, targetElement)) {
          endIndex = i;
          if (startIndex < 0) {
            startIndex = i;
          }
          break;
        }
        startIndex = -1;
      }
      return [startIndex, endIndex];
    }
    function applyNewOrder() {
      let parent = isParent() ? $grandParentOfSelectedAstElement() : $parentOfSelectedAstElement();
      if (strict_equals(newIndex, null, false) && strict_equals(newIndex, dragElementInfo.selectedIndex, false) && !!parent) {
        const [startIndex, endIndex] = correctIndex(dragElementInfo.selectedIndex);
        const movedAstNodes = parent.content.splice(startIndex, endIndex - startIndex + 1);
        const [insertIndex] = correctIndex(newIndex);
        parent.content.splice(insertIndex, 0, ...movedAstNodes);
        if (isParent()) {
          let newSelectedIndex = insertIndex + endIndex - startIndex;
          let parts = $selectedAstElementId().split(".");
          parts[parts.length - 2] = newSelectedIndex.toString();
          store_set(selectedAstElementId, parts.join("."));
        } else {
          let newSelectedIndex = insertIndex + endIndex - startIndex;
          let parts = $selectedAstElementId().split(".");
          parts[parts.length - 1] = newSelectedIndex.toString();
          store_set(selectedAstElementId, parts.join("."));
        }
        store_set(pageAst, [...$pageAst()]);
        $live().pushEventTo("#heex-visual-editor", "update_page_ast", { ast: $pageAst() });
      }
    }
    function resetDragElementHandle() {
      if (get(dragHandleElement)) {
        mutate(dragHandleElement, get(dragHandleElement).style.transform = null);
        get(dragHandleElement).style.setProperty("--tw-translate-y", null);
        get(dragHandleElement).style.setProperty("--tw-translate-x", null);
      }
    }
    async function handleMouseup(e) {
      document.removeEventListener("mousemove", handleMousemove);
      document.removeEventListener("mouseup", handleMouseup);
      applyNewOrder();
      if (dragElementInfo) {
        element2(element2().parentElement.style.display = null, true);
        dragElementInfo.parentElementClone.remove();
        dragElementInfo = null;
      }
      mouseDownEvent = null;
      await tick();
      store_set(isDragging, false);
      resetDragElementHandle();
      set(placeholderStyle, null);
      originalSiblings = null;
    }
    function getGhostElement() {
      return dragElementInfo.parentElementClone.children.item(dragElementInfo.selectedIndex);
    }
    function findSwappedIndexes(mouseDiff) {
      let hoveredElementIndex = findHoveredSiblingIndex(mouseDiff, dragElementInfo.originalSiblingRects, dragElementInfo.selectedIndex);
      if (strict_equals(hoveredElementIndex, -1)) {
        return {
          currentIndex: dragElementInfo.selectedIndex,
          destinationIndex: dragElementInfo.selectedIndex
        };
      }
      return {
        currentIndex: dragElementInfo.selectedIndex,
        destinationIndex: hoveredElementIndex
      };
    }
    function repositionSiblings(currentIndex, destinationIndex) {
      let parentElement = dragElementInfo.parentElementClone;
      const children = Array.from(parentElement.children);
      const firstRects = children.map((child2) => child2.getBoundingClientRect());
      const newChildren = [...originalSiblings];
      const element3 = newChildren.splice(currentIndex, 1)[0];
      newChildren.splice(destinationIndex, 0, element3);
      dragElementInfo.parentElementClone.replaceChildren(...newChildren);
      const lastRects = children.map((child2) => child2.getBoundingClientRect());
      children.forEach((child2, i) => {
        if (strict_equals(i, newIndex, false)) {
          const firstRect = firstRects[i];
          const lastRect = lastRects[i];
          const deltaX = firstRect.left - lastRect.left;
          const deltaY = firstRect.top - lastRect.top;
          child2.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
        } else {
          child2.style.transform = `none`;
        }
        child2.style.transition = "transform 0s";
      });
      dragElementInfo.newSiblingRects = Array.from(dragElementInfo.parentElementClone.children).map((e) => e.getBoundingClientRect());
      requestAnimationFrame(() => {
        children.forEach((child2) => {
          child2.style.transition = "transform 0.2s";
          child2.style.transform = "";
        });
      });
    }
    function repositionPlaceholder(destinationIndex) {
      const currentRect = dragElementInfo.newSiblingRects[destinationIndex];
      set(placeholderStyle, `top: ${currentRect.top - relativeWrapperRect.top}px; left: ${currentRect.left - relativeWrapperRect.left}px; height: ${currentRect.height}px; width: ${currentRect.width}px;`);
    }
    function repositionGhostElement(currentIndex, destinationIndex, mouseDiff) {
      const ghostElement = dragElementInfo.parentElementClone.children.item(destinationIndex);
      let xDistance = 0;
      let yDistance = 0;
      if (strict_equals(currentIndex, destinationIndex)) {
        xDistance = mouseDiff.x;
        yDistance = mouseDiff.y;
      } else {
        const oldRect = dragElementInfo.originalSiblingRects[currentIndex];
        const newRect = dragElementInfo.newSiblingRects[destinationIndex];
        xDistance = -(newRect.x - oldRect.x - mouseDiff.x);
        yDistance = -(newRect.y - oldRect.y - mouseDiff.y);
      }
      ghostElement.style.transition = "none";
      ghostElement.style.transform = `translate(${xDistance}px,${yDistance}px)`;
    }
    function repositionDragHandle(mouseDiff) {
      get(dragHandleElement).style.setProperty("--tw-translate-x", `${mouseDiff.x}px`);
      get(dragHandleElement).style.setProperty("--tw-translate-y", `${mouseDiff.y}px`);
    }
    let placeholderStyle = mutable_source(null);
    let newIndex = null;
    function updateSiblingsPositioning(mouseDiff) {
      if (!relativeWrapperRect) {
        relativeWrapperRect = document.getElementById("ui-builder-app-container").closest(".relative").getBoundingClientRect();
      }
      let { currentIndex, destinationIndex } = findSwappedIndexes(mouseDiff);
      if (strict_equals(newIndex, destinationIndex, false)) {
        repositionSiblings(currentIndex, destinationIndex);
        repositionPlaceholder(destinationIndex);
        newIndex = destinationIndex;
      }
      repositionGhostElement(currentIndex, destinationIndex, mouseDiff);
    }
    function handleMousemove(e) {
      let ghostElement = getGhostElement();
      let dragDirection2 = getDragDirection(ghostElement);
      let mouseDiff = {
        x: strict_equals(dragDirection2, "vertical") ? 0 : e.x - mouseDownEvent.x,
        y: strict_equals(dragDirection2, "horizontal") ? 0 : e.y - mouseDownEvent.y
      };
      updateSiblingsPositioning(mouseDiff);
      repositionDragHandle(mouseDiff);
    }
    legacy_pre_effect(() => deep_read_state(element2()), () => {
      set(canBeDragged, element2()?.parentElement?.children?.length > 1);
    });
    legacy_pre_effect(
      () => (getDragDirection, deep_read_state(element2())),
      () => {
        set(dragDirection, getDragDirection(element2()));
      }
    );
    legacy_pre_effect(
      () => (deep_read_state(element2()), deep_read_state(isParent())),
      () => {
        !!element2() && initSelectedElementDragMenuPosition(element2(), isParent());
      }
    );
    legacy_pre_effect_reset();
    init2();
    var fragment = comment();
    var node_1 = first_child(fragment);
    {
      var consequent_1 = ($$anchor2) => {
        var fragment_1 = root_13();
        var node_2 = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var div = root_22();
            template_effect(() => set_style(div, `background-color:aqua; opacity: 0.5; ${get(placeholderStyle) ?? ""}`));
            append($$anchor3, div);
          };
          if_block(node_2, ($$render) => {
            if (get(placeholderStyle)) $$render(consequent);
          });
        }
        var button = sibling(node_2, 2);
        var span = child(button);
        let classes;
        reset(button);
        bind_this(button, ($$value) => set(dragHandleElement, $$value), () => get(dragHandleElement));
        template_effect(
          ($0) => {
            set_style(button, get(dragHandleStyle));
            set_attribute(button, "data-testid", `drag-button${(isParent() ? "-parent" : "") ?? ""}`);
            set_attribute(button, "aria-label", `Drag to ${strict_equals(get(dragDirection), "horizontal") ? "reorder horizontally" : strict_equals(get(dragDirection), "vertical") ? "reorder vertically" : "reorder in any direction"}`);
            classes = set_class(span, 1, "", null, classes, $0);
          },
          [
            () => ({
              "hero-arrows-right-left": strict_equals(get(dragDirection), "horizontal"),
              "hero-arrows-up-down": strict_equals(get(dragDirection), "vertical"),
              "hero-arrows-pointing-out": strict_equals(get(dragDirection), "both")
            })
          ],
          derived_safe_equal
        );
        event("mousedown", button, handleMousedown);
        append($$anchor2, fragment_1);
      };
      if_block(node_1, ($$render) => {
        if (get(canBeDragged)) $$render(consequent_1);
      });
    }
    append($$anchor, fragment);
    var $$pop = pop({
      get element() {
        return element2();
      },
      set element($$value) {
        element2($$value);
        flushSync();
      },
      get isParent() {
        return isParent();
      },
      set isParent($$value) {
        isParent($$value);
        flushSync();
      },
      ...legacy_api()
    });
    $$cleanup();
    return $$pop;
  }
  mark_module_end(DragMenuOption);
  create_custom_element(DragMenuOption, { element: {}, isParent: {} }, [], [], true);

  // svelte/utils/drag-helpers.ts
  function elementCanBeDroppedInTarget(draggedComponentDefinition2) {
    return true;
  }
  function detectFlow(rects) {
    const sortedByLeft = [...rects].sort((a, b) => a.left - b.left);
    const sortedByTop = [...rects].sort((a, b) => a.top - b.top);
    const avgHorizontalDiff = getAverageDifference(sortedByLeft, "left");
    const avgVerticalDiff = getAverageDifference(sortedByTop, "top");
    if (avgHorizontalDiff > avgVerticalDiff) {
      const isCenteredHorizontally = checkVerticalCenterAlignment(sortedByLeft);
      return isCenteredHorizontally ? "horizontal" : "both";
    } else if (avgVerticalDiff > avgHorizontalDiff) {
      return "vertical";
    }
    return "both";
  }
  function getAverageDifference(rects, property) {
    let totalDiff = 0;
    for (let i = 1; i < rects.length; i++) {
      totalDiff += Math.abs(rects[i][property] - rects[i - 1][property]);
    }
    return totalDiff / (rects.length - 1);
  }
  function checkVerticalCenterAlignment(rects) {
    const centers = rects.map((rect) => (rect.top + rect.bottom) / 2);
    const minCenter = Math.min(...centers);
    const maxCenter = Math.max(...centers);
    return maxCenter - minCenter < 17;
  }
  function getDragDirection(element2) {
    let parentEl = element2?.parentElement;
    if (!parentEl) {
      return "vertical";
    }
    const siblings = Array.from(parentEl.children);
    const rects = siblings.map((el) => el.getBoundingClientRect());
    return detectFlow(rects);
  }
  function getBoundingRect(el) {
    if (window.getComputedStyle(el).display === "contents") {
      if (el.children.length === 1) {
        return el.children[0].getBoundingClientRect();
      }
      const rects = Array.from(el.children).map((e) => e.getBoundingClientRect());
      let top = Math.min(...rects.map((r2) => r2.top));
      let bottom = Math.max(...rects.map((r2) => r2.bottom));
      let left = Math.min(...rects.map((r2) => r2.left));
      let right = Math.max(...rects.map((r2) => r2.right));
      return {
        x: Math.min(...rects.map((r2) => r2.x)),
        y: Math.min(...rects.map((r2) => r2.y)),
        top,
        right,
        bottom,
        left,
        width: right - left,
        height: bottom - top
      };
    }
    return el.getBoundingClientRect();
  }
  function findHoveredSiblingIndex(mouseDiff, siblingRects, selectedIndex) {
    const currentRect = offsetRect(siblingRects[selectedIndex], mouseDiff);
    let bestMatchIndex = selectedIndex;
    let bestOverlapScore = 0;
    for (let i = 0; i < siblingRects.length; i++) {
      if (i !== selectedIndex) {
        const rect = siblingRects[i];
        const overlap = calculateOverlap(rect, currentRect);
        if (overlap === 0) {
          continue;
        }
        if (overlap > bestOverlapScore) {
          bestOverlapScore = overlap;
          bestMatchIndex = i;
          continue;
        }
        if (overlap === bestOverlapScore) {
          let currentMatch = siblingRects[bestMatchIndex];
          if (calculateCenterDistance(rect, currentMatch) < calculateCenterDistance(currentRect, currentMatch)) {
            bestMatchIndex = i;
          }
        }
      }
    }
    return bestMatchIndex;
  }
  function calculateOverlap(rect, draggedRect) {
    const xOverlap = Math.max(0, Math.min(rect.right, draggedRect.right) - Math.max(rect.left, draggedRect.left));
    const yOverlap = Math.max(0, Math.min(rect.bottom, draggedRect.bottom) - Math.max(rect.top, draggedRect.top));
    const overlapArea = xOverlap * yOverlap;
    const rectArea = rect.width * rect.height;
    const draggedRectArea = draggedRect.width * draggedRect.height;
    const minArea = Math.min(rectArea, draggedRectArea);
    return 100 * overlapArea / minArea;
  }
  function calculateCenterDistance(rect1, rect2) {
    return calculateDistance(calculateCenter(rect1), calculateCenter(rect2));
  }
  function calculateCenter(rect) {
    return {
      x: rect.left + rect.width / 2,
      y: rect.top + rect.height / 2
    };
  }
  function calculateDistance(point1, point2) {
    return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
  }
  function offsetRect(rect, mouseDiff) {
    const newRect = { ...rect };
    newRect.x += mouseDiff.x;
    newRect.left += mouseDiff.x;
    newRect.right += mouseDiff.x;
    newRect.y += mouseDiff.y;
    newRect.top += mouseDiff.y;
    newRect.bottom += mouseDiff.y;
    return newRect;
  }

  // svelte/components/PageAstNode.svelte
  mark_module_start();
  PageAstNode[FILENAME] = "svelte/components/PageAstNode.svelte";
  var root_8 = add_locations(template(`<div tabindex="0" role="button"><!></div>`), PageAstNode[FILENAME], [[130, 4]]);
  var root_132 = add_locations(template(`<div class="dragged-element-placeholder svelte-fu018p">Preview</div>`), PageAstNode[FILENAME], [[171, 10]]);
  var root_11 = add_locations(template(`<!> <!>`, 1), PageAstNode[FILENAME], []);
  var $$css2 = {
    hash: "svelte-fu018p",
    code: "\n  .dragged-element-placeholder.svelte-fu018p {\n    outline: 2px dashed red;\n\n    /* Disable pointer events to block out any dragOver event triggers on the placeholder while dragging */\n    pointer-events: none;\n  }\n\n  .embedded-iframe {\n    display: inline;\n  }\n\n  .embedded-iframe > iframe {\n    pointer-events: none;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFnZUFzdE5vZGUuc3ZlbHRlIiwibWFwcGluZ3MiOiI7QUE0TUEsRUFBRSwwQ0FBNEIsQ0FBQztBQUMvQixJQUFJLHVCQUF1Qjs7QUFFM0I7QUFDQSxJQUFJLG9CQUFvQjtBQUN4Qjs7QUFFQSxFQUFVLGdCQUFpQixDQUFDO0FBQzVCLElBQUksZUFBZTtBQUNuQjs7QUFFQSxFQUFVLHlCQUEwQixDQUFDO0FBQ3JDLElBQUksb0JBQW9CO0FBQ3hCIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJQYWdlQXN0Tm9kZS5zdmVsdGUiXX0= */"
  };
  function PageAstNode($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, PageAstNode);
    append_styles2($$anchor, $$css2);
    const [$$stores, $$cleanup] = setup_stores();
    const $slotTargetElement = () => (validate_store(slotTargetElement, "slotTargetElement"), store_get(slotTargetElement, "$slotTargetElement", $$stores));
    const $selectedAstElement = () => (validate_store(selectedAstElement, "selectedAstElement"), store_get(selectedAstElement, "$selectedAstElement", $$stores));
    const $highlightedAstElement = () => (validate_store(highlightedAstElement, "highlightedAstElement"), store_get(highlightedAstElement, "$highlightedAstElement", $$stores));
    const $draggedComponentDefinition = () => (validate_store(draggedComponentDefinition, "draggedComponentDefinition"), store_get(draggedComponentDefinition, "$draggedComponentDefinition", $$stores));
    const isDragTarget = mutable_source();
    const isSelectedNode = mutable_source();
    const isHighlightedNode = mutable_source();
    const isEditable = mutable_source();
    const isParentOfSelectedNode = mutable_source();
    const htmlWrapperHasMultipleElements = mutable_source();
    const htmlWrapperHasIframe = mutable_source();
    let node = prop($$props, "node", 12);
    let nodeId = prop($$props, "nodeId", 12);
    let htmlWrapper = mutable_source();
    let domElement = mutable_source();
    let previewDropInside;
    let children = mutable_source();
    function handleDragEnter() {
      if ($draggedComponentDefinition()) {
        if (isAstElement(node()) && elementCanBeDroppedInTarget($draggedComponentDefinition())) {
          store_set(slotTargetElement, node());
        }
      }
    }
    function handleDragLeave() {
      if (isAstElement(node()) && elementCanBeDroppedInTarget($draggedComponentDefinition()) && strict_equals($slotTargetElement(), node())) {
        store_set(slotTargetElement, void 0);
      }
    }
    function handleMouseOver() {
      if (!$selectedAstElement()) {
        isAstElement(node()) && store_set(highlightedAstElement, node());
      }
    }
    function handleMouseOut() {
      store_set(highlightedAstElement, void 0);
    }
    function handleClick({ currentTarget }) {
      if (currentTarget instanceof Element) {
        setSelection(nodeId());
        setSelectedDom(currentTarget);
      }
    }
    function handleContentEdited({ target }) {
      if (!(target instanceof HTMLElement)) return;
      let children2 = target.children;
      if (!isAstElement(node())) {
        return;
      }
      if (strict_equals(children2.length, 0)) {
        if (strict_equals(target.innerText, node().content, false)) {
          updateNodeContent(node(), target.innerText);
        }
      } else {
        let tmpClone = target.cloneNode(true);
        Array.from(tmpClone.children).forEach((c) => tmpClone.removeChild(c));
        let stringChildIndex = node().content.findIndex((e) => strict_equals(typeof e, "string"));
        let newText = tmpClone.textContent?.trim() || "";
        if (strict_equals(node().content[stringChildIndex], newText, false)) {
          node(node().content[stringChildIndex] = newText, true);
          updateAst();
        }
      }
    }
    function highlightContent(wrapperDiv, { selected, highlighted }) {
      let startsWithOneChildren = strict_equals(wrapperDiv.children.length, 1);
      if (startsWithOneChildren) {
        let child2 = wrapperDiv.children[0];
        child2.setAttribute("data-selected", String(selected));
        child2.setAttribute("data-highlighted", String(highlighted));
      }
      return {
        update({ selected: selected2, highlighted: highlighted2 }) {
          if (strict_equals(wrapperDiv.children.length, 1)) {
            let child2 = wrapperDiv.children[0];
            child2.setAttribute("data-selected", String(selected2));
            child2.setAttribute("data-highlighted", String(highlighted2));
          } else if (strict_equals(wrapperDiv.children.length, 0) && strict_equals(wrapperDiv.childNodes.length, 1)) {
            wrapperDiv.setAttribute("data-nochildren", "true");
            wrapperDiv.setAttribute("data-selected", String(selected2));
            wrapperDiv.setAttribute("data-highlighted", String(highlighted2));
          } else if (startsWithOneChildren) {
            Array.from(wrapperDiv.children).forEach((child2) => {
              child2.removeAttribute("data-selected");
              child2.removeAttribute("data-highlighted");
            });
          }
        },
        destroy() {
        }
      };
    }
    legacy_pre_effect(
      () => ($slotTargetElement(), deep_read_state(node())),
      () => {
        set(isDragTarget, strict_equals($slotTargetElement(), node()));
      }
    );
    legacy_pre_effect(
      () => ($selectedAstElement(), deep_read_state(node())),
      () => {
        set(isSelectedNode, strict_equals($selectedAstElement(), node()));
      }
    );
    legacy_pre_effect(
      () => ($highlightedAstElement(), deep_read_state(node())),
      () => {
        set(isHighlightedNode, strict_equals($highlightedAstElement(), node()));
      }
    );
    legacy_pre_effect(
      () => (get(isSelectedNode), isAstElement, deep_read_state(node())),
      () => {
        set(isEditable, get(isSelectedNode) && isAstElement(node()) && Array.isArray(node().content) && strict_equals(node().content.filter((e) => strict_equals(typeof e, "string")).length, 1) && !node().attrs?.selfClose);
      }
    );
    legacy_pre_effect(
      () => (isAstElement, deep_read_state(node()), $selectedAstElement()),
      () => {
        set(isParentOfSelectedNode, isAstElement(node()) && Array.isArray(node().content) ? node().content.includes($selectedAstElement()) : false);
      }
    );
    legacy_pre_effect(
      () => (isAstElement, deep_read_state(node())),
      () => {
        if (isAstElement(node())) {
          set(children, node().content);
        }
      }
    );
    legacy_pre_effect(() => get(htmlWrapper), () => {
      set(htmlWrapperHasMultipleElements, (() => {
        return !!get(htmlWrapper) && get(htmlWrapper).childElementCount > 1;
      })());
    });
    legacy_pre_effect(() => get(htmlWrapper), () => {
      set(htmlWrapperHasIframe, (() => {
        return !!get(htmlWrapper) && get(htmlWrapper).getElementsByTagName("iframe").length > 0;
      })());
    });
    legacy_pre_effect(
      () => (get(isSelectedNode), setSelectedDom, get(domElement), get(htmlWrapper)),
      () => {
        if (get(isSelectedNode)) {
          setSelectedDom(get(domElement) || get(htmlWrapper));
        }
      }
    );
    legacy_pre_effect_reset();
    init2();
    var fragment = comment();
    var node_1 = first_child(fragment);
    {
      var consequent_6 = ($$anchor2) => {
        var fragment_1 = comment();
        var node_2 = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            html(node_3, () => "<!--" + node().content + "-->", false, false);
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3, $$elseif) => {
            {
              var consequent_1 = ($$anchor4) => {
                var fragment_3 = comment();
                var node_4 = first_child(fragment_3);
                html(node_4, () => "<!--" + node().content + "-->", false, false);
                append($$anchor4, fragment_3);
              };
              var alternate_1 = ($$anchor4, $$elseif2) => {
                {
                  var consequent_2 = ($$anchor5) => {
                    var fragment_4 = comment();
                    var node_5 = first_child(fragment_4);
                    slot(node_5, $$props, "default", {}, null);
                    append($$anchor5, fragment_4);
                  };
                  var alternate_2 = ($$anchor5, $$elseif3) => {
                    {
                      var consequent_3 = ($$anchor6) => {
                        var div = root_8();
                        let classes;
                        var node_6 = child(div);
                        html(node_6, () => node().rendered_html, false, false);
                        reset(div);
                        bind_this(div, ($$value) => set(htmlWrapper, $$value), () => get(htmlWrapper));
                        effect(() => event("mouseover", div, stopPropagation(handleMouseOver)));
                        effect(() => event("mouseout", div, stopPropagation(handleMouseOut)));
                        effect(() => event("focus", div, stopPropagation(handleMouseOver)));
                        effect(() => event("blur", div, stopPropagation(handleMouseOut)));
                        effect(() => event("click", div, preventDefault(stopPropagation(handleClick))));
                        effect(() => event("keydown", div, preventDefault(stopPropagation((e) => strict_equals(e.key, "Enter") && handleClick(e)))));
                        action(div, ($$node, $$action_arg) => highlightContent?.($$node, $$action_arg), () => ({
                          selected: get(isSelectedNode),
                          highlighted: get(isHighlightedNode)
                        }));
                        template_effect(
                          ($0) => {
                            set_attribute(div, "data-selected", get(isSelectedNode));
                            classes = set_class(div, 1, "", null, classes, $0);
                          },
                          [
                            () => ({
                              contents: get(htmlWrapperHasMultipleElements),
                              "embedded-iframe": get(htmlWrapperHasIframe)
                            })
                          ],
                          derived_safe_equal
                        );
                        append($$anchor6, div);
                      };
                      var alternate_3 = ($$anchor6) => {
                        var fragment_5 = comment();
                        var node_7 = first_child(fragment_5);
                        validate_void_dynamic_element(() => node().tag);
                        validate_dynamic_element_tag(() => node().tag);
                        element(
                          node_7,
                          () => node().tag,
                          false,
                          ($$element, $$anchor7) => {
                            bind_this($$element, ($$value) => set(domElement, $$value), () => get(domElement));
                            let attributes;
                            template_effect(() => attributes = set_attributes($$element, attributes, {
                              class: "relative",
                              ...node().attrs,
                              "data-selected": get(isSelectedNode),
                              "data-selected-parent": get(isParentOfSelectedNode),
                              "data-highlighted": get(isHighlightedNode),
                              "data-slot-target": get(isDragTarget),
                              contenteditable: get(isEditable)
                            }));
                            event("blur", $$element, handleContentEdited);
                            event("dragenter", $$element, stopPropagation(handleDragEnter));
                            event("dragleave", $$element, stopPropagation(handleDragLeave));
                            event("mouseover", $$element, stopPropagation(handleMouseOver));
                            event("mouseout", $$element, stopPropagation(handleMouseOut));
                            event("click", $$element, preventDefault(stopPropagation(handleClick)));
                            var fragment_6 = comment();
                            var node_8 = first_child(fragment_6);
                            {
                              var consequent_5 = ($$anchor8) => {
                                var fragment_7 = root_11();
                                var node_9 = first_child(fragment_7);
                                each(node_9, 1, () => get(children), index2, ($$anchor9, child2, childIndex) => {
                                  var fragment_8 = comment();
                                  var node_10 = first_child(fragment_8);
                                  PageAstNode(node_10, {
                                    get node() {
                                      return get(child2);
                                    },
                                    get nodeId() {
                                      return `${nodeId() ?? ""}.${childIndex ?? ""}`;
                                    }
                                  });
                                  append($$anchor9, fragment_8);
                                });
                                var node_11 = sibling(node_9, 2);
                                {
                                  var consequent_4 = ($$anchor9) => {
                                    var div_1 = root_132();
                                    append($$anchor9, div_1);
                                  };
                                  if_block(node_11, ($$render) => {
                                    if (get(isDragTarget) && $draggedComponentDefinition()) $$render(consequent_4);
                                  });
                                }
                                append($$anchor8, fragment_7);
                              };
                              if_block(node_8, ($$render) => {
                                if (!node().attrs?.selfClose) $$render(consequent_5);
                              });
                            }
                            append($$anchor7, fragment_6);
                          },
                          void 0,
                          [148, 4]
                        );
                        append($$anchor6, fragment_5);
                      };
                      if_block(
                        $$anchor5,
                        ($$render) => {
                          if (node().rendered_html) $$render(consequent_3);
                          else $$render(alternate_3, false);
                        },
                        $$elseif3
                      );
                    }
                  };
                  if_block(
                    $$anchor4,
                    ($$render) => {
                      if (strict_equals(node().tag, "eex") && strict_equals(node().content[0], "@inner_content")) $$render(consequent_2);
                      else $$render(alternate_2, false);
                    },
                    $$elseif2
                  );
                }
              };
              if_block(
                $$anchor3,
                ($$render) => {
                  if (strict_equals(node().tag, "eex_comment")) $$render(consequent_1);
                  else $$render(alternate_1, false);
                },
                $$elseif
              );
            }
          };
          if_block(node_2, ($$render) => {
            if (strict_equals(node().tag, "html_comment")) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor2, fragment_1);
      };
      var alternate_4 = ($$anchor2) => {
        var text2 = text();
        template_effect(() => set_text(text2, node()));
        append($$anchor2, text2);
      };
      if_block(node_1, ($$render) => {
        if (isAstElement(node())) $$render(consequent_6);
        else $$render(alternate_4, false);
      });
    }
    append($$anchor, fragment);
    var $$pop = pop({
      get node() {
        return node();
      },
      set node($$value) {
        node($$value);
        flushSync();
      },
      get nodeId() {
        return nodeId();
      },
      set nodeId($$value) {
        nodeId($$value);
        flushSync();
      },
      ...legacy_api()
    });
    $$cleanup();
    return $$pop;
  }
  mark_module_end(PageAstNode);
  create_custom_element(PageAstNode, { node: {}, nodeId: {} }, ["default"], [], true);

  // svelte/components/PagePreview.svelte
  var PagePreview_exports = {};
  __export(PagePreview_exports, {
    default: () => PagePreview
  });
  mark_module_start();
  PagePreview[FILENAME] = "svelte/components/PagePreview.svelte";
  var root_23 = add_locations(template(`<div role="document" style="--outlined-id: title-1" id="fake-browser-content" data-testid="browser-content"><div id="page-wrapper" class="p-1 m-1"><page-wrapper></page-wrapper></div></div>`, 2), PagePreview[FILENAME], [
    [63, 6, [[73, 8, [[74, 10]]]]]
  ]);
  var root5 = add_locations(template(`<div class="flex-1 px-8 pb-4 flex max-h-full" data-testid="main"><!></div>`), PagePreview[FILENAME], [[60, 0]]);
  var $$css3 = {
    hash: "svelte-r4h6jy",
    code: '\n  .contents[data-nochildren="true"], .contents[data-nochildren="true"] {\n    /* In the specific case of an element containing only an EEX expression that generates no children (only a text node),\n    there is no child node to which apply the styles, so we have to apply them to the wrapper, so we have to overwrite the\n    display: contents for the styles to apply */\n    display: inline;\n  }\n  [data-slot-target="true"] {\n    outline-color: red;\n    outline-width: 2px;\n    outline-style: dashed;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFnZVByZXZpZXcuc3ZlbHRlIiwibWFwcGluZ3MiOiI7QUFzR0EsRUFBVSxvRUFBcUUsQ0FBQztBQUNoRjtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQSxFQUFVLHlCQUEwQixDQUFDO0FBQ3JDLElBQUksa0JBQWtCO0FBQ3RCLElBQUksa0JBQWtCO0FBQ3RCLElBQUkscUJBQXFCO0FBQ3pCIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJQYWdlUHJldmlldy5zdmVsdGUiXX0= */'
  };
  function PagePreview($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, PagePreview);
    append_styles2($$anchor, $$css3);
    const [$$stores, $$cleanup] = setup_stores();
    const $currentComponentCategory = () => (validate_store(currentComponentCategory, "currentComponentCategory"), store_get(currentComponentCategory, "$currentComponentCategory", $$stores));
    const $draggedComponentDefinition = () => (validate_store(draggedComponentDefinition, "draggedComponentDefinition"), store_get(draggedComponentDefinition, "$draggedComponentDefinition", $$stores));
    const $live = () => (validate_store(live, "live"), store_get(live, "$live", $$stores));
    const $pageAst = () => (validate_store(pageAst, "pageAst"), store_get(pageAst, "$pageAst", $$stores));
    const $slotTargetElement = () => (validate_store(slotTargetElement, "slotTargetElement"), store_get(slotTargetElement, "$slotTargetElement", $$stores));
    const $selectedAstElementId = () => (validate_store(selectedAstElementId, "selectedAstElementId"), store_get(selectedAstElementId, "$selectedAstElementId", $$stores));
    let isDraggingOver = mutable_source(false);
    async function handleDragDrop(e) {
      const target = e.target;
      const layoutZone = e.dataTransfer?.getData("layoutZone");
      store_set(currentComponentCategory, null);
      if (!$draggedComponentDefinition()) return;
      let draggedObj = $draggedComponentDefinition();
      if (layoutZone) {
        $live().pushEventTo("#heex-visual-editor", "render_component_in_page", { component_id: draggedObj.id }, ({ ast }) => {
          const newAst = strict_equals(layoutZone, "preamble") ? [...ast, ...$pageAst()] : [...$pageAst(), ...ast];
          $live().pushEventTo("#heex-visual-editor", "update_page_ast", { ast: newAst });
        });
      } else if (strict_equals(target.id, "fake-browser-content", false) && elementCanBeDroppedInTarget(draggedObj)) {
        if (!(target instanceof HTMLElement) || !$slotTargetElement() || $slotTargetElement().attrs.selfClose) {
          resetDragDrop();
          return;
        }
        addBasicComponentToTarget($slotTargetElement());
      } else {
        $live().pushEventTo("#heex-visual-editor", "render_component_in_page", { component_id: draggedObj.id }, ({ ast }) => {
          $live().pushEventTo("#heex-visual-editor", "update_page_ast", { ast: [...$pageAst(), ...ast] });
        });
      }
      resetDragDrop();
    }
    async function addBasicComponentToTarget(astElement) {
      if (!$draggedComponentDefinition()) return;
      let componentDefinition = $draggedComponentDefinition();
      store_set(draggedComponentDefinition, null);
      let targetNode = astElement;
      $live().pushEventTo("#heex-visual-editor", "render_component_in_page", { component_id: componentDefinition.id }, ({ ast }) => {
        targetNode?.content.push(...ast);
        store_set(slotTargetElement, void 0);
        $live().pushEventTo("#heex-visual-editor", "update_page_ast", { ast: $pageAst() });
      });
    }
    function dragOver() {
      set(isDraggingOver, true);
    }
    function resetDragDrop() {
      resetDrag();
      set(isDraggingOver, false);
    }
    init2();
    var div = root5();
    var node = child(div);
    {
      var consequent = ($$anchor2) => {
        BrowserFrame($$anchor2, {
          children: wrap_snippet(PagePreview, ($$anchor3, $$slotProps) => {
            var div_1 = root_23();
            var div_2 = child(div_1);
            var page_wrapper = child(div_2);
            set_class(page_wrapper, 1, "relative");
            reset(div_2);
            reset(div_1);
            template_effect(() => {
              set_class(div_1, 1, `bg-white rounded-b-xl relative overflow-hidden flex-1 ${get(isDraggingOver) && "border-dashed border-blue-500 border-2"}`);
              set_attribute(div_2, "data-selected", strict_equals($selectedAstElementId(), "root"));
            });
            event("drop", div_1, preventDefault(handleDragDrop));
            event("dragover", div_1, preventDefault(dragOver));
            append($$anchor3, div_1);
          }),
          $$slots: { default: true }
        });
      };
      if_block(node, ($$render) => {
        if ($pageAst()) $$render(consequent);
      });
    }
    reset(div);
    append($$anchor, div);
    var $$pop = pop({ ...legacy_api() });
    $$cleanup();
    return $$pop;
  }
  mark_module_end(PagePreview);
  create_custom_element(PagePreview, {}, [], [], true);

  // svelte/components/PageWrapper.svelte
  var PageWrapper_exports = {};
  __export(PageWrapper_exports, {
    default: () => PageWrapper
  });

  // svelte/stores/tailwindConfig.ts
  var tailwindConfig = writable();

  // svelte/stores/tailwindInput.ts
  var tailwindInput = writable();

  // node_modules/postcss/lib/postcss.mjs
  var import_postcss = __toESM(require_postcss(), 1);
  var postcss_default = import_postcss.default;
  var stringify = import_postcss.default.stringify;
  var fromJSON = import_postcss.default.fromJSON;
  var plugin = import_postcss.default.plugin;
  var parse = import_postcss.default.parse;
  var list = import_postcss.default.list;
  var document2 = import_postcss.default.document;
  var comment2 = import_postcss.default.comment;
  var atRule = import_postcss.default.atRule;
  var rule = import_postcss.default.rule;
  var decl = import_postcss.default.decl;
  var root6 = import_postcss.default.root;
  var CssSyntaxError = import_postcss.default.CssSyntaxError;
  var Declaration = import_postcss.default.Declaration;
  var Container = import_postcss.default.Container;
  var Processor = import_postcss.default.Processor;
  var Document = import_postcss.default.Document;
  var Comment2 = import_postcss.default.Comment;
  var Warning = import_postcss.default.Warning;
  var AtRule = import_postcss.default.AtRule;
  var Result = import_postcss.default.Result;
  var Input = import_postcss.default.Input;
  var Rule = import_postcss.default.Rule;
  var Root = import_postcss.default.Root;
  var Node2 = import_postcss.default.Node;

  // node_modules/@mhsdesign/jit-browser-tailwindcss/dist/module.esm.js
  var import_postcss_selector_parser = __toESM(require_dist(), 1);
  var import_postcss_nested = __toESM(require_postcss_nested(), 1);

  // node_modules/postcss-js/index.mjs
  var import_index3 = __toESM(require_postcss_js(), 1);
  var postcss_js_default = import_index3.default;
  var objectify = import_index3.default.objectify;
  var parse2 = import_index3.default.parse;
  var async = import_index3.default.async;
  var sync = import_index3.default.sync;

  // node_modules/@mhsdesign/jit-browser-tailwindcss/dist/module.esm.js
  var import_postcss_selector_parser2 = __toESM(require_dist(), 1);
  var import_postcss_selector_parser3 = __toESM(require_dist(), 1);
  var import_unesc = __toESM(require_unesc(), 1);
  var import_postcss_selector_parser4 = __toESM(require_dist(), 1);
  var import_dlv = __toESM(require_dlv_umd(), 1);
  var import_postcss_selector_parser5 = __toESM(require_dist(), 1);
  var import_postcss_selector_parser6 = __toESM(require_dist(), 1);
  var import_postcss_selector_parser7 = __toESM(require_dist(), 1);
  var import_dlv2 = __toESM(require_dlv_umd(), 1);
  var import_didyoumean = __toESM(require_didYouMean_1_2_1(), 1);
  var import_postcss_selector_parser8 = __toESM(require_dist(), 1);
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __commonJS2 = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps2 = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
    isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var require_quick_lru = __commonJS2({
    "node_modules/@alloc/quick-lru/index.js"(exports, module) {
      "use strict";
      var QuickLRU = class {
        constructor(options = {}) {
          if (!(options.maxSize && options.maxSize > 0)) {
            throw new TypeError("`maxSize` must be a number greater than 0");
          }
          if (typeof options.maxAge === "number" && options.maxAge === 0) {
            throw new TypeError("`maxAge` must be a number greater than 0");
          }
          this.maxSize = options.maxSize;
          this.maxAge = options.maxAge || Infinity;
          this.onEviction = options.onEviction;
          this.cache = /* @__PURE__ */ new Map();
          this.oldCache = /* @__PURE__ */ new Map();
          this._size = 0;
        }
        _emitEvictions(cache2) {
          if (typeof this.onEviction !== "function") {
            return;
          }
          for (const [key, item] of cache2) {
            this.onEviction(key, item.value);
          }
        }
        _deleteIfExpired(key, item) {
          if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
            if (typeof this.onEviction === "function") {
              this.onEviction(key, item.value);
            }
            return this.delete(key);
          }
          return false;
        }
        _getOrDeleteIfExpired(key, item) {
          const deleted = this._deleteIfExpired(key, item);
          if (deleted === false) {
            return item.value;
          }
        }
        _getItemValue(key, item) {
          return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
        }
        _peek(key, cache2) {
          const item = cache2.get(key);
          return this._getItemValue(key, item);
        }
        _set(key, value2) {
          this.cache.set(key, value2);
          this._size++;
          if (this._size >= this.maxSize) {
            this._size = 0;
            this._emitEvictions(this.oldCache);
            this.oldCache = this.cache;
            this.cache = /* @__PURE__ */ new Map();
          }
        }
        _moveToRecent(key, item) {
          this.oldCache.delete(key);
          this._set(key, item);
        }
        *_entriesAscending() {
          for (const item of this.oldCache) {
            const [key, value2] = item;
            if (!this.cache.has(key)) {
              const deleted = this._deleteIfExpired(key, value2);
              if (deleted === false) {
                yield item;
              }
            }
          }
          for (const item of this.cache) {
            const [key, value2] = item;
            const deleted = this._deleteIfExpired(key, value2);
            if (deleted === false) {
              yield item;
            }
          }
        }
        get(key) {
          if (this.cache.has(key)) {
            const item = this.cache.get(key);
            return this._getItemValue(key, item);
          }
          if (this.oldCache.has(key)) {
            const item = this.oldCache.get(key);
            if (this._deleteIfExpired(key, item) === false) {
              this._moveToRecent(key, item);
              return item.value;
            }
          }
        }
        set(key, value2, { maxAge = this.maxAge === Infinity ? void 0 : Date.now() + this.maxAge } = {}) {
          if (this.cache.has(key)) {
            this.cache.set(key, {
              value: value2,
              maxAge
            });
          } else {
            this._set(key, { value: value2, expiry: maxAge });
          }
        }
        has(key) {
          if (this.cache.has(key)) {
            return !this._deleteIfExpired(key, this.cache.get(key));
          }
          if (this.oldCache.has(key)) {
            return !this._deleteIfExpired(key, this.oldCache.get(key));
          }
          return false;
        }
        peek(key) {
          if (this.cache.has(key)) {
            return this._peek(key, this.cache);
          }
          if (this.oldCache.has(key)) {
            return this._peek(key, this.oldCache);
          }
        }
        delete(key) {
          const deleted = this.cache.delete(key);
          if (deleted) {
            this._size--;
          }
          return this.oldCache.delete(key) || deleted;
        }
        clear() {
          this.cache.clear();
          this.oldCache.clear();
          this._size = 0;
        }
        resize(newSize) {
          if (!(newSize && newSize > 0)) {
            throw new TypeError("`maxSize` must be a number greater than 0");
          }
          const items = [...this._entriesAscending()];
          const removeCount = items.length - newSize;
          if (removeCount < 0) {
            this.cache = new Map(items);
            this.oldCache = /* @__PURE__ */ new Map();
            this._size = items.length;
          } else {
            if (removeCount > 0) {
              this._emitEvictions(items.slice(0, removeCount));
            }
            this.oldCache = new Map(items.slice(removeCount));
            this.cache = /* @__PURE__ */ new Map();
            this._size = 0;
          }
          this.maxSize = newSize;
        }
        *keys() {
          for (const [key] of this) {
            yield key;
          }
        }
        *values() {
          for (const [, value2] of this) {
            yield value2;
          }
        }
        *[Symbol.iterator]() {
          for (const item of this.cache) {
            const [key, value2] = item;
            const deleted = this._deleteIfExpired(key, value2);
            if (deleted === false) {
              yield [key, value2.value];
            }
          }
          for (const item of this.oldCache) {
            const [key, value2] = item;
            if (!this.cache.has(key)) {
              const deleted = this._deleteIfExpired(key, value2);
              if (deleted === false) {
                yield [key, value2.value];
              }
            }
          }
        }
        *entriesDescending() {
          let items = [...this.cache];
          for (let i = items.length - 1; i >= 0; --i) {
            const item = items[i];
            const [key, value2] = item;
            const deleted = this._deleteIfExpired(key, value2);
            if (deleted === false) {
              yield [key, value2.value];
            }
          }
          items = [...this.oldCache];
          for (let i = items.length - 1; i >= 0; --i) {
            const item = items[i];
            const [key, value2] = item;
            if (!this.cache.has(key)) {
              const deleted = this._deleteIfExpired(key, value2);
              if (deleted === false) {
                yield [key, value2.value];
              }
            }
          }
        }
        *entriesAscending() {
          for (const [key, value2] of this._entriesAscending()) {
            yield [key, value2.value];
          }
        }
        get size() {
          if (!this._size) {
            return this.oldCache.size;
          }
          let oldCacheSize = 0;
          for (const key of this.oldCache.keys()) {
            if (!this.cache.has(key)) {
              oldCacheSize++;
            }
          }
          return Math.min(this._size + oldCacheSize, this.maxSize);
        }
      };
      module.exports = QuickLRU;
    }
  });
  var require_parse2 = __commonJS2({
    "node_modules/tailwindcss/src/value-parser/parse.js"(exports, module) {
      var openParentheses = "(".charCodeAt(0);
      var closeParentheses = ")".charCodeAt(0);
      var singleQuote = "'".charCodeAt(0);
      var doubleQuote = '"'.charCodeAt(0);
      var backslash = "\\".charCodeAt(0);
      var slash = "/".charCodeAt(0);
      var comma = ",".charCodeAt(0);
      var colon = ":".charCodeAt(0);
      var star = "*".charCodeAt(0);
      var uLower = "u".charCodeAt(0);
      var uUpper = "U".charCodeAt(0);
      var plus = "+".charCodeAt(0);
      var isUnicodeRange = /^[a-f0-9?-]+$/i;
      module.exports = function(input) {
        var tokens = [];
        var value2 = input;
        var next2, quote, prev, token, escape2, escapePos, whitespacePos, parenthesesOpenPos;
        var pos = 0;
        var code = value2.charCodeAt(pos);
        var max2 = value2.length;
        var stack2 = [{ nodes: tokens }];
        var balanced = 0;
        var parent;
        var name = "";
        var before = "";
        var after = "";
        while (pos < max2) {
          if (code <= 32) {
            next2 = pos;
            do {
              next2 += 1;
              code = value2.charCodeAt(next2);
            } while (code <= 32);
            token = value2.slice(pos, next2);
            prev = tokens[tokens.length - 1];
            if (code === closeParentheses && balanced) {
              after = token;
            } else if (prev && prev.type === "div") {
              prev.after = token;
              prev.sourceEndIndex += token.length;
            } else if (code === comma || code === colon || code === slash && value2.charCodeAt(next2 + 1) !== star && (!parent || parent && parent.type === "function" && false)) {
              before = token;
            } else {
              tokens.push({
                type: "space",
                sourceIndex: pos,
                sourceEndIndex: next2,
                value: token
              });
            }
            pos = next2;
          } else if (code === singleQuote || code === doubleQuote) {
            next2 = pos;
            quote = code === singleQuote ? "'" : '"';
            token = {
              type: "string",
              sourceIndex: pos,
              quote
            };
            do {
              escape2 = false;
              next2 = value2.indexOf(quote, next2 + 1);
              if (~next2) {
                escapePos = next2;
                while (value2.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape2 = !escape2;
                }
              } else {
                value2 += quote;
                next2 = value2.length - 1;
                token.unclosed = true;
              }
            } while (escape2);
            token.value = value2.slice(pos + 1, next2);
            token.sourceEndIndex = token.unclosed ? next2 : next2 + 1;
            tokens.push(token);
            pos = next2 + 1;
            code = value2.charCodeAt(pos);
          } else if (code === slash && value2.charCodeAt(pos + 1) === star) {
            next2 = value2.indexOf("*/", pos);
            token = {
              type: "comment",
              sourceIndex: pos,
              sourceEndIndex: next2 + 2
            };
            if (next2 === -1) {
              token.unclosed = true;
              next2 = value2.length;
              token.sourceEndIndex = next2;
            }
            token.value = value2.slice(pos + 2, next2);
            tokens.push(token);
            pos = next2 + 2;
            code = value2.charCodeAt(pos);
          } else if ((code === slash || code === star) && parent && parent.type === "function" && true) {
            token = value2[pos];
            tokens.push({
              type: "word",
              sourceIndex: pos - before.length,
              sourceEndIndex: pos + token.length,
              value: token
            });
            pos += 1;
            code = value2.charCodeAt(pos);
          } else if (code === slash || code === comma || code === colon) {
            token = value2[pos];
            tokens.push({
              type: "div",
              sourceIndex: pos - before.length,
              sourceEndIndex: pos + token.length,
              value: token,
              before,
              after: ""
            });
            before = "";
            pos += 1;
            code = value2.charCodeAt(pos);
          } else if (openParentheses === code) {
            next2 = pos;
            do {
              next2 += 1;
              code = value2.charCodeAt(next2);
            } while (code <= 32);
            parenthesesOpenPos = pos;
            token = {
              type: "function",
              sourceIndex: pos - name.length,
              value: name,
              before: value2.slice(parenthesesOpenPos + 1, next2)
            };
            pos = next2;
            if (name === "url" && code !== singleQuote && code !== doubleQuote) {
              next2 -= 1;
              do {
                escape2 = false;
                next2 = value2.indexOf(")", next2 + 1);
                if (~next2) {
                  escapePos = next2;
                  while (value2.charCodeAt(escapePos - 1) === backslash) {
                    escapePos -= 1;
                    escape2 = !escape2;
                  }
                } else {
                  value2 += ")";
                  next2 = value2.length - 1;
                  token.unclosed = true;
                }
              } while (escape2);
              whitespacePos = next2;
              do {
                whitespacePos -= 1;
                code = value2.charCodeAt(whitespacePos);
              } while (code <= 32);
              if (parenthesesOpenPos < whitespacePos) {
                if (pos !== whitespacePos + 1) {
                  token.nodes = [
                    {
                      type: "word",
                      sourceIndex: pos,
                      sourceEndIndex: whitespacePos + 1,
                      value: value2.slice(pos, whitespacePos + 1)
                    }
                  ];
                } else {
                  token.nodes = [];
                }
                if (token.unclosed && whitespacePos + 1 !== next2) {
                  token.after = "";
                  token.nodes.push({
                    type: "space",
                    sourceIndex: whitespacePos + 1,
                    sourceEndIndex: next2,
                    value: value2.slice(whitespacePos + 1, next2)
                  });
                } else {
                  token.after = value2.slice(whitespacePos + 1, next2);
                  token.sourceEndIndex = next2;
                }
              } else {
                token.after = "";
                token.nodes = [];
              }
              pos = next2 + 1;
              token.sourceEndIndex = token.unclosed ? next2 : pos;
              code = value2.charCodeAt(pos);
              tokens.push(token);
            } else {
              balanced += 1;
              token.after = "";
              token.sourceEndIndex = pos + 1;
              tokens.push(token);
              stack2.push(token);
              tokens = token.nodes = [];
              parent = token;
            }
            name = "";
          } else if (closeParentheses === code && balanced) {
            pos += 1;
            code = value2.charCodeAt(pos);
            parent.after = after;
            parent.sourceEndIndex += after.length;
            after = "";
            balanced -= 1;
            stack2[stack2.length - 1].sourceEndIndex = pos;
            stack2.pop();
            parent = stack2[balanced];
            tokens = parent.nodes;
          } else {
            next2 = pos;
            do {
              if (code === backslash) {
                next2 += 1;
              }
              next2 += 1;
              code = value2.charCodeAt(next2);
            } while (next2 < max2 && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && true || code === slash && parent.type === "function" && true || code === closeParentheses && balanced));
            token = value2.slice(pos, next2);
            if (openParentheses === code) {
              name = token;
            } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
              tokens.push({
                type: "unicode-range",
                sourceIndex: pos,
                sourceEndIndex: next2,
                value: token
              });
            } else {
              tokens.push({
                type: "word",
                sourceIndex: pos,
                sourceEndIndex: next2,
                value: token
              });
            }
            pos = next2;
          }
        }
        for (pos = stack2.length - 1; pos; pos -= 1) {
          stack2[pos].unclosed = true;
          stack2[pos].sourceEndIndex = value2.length;
        }
        return stack2[0].nodes;
      };
    }
  });
  var require_walk = __commonJS2({
    "node_modules/tailwindcss/src/value-parser/walk.js"(exports, module) {
      module.exports = function walk(nodes, cb, bubble) {
        var i, max2, node, result;
        for (i = 0, max2 = nodes.length; i < max2; i += 1) {
          node = nodes[i];
          if (!bubble) {
            result = cb(node, i, nodes);
          }
          if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
            walk(node.nodes, cb, bubble);
          }
          if (bubble) {
            cb(node, i, nodes);
          }
        }
      };
    }
  });
  var require_stringify2 = __commonJS2({
    "node_modules/tailwindcss/src/value-parser/stringify.js"(exports, module) {
      function stringifyNode(node, custom) {
        var type = node.type;
        var value2 = node.value;
        var buf;
        var customResult;
        if (custom && (customResult = custom(node)) !== void 0) {
          return customResult;
        } else if (type === "word" || type === "space") {
          return value2;
        } else if (type === "string") {
          buf = node.quote || "";
          return buf + value2 + (node.unclosed ? "" : buf);
        } else if (type === "comment") {
          return "/*" + value2 + (node.unclosed ? "" : "*/");
        } else if (type === "div") {
          return (node.before || "") + value2 + (node.after || "");
        } else if (Array.isArray(node.nodes)) {
          buf = stringify2(node.nodes, custom);
          if (type !== "function") {
            return buf;
          }
          return value2 + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
        }
        return value2;
      }
      function stringify2(nodes, custom) {
        var result, i;
        if (Array.isArray(nodes)) {
          result = "";
          for (i = nodes.length - 1; ~i; i -= 1) {
            result = stringifyNode(nodes[i], custom) + result;
          }
          return result;
        }
        return stringifyNode(nodes, custom);
      }
      module.exports = stringify2;
    }
  });
  var require_unit = __commonJS2({
    "node_modules/tailwindcss/src/value-parser/unit.js"(exports, module) {
      var minus = "-".charCodeAt(0);
      var plus = "+".charCodeAt(0);
      var dot = ".".charCodeAt(0);
      var exp = "e".charCodeAt(0);
      var EXP = "E".charCodeAt(0);
      function likeNumber(value2) {
        var code = value2.charCodeAt(0);
        var nextCode;
        if (code === plus || code === minus) {
          nextCode = value2.charCodeAt(1);
          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }
          var nextNextCode = value2.charCodeAt(2);
          if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
            return true;
          }
          return false;
        }
        if (code === dot) {
          nextCode = value2.charCodeAt(1);
          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }
          return false;
        }
        if (code >= 48 && code <= 57) {
          return true;
        }
        return false;
      }
      module.exports = function(value2) {
        var pos = 0;
        var length2 = value2.length;
        var code;
        var nextCode;
        var nextNextCode;
        if (length2 === 0 || !likeNumber(value2)) {
          return false;
        }
        code = value2.charCodeAt(pos);
        if (code === plus || code === minus) {
          pos++;
        }
        while (pos < length2) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
        code = value2.charCodeAt(pos);
        nextCode = value2.charCodeAt(pos + 1);
        if (code === dot && nextCode >= 48 && nextCode <= 57) {
          pos += 2;
          while (pos < length2) {
            code = value2.charCodeAt(pos);
            if (code < 48 || code > 57) {
              break;
            }
            pos += 1;
          }
        }
        code = value2.charCodeAt(pos);
        nextCode = value2.charCodeAt(pos + 1);
        nextNextCode = value2.charCodeAt(pos + 2);
        if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
          pos += nextCode === plus || nextCode === minus ? 3 : 2;
          while (pos < length2) {
            code = value2.charCodeAt(pos);
            if (code < 48 || code > 57) {
              break;
            }
            pos += 1;
          }
        }
        return {
          number: value2.slice(0, pos),
          unit: value2.slice(pos)
        };
      };
    }
  });
  var require_value_parser = __commonJS2({
    "node_modules/tailwindcss/src/value-parser/index.js"(exports, module) {
      var parse3 = require_parse2();
      var walk = require_walk();
      var stringify2 = require_stringify2();
      function ValueParser(value2) {
        if (this instanceof ValueParser) {
          this.nodes = parse3(value2);
          return this;
        }
        return new ValueParser(value2);
      }
      ValueParser.prototype.toString = function() {
        return Array.isArray(this.nodes) ? stringify2(this.nodes) : "";
      };
      ValueParser.prototype.walk = function(cb, bubble) {
        walk(this.nodes, cb, bubble);
        return this;
      };
      ValueParser.unit = require_unit();
      ValueParser.walk = walk;
      ValueParser.stringify = stringify2;
      module.exports = ValueParser;
    }
  });
  var require_config_full = __commonJS2({
    "node_modules/tailwindcss/stubs/config.full.js"(exports, module) {
      module.exports = {
        content: [],
        presets: [],
        darkMode: "media",
        theme: {
          accentColor: ({ theme: theme2 }) => ({
            ...theme2("colors"),
            auto: "auto"
          }),
          animation: {
            none: "none",
            spin: "spin 1s linear infinite",
            ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
            pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
            bounce: "bounce 1s infinite"
          },
          aria: {
            busy: 'busy="true"',
            checked: 'checked="true"',
            disabled: 'disabled="true"',
            expanded: 'expanded="true"',
            hidden: 'hidden="true"',
            pressed: 'pressed="true"',
            readonly: 'readonly="true"',
            required: 'required="true"',
            selected: 'selected="true"'
          },
          aspectRatio: {
            auto: "auto",
            square: "1 / 1",
            video: "16 / 9"
          },
          backdropBlur: ({ theme: theme2 }) => theme2("blur"),
          backdropBrightness: ({ theme: theme2 }) => theme2("brightness"),
          backdropContrast: ({ theme: theme2 }) => theme2("contrast"),
          backdropGrayscale: ({ theme: theme2 }) => theme2("grayscale"),
          backdropHueRotate: ({ theme: theme2 }) => theme2("hueRotate"),
          backdropInvert: ({ theme: theme2 }) => theme2("invert"),
          backdropOpacity: ({ theme: theme2 }) => theme2("opacity"),
          backdropSaturate: ({ theme: theme2 }) => theme2("saturate"),
          backdropSepia: ({ theme: theme2 }) => theme2("sepia"),
          backgroundColor: ({ theme: theme2 }) => theme2("colors"),
          backgroundImage: {
            none: "none",
            "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
            "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
            "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
            "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
            "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
            "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
            "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
            "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
          },
          backgroundOpacity: ({ theme: theme2 }) => theme2("opacity"),
          backgroundPosition: {
            bottom: "bottom",
            center: "center",
            left: "left",
            "left-bottom": "left bottom",
            "left-top": "left top",
            right: "right",
            "right-bottom": "right bottom",
            "right-top": "right top",
            top: "top"
          },
          backgroundSize: {
            auto: "auto",
            cover: "cover",
            contain: "contain"
          },
          blur: {
            0: "0",
            none: "0",
            sm: "4px",
            DEFAULT: "8px",
            md: "12px",
            lg: "16px",
            xl: "24px",
            "2xl": "40px",
            "3xl": "64px"
          },
          borderColor: ({ theme: theme2 }) => ({
            ...theme2("colors"),
            DEFAULT: theme2("colors.gray.200", "currentColor")
          }),
          borderOpacity: ({ theme: theme2 }) => theme2("opacity"),
          borderRadius: {
            none: "0px",
            sm: "0.125rem",
            DEFAULT: "0.25rem",
            md: "0.375rem",
            lg: "0.5rem",
            xl: "0.75rem",
            "2xl": "1rem",
            "3xl": "1.5rem",
            full: "9999px"
          },
          borderSpacing: ({ theme: theme2 }) => ({
            ...theme2("spacing")
          }),
          borderWidth: {
            DEFAULT: "1px",
            0: "0px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          boxShadow: {
            sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
            DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
            md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
            lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
            xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
            "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
            inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
            none: "none"
          },
          boxShadowColor: ({ theme: theme2 }) => theme2("colors"),
          brightness: {
            0: "0",
            50: ".5",
            75: ".75",
            90: ".9",
            95: ".95",
            100: "1",
            105: "1.05",
            110: "1.1",
            125: "1.25",
            150: "1.5",
            200: "2"
          },
          caretColor: ({ theme: theme2 }) => theme2("colors"),
          colors: ({ colors: colors2 }) => ({
            inherit: colors2.inherit,
            current: colors2.current,
            transparent: colors2.transparent,
            black: colors2.black,
            white: colors2.white,
            slate: colors2.slate,
            gray: colors2.gray,
            zinc: colors2.zinc,
            neutral: colors2.neutral,
            stone: colors2.stone,
            red: colors2.red,
            orange: colors2.orange,
            amber: colors2.amber,
            yellow: colors2.yellow,
            lime: colors2.lime,
            green: colors2.green,
            emerald: colors2.emerald,
            teal: colors2.teal,
            cyan: colors2.cyan,
            sky: colors2.sky,
            blue: colors2.blue,
            indigo: colors2.indigo,
            violet: colors2.violet,
            purple: colors2.purple,
            fuchsia: colors2.fuchsia,
            pink: colors2.pink,
            rose: colors2.rose
          }),
          columns: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            "3xs": "16rem",
            "2xs": "18rem",
            xs: "20rem",
            sm: "24rem",
            md: "28rem",
            lg: "32rem",
            xl: "36rem",
            "2xl": "42rem",
            "3xl": "48rem",
            "4xl": "56rem",
            "5xl": "64rem",
            "6xl": "72rem",
            "7xl": "80rem"
          },
          container: {},
          content: {
            none: "none"
          },
          contrast: {
            0: "0",
            50: ".5",
            75: ".75",
            100: "1",
            125: "1.25",
            150: "1.5",
            200: "2"
          },
          cursor: {
            auto: "auto",
            default: "default",
            pointer: "pointer",
            wait: "wait",
            text: "text",
            move: "move",
            help: "help",
            "not-allowed": "not-allowed",
            none: "none",
            "context-menu": "context-menu",
            progress: "progress",
            cell: "cell",
            crosshair: "crosshair",
            "vertical-text": "vertical-text",
            alias: "alias",
            copy: "copy",
            "no-drop": "no-drop",
            grab: "grab",
            grabbing: "grabbing",
            "all-scroll": "all-scroll",
            "col-resize": "col-resize",
            "row-resize": "row-resize",
            "n-resize": "n-resize",
            "e-resize": "e-resize",
            "s-resize": "s-resize",
            "w-resize": "w-resize",
            "ne-resize": "ne-resize",
            "nw-resize": "nw-resize",
            "se-resize": "se-resize",
            "sw-resize": "sw-resize",
            "ew-resize": "ew-resize",
            "ns-resize": "ns-resize",
            "nesw-resize": "nesw-resize",
            "nwse-resize": "nwse-resize",
            "zoom-in": "zoom-in",
            "zoom-out": "zoom-out"
          },
          divideColor: ({ theme: theme2 }) => theme2("borderColor"),
          divideOpacity: ({ theme: theme2 }) => theme2("borderOpacity"),
          divideWidth: ({ theme: theme2 }) => theme2("borderWidth"),
          dropShadow: {
            sm: "0 1px 1px rgb(0 0 0 / 0.05)",
            DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
            md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
            lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
            xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
            "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
            none: "0 0 #0000"
          },
          fill: ({ theme: theme2 }) => ({
            none: "none",
            ...theme2("colors")
          }),
          flex: {
            1: "1 1 0%",
            auto: "1 1 auto",
            initial: "0 1 auto",
            none: "none"
          },
          flexBasis: ({ theme: theme2 }) => ({
            auto: "auto",
            ...theme2("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%"
          }),
          flexGrow: {
            0: "0",
            DEFAULT: "1"
          },
          flexShrink: {
            0: "0",
            DEFAULT: "1"
          },
          fontFamily: {
            sans: [
              "ui-sans-serif",
              "system-ui",
              "sans-serif",
              '"Apple Color Emoji"',
              '"Segoe UI Emoji"',
              '"Segoe UI Symbol"',
              '"Noto Color Emoji"'
            ],
            serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
            mono: [
              "ui-monospace",
              "SFMono-Regular",
              "Menlo",
              "Monaco",
              "Consolas",
              '"Liberation Mono"',
              '"Courier New"',
              "monospace"
            ]
          },
          fontSize: {
            xs: ["0.75rem", { lineHeight: "1rem" }],
            sm: ["0.875rem", { lineHeight: "1.25rem" }],
            base: ["1rem", { lineHeight: "1.5rem" }],
            lg: ["1.125rem", { lineHeight: "1.75rem" }],
            xl: ["1.25rem", { lineHeight: "1.75rem" }],
            "2xl": ["1.5rem", { lineHeight: "2rem" }],
            "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
            "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
            "5xl": ["3rem", { lineHeight: "1" }],
            "6xl": ["3.75rem", { lineHeight: "1" }],
            "7xl": ["4.5rem", { lineHeight: "1" }],
            "8xl": ["6rem", { lineHeight: "1" }],
            "9xl": ["8rem", { lineHeight: "1" }]
          },
          fontWeight: {
            thin: "100",
            extralight: "200",
            light: "300",
            normal: "400",
            medium: "500",
            semibold: "600",
            bold: "700",
            extrabold: "800",
            black: "900"
          },
          gap: ({ theme: theme2 }) => theme2("spacing"),
          gradientColorStops: ({ theme: theme2 }) => theme2("colors"),
          gradientColorStopPositions: {
            "0%": "0%",
            "5%": "5%",
            "10%": "10%",
            "15%": "15%",
            "20%": "20%",
            "25%": "25%",
            "30%": "30%",
            "35%": "35%",
            "40%": "40%",
            "45%": "45%",
            "50%": "50%",
            "55%": "55%",
            "60%": "60%",
            "65%": "65%",
            "70%": "70%",
            "75%": "75%",
            "80%": "80%",
            "85%": "85%",
            "90%": "90%",
            "95%": "95%",
            "100%": "100%"
          },
          grayscale: {
            0: "0",
            DEFAULT: "100%"
          },
          gridAutoColumns: {
            auto: "auto",
            min: "min-content",
            max: "max-content",
            fr: "minmax(0, 1fr)"
          },
          gridAutoRows: {
            auto: "auto",
            min: "min-content",
            max: "max-content",
            fr: "minmax(0, 1fr)"
          },
          gridColumn: {
            auto: "auto",
            "span-1": "span 1 / span 1",
            "span-2": "span 2 / span 2",
            "span-3": "span 3 / span 3",
            "span-4": "span 4 / span 4",
            "span-5": "span 5 / span 5",
            "span-6": "span 6 / span 6",
            "span-7": "span 7 / span 7",
            "span-8": "span 8 / span 8",
            "span-9": "span 9 / span 9",
            "span-10": "span 10 / span 10",
            "span-11": "span 11 / span 11",
            "span-12": "span 12 / span 12",
            "span-full": "1 / -1"
          },
          gridColumnEnd: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            13: "13"
          },
          gridColumnStart: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            13: "13"
          },
          gridRow: {
            auto: "auto",
            "span-1": "span 1 / span 1",
            "span-2": "span 2 / span 2",
            "span-3": "span 3 / span 3",
            "span-4": "span 4 / span 4",
            "span-5": "span 5 / span 5",
            "span-6": "span 6 / span 6",
            "span-7": "span 7 / span 7",
            "span-8": "span 8 / span 8",
            "span-9": "span 9 / span 9",
            "span-10": "span 10 / span 10",
            "span-11": "span 11 / span 11",
            "span-12": "span 12 / span 12",
            "span-full": "1 / -1"
          },
          gridRowEnd: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            13: "13"
          },
          gridRowStart: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            13: "13"
          },
          gridTemplateColumns: {
            none: "none",
            subgrid: "subgrid",
            1: "repeat(1, minmax(0, 1fr))",
            2: "repeat(2, minmax(0, 1fr))",
            3: "repeat(3, minmax(0, 1fr))",
            4: "repeat(4, minmax(0, 1fr))",
            5: "repeat(5, minmax(0, 1fr))",
            6: "repeat(6, minmax(0, 1fr))",
            7: "repeat(7, minmax(0, 1fr))",
            8: "repeat(8, minmax(0, 1fr))",
            9: "repeat(9, minmax(0, 1fr))",
            10: "repeat(10, minmax(0, 1fr))",
            11: "repeat(11, minmax(0, 1fr))",
            12: "repeat(12, minmax(0, 1fr))"
          },
          gridTemplateRows: {
            none: "none",
            subgrid: "subgrid",
            1: "repeat(1, minmax(0, 1fr))",
            2: "repeat(2, minmax(0, 1fr))",
            3: "repeat(3, minmax(0, 1fr))",
            4: "repeat(4, minmax(0, 1fr))",
            5: "repeat(5, minmax(0, 1fr))",
            6: "repeat(6, minmax(0, 1fr))",
            7: "repeat(7, minmax(0, 1fr))",
            8: "repeat(8, minmax(0, 1fr))",
            9: "repeat(9, minmax(0, 1fr))",
            10: "repeat(10, minmax(0, 1fr))",
            11: "repeat(11, minmax(0, 1fr))",
            12: "repeat(12, minmax(0, 1fr))"
          },
          height: ({ theme: theme2 }) => ({
            auto: "auto",
            ...theme2("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          }),
          hueRotate: {
            0: "0deg",
            15: "15deg",
            30: "30deg",
            60: "60deg",
            90: "90deg",
            180: "180deg"
          },
          inset: ({ theme: theme2 }) => ({
            auto: "auto",
            ...theme2("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%"
          }),
          invert: {
            0: "0",
            DEFAULT: "100%"
          },
          keyframes: {
            spin: {
              to: {
                transform: "rotate(360deg)"
              }
            },
            ping: {
              "75%, 100%": {
                transform: "scale(2)",
                opacity: "0"
              }
            },
            pulse: {
              "50%": {
                opacity: ".5"
              }
            },
            bounce: {
              "0%, 100%": {
                transform: "translateY(-25%)",
                animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
              },
              "50%": {
                transform: "none",
                animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
              }
            }
          },
          letterSpacing: {
            tighter: "-0.05em",
            tight: "-0.025em",
            normal: "0em",
            wide: "0.025em",
            wider: "0.05em",
            widest: "0.1em"
          },
          lineHeight: {
            none: "1",
            tight: "1.25",
            snug: "1.375",
            normal: "1.5",
            relaxed: "1.625",
            loose: "2",
            3: ".75rem",
            4: "1rem",
            5: "1.25rem",
            6: "1.5rem",
            7: "1.75rem",
            8: "2rem",
            9: "2.25rem",
            10: "2.5rem"
          },
          listStyleType: {
            none: "none",
            disc: "disc",
            decimal: "decimal"
          },
          listStyleImage: {
            none: "none"
          },
          margin: ({ theme: theme2 }) => ({
            auto: "auto",
            ...theme2("spacing")
          }),
          lineClamp: {
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6"
          },
          maxHeight: ({ theme: theme2 }) => ({
            ...theme2("spacing"),
            none: "none",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          }),
          maxWidth: ({ theme: theme2, breakpoints }) => ({
            ...theme2("spacing"),
            none: "none",
            xs: "20rem",
            sm: "24rem",
            md: "28rem",
            lg: "32rem",
            xl: "36rem",
            "2xl": "42rem",
            "3xl": "48rem",
            "4xl": "56rem",
            "5xl": "64rem",
            "6xl": "72rem",
            "7xl": "80rem",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            prose: "65ch",
            ...breakpoints(theme2("screens"))
          }),
          minHeight: ({ theme: theme2 }) => ({
            ...theme2("spacing"),
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          }),
          minWidth: ({ theme: theme2 }) => ({
            ...theme2("spacing"),
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          }),
          objectPosition: {
            bottom: "bottom",
            center: "center",
            left: "left",
            "left-bottom": "left bottom",
            "left-top": "left top",
            right: "right",
            "right-bottom": "right bottom",
            "right-top": "right top",
            top: "top"
          },
          opacity: {
            0: "0",
            5: "0.05",
            10: "0.1",
            15: "0.15",
            20: "0.2",
            25: "0.25",
            30: "0.3",
            35: "0.35",
            40: "0.4",
            45: "0.45",
            50: "0.5",
            55: "0.55",
            60: "0.6",
            65: "0.65",
            70: "0.7",
            75: "0.75",
            80: "0.8",
            85: "0.85",
            90: "0.9",
            95: "0.95",
            100: "1"
          },
          order: {
            first: "-9999",
            last: "9999",
            none: "0",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12"
          },
          outlineColor: ({ theme: theme2 }) => theme2("colors"),
          outlineOffset: {
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          outlineWidth: {
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          padding: ({ theme: theme2 }) => theme2("spacing"),
          placeholderColor: ({ theme: theme2 }) => theme2("colors"),
          placeholderOpacity: ({ theme: theme2 }) => theme2("opacity"),
          ringColor: ({ theme: theme2 }) => ({
            DEFAULT: theme2("colors.blue.500", "#3b82f6"),
            ...theme2("colors")
          }),
          ringOffsetColor: ({ theme: theme2 }) => theme2("colors"),
          ringOffsetWidth: {
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          ringOpacity: ({ theme: theme2 }) => ({
            DEFAULT: "0.5",
            ...theme2("opacity")
          }),
          ringWidth: {
            DEFAULT: "3px",
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          rotate: {
            0: "0deg",
            1: "1deg",
            2: "2deg",
            3: "3deg",
            6: "6deg",
            12: "12deg",
            45: "45deg",
            90: "90deg",
            180: "180deg"
          },
          saturate: {
            0: "0",
            50: ".5",
            100: "1",
            150: "1.5",
            200: "2"
          },
          scale: {
            0: "0",
            50: ".5",
            75: ".75",
            90: ".9",
            95: ".95",
            100: "1",
            105: "1.05",
            110: "1.1",
            125: "1.25",
            150: "1.5"
          },
          screens: {
            sm: "640px",
            md: "768px",
            lg: "1024px",
            xl: "1280px",
            "2xl": "1536px"
          },
          scrollMargin: ({ theme: theme2 }) => ({
            ...theme2("spacing")
          }),
          scrollPadding: ({ theme: theme2 }) => theme2("spacing"),
          sepia: {
            0: "0",
            DEFAULT: "100%"
          },
          skew: {
            0: "0deg",
            1: "1deg",
            2: "2deg",
            3: "3deg",
            6: "6deg",
            12: "12deg"
          },
          space: ({ theme: theme2 }) => ({
            ...theme2("spacing")
          }),
          spacing: {
            px: "1px",
            0: "0px",
            0.5: "0.125rem",
            1: "0.25rem",
            1.5: "0.375rem",
            2: "0.5rem",
            2.5: "0.625rem",
            3: "0.75rem",
            3.5: "0.875rem",
            4: "1rem",
            5: "1.25rem",
            6: "1.5rem",
            7: "1.75rem",
            8: "2rem",
            9: "2.25rem",
            10: "2.5rem",
            11: "2.75rem",
            12: "3rem",
            14: "3.5rem",
            16: "4rem",
            20: "5rem",
            24: "6rem",
            28: "7rem",
            32: "8rem",
            36: "9rem",
            40: "10rem",
            44: "11rem",
            48: "12rem",
            52: "13rem",
            56: "14rem",
            60: "15rem",
            64: "16rem",
            72: "18rem",
            80: "20rem",
            96: "24rem"
          },
          stroke: ({ theme: theme2 }) => ({
            none: "none",
            ...theme2("colors")
          }),
          strokeWidth: {
            0: "0",
            1: "1",
            2: "2"
          },
          supports: {},
          data: {},
          textColor: ({ theme: theme2 }) => theme2("colors"),
          textDecorationColor: ({ theme: theme2 }) => theme2("colors"),
          textDecorationThickness: {
            auto: "auto",
            "from-font": "from-font",
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          textIndent: ({ theme: theme2 }) => ({
            ...theme2("spacing")
          }),
          textOpacity: ({ theme: theme2 }) => theme2("opacity"),
          textUnderlineOffset: {
            auto: "auto",
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          transformOrigin: {
            center: "center",
            top: "top",
            "top-right": "top right",
            right: "right",
            "bottom-right": "bottom right",
            bottom: "bottom",
            "bottom-left": "bottom left",
            left: "left",
            "top-left": "top left"
          },
          transitionDelay: {
            0: "0s",
            75: "75ms",
            100: "100ms",
            150: "150ms",
            200: "200ms",
            300: "300ms",
            500: "500ms",
            700: "700ms",
            1e3: "1000ms"
          },
          transitionDuration: {
            DEFAULT: "150ms",
            0: "0s",
            75: "75ms",
            100: "100ms",
            150: "150ms",
            200: "200ms",
            300: "300ms",
            500: "500ms",
            700: "700ms",
            1e3: "1000ms"
          },
          transitionProperty: {
            none: "none",
            all: "all",
            DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
            colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
            opacity: "opacity",
            shadow: "box-shadow",
            transform: "transform"
          },
          transitionTimingFunction: {
            DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
            linear: "linear",
            in: "cubic-bezier(0.4, 0, 1, 1)",
            out: "cubic-bezier(0, 0, 0.2, 1)",
            "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
          },
          translate: ({ theme: theme2 }) => ({
            ...theme2("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%"
          }),
          size: ({ theme: theme2 }) => ({
            auto: "auto",
            ...theme2("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          }),
          width: ({ theme: theme2 }) => ({
            auto: "auto",
            ...theme2("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            screen: "100vw",
            svw: "100svw",
            lvw: "100lvw",
            dvw: "100dvw",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          }),
          willChange: {
            auto: "auto",
            scroll: "scroll-position",
            contents: "contents",
            transform: "transform"
          },
          zIndex: {
            auto: "auto",
            0: "0",
            10: "10",
            20: "20",
            30: "30",
            40: "40",
            50: "50"
          }
        },
        plugins: []
      };
    }
  });
  function log() {
  }
  function dim(input) {
    return input;
  }
  var log_default = {
    info: log,
    warn: log,
    risk: log
  };
  function normalizeTailwindDirectives(root12) {
    let tailwindDirectives = /* @__PURE__ */ new Set();
    let layerDirectives = /* @__PURE__ */ new Set();
    let applyDirectives = /* @__PURE__ */ new Set();
    root12.walkAtRules((atRule2) => {
      if (atRule2.name === "apply") {
        applyDirectives.add(atRule2);
      }
      if (atRule2.name === "import") {
        if (atRule2.params === '"tailwindcss/base"' || atRule2.params === "'tailwindcss/base'") {
          atRule2.name = "tailwind";
          atRule2.params = "base";
        } else if (atRule2.params === '"tailwindcss/components"' || atRule2.params === "'tailwindcss/components'") {
          atRule2.name = "tailwind";
          atRule2.params = "components";
        } else if (atRule2.params === '"tailwindcss/utilities"' || atRule2.params === "'tailwindcss/utilities'") {
          atRule2.name = "tailwind";
          atRule2.params = "utilities";
        } else if (atRule2.params === '"tailwindcss/screens"' || atRule2.params === "'tailwindcss/screens'" || atRule2.params === '"tailwindcss/variants"' || atRule2.params === "'tailwindcss/variants'") {
          atRule2.name = "tailwind";
          atRule2.params = "variants";
        }
      }
      if (atRule2.name === "tailwind") {
        if (atRule2.params === "screens") {
          atRule2.params = "variants";
        }
        tailwindDirectives.add(atRule2.params);
      }
      if (["layer", "responsive", "variants"].includes(atRule2.name)) {
        if (["responsive", "variants"].includes(atRule2.name)) {
          log_default.warn(`${atRule2.name}-at-rule-deprecated`, [
            `The \`@${atRule2.name}\` directive has been deprecated in Tailwind CSS v3.0.`,
            `Use \`@layer utilities\` or \`@layer components\` instead.`,
            "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"
          ]);
        }
        layerDirectives.add(atRule2);
      }
    });
    if (!tailwindDirectives.has("base") || !tailwindDirectives.has("components") || !tailwindDirectives.has("utilities")) {
      for (let rule2 of layerDirectives) {
        if (rule2.name === "layer" && ["base", "components", "utilities"].includes(rule2.params)) {
          if (!tailwindDirectives.has(rule2.params)) {
            throw rule2.error(
              `\`@layer ${rule2.params}\` is used but no matching \`@tailwind ${rule2.params}\` directive is present.`
            );
          }
        } else if (rule2.name === "responsive") {
          if (!tailwindDirectives.has("utilities")) {
            throw rule2.error("`@responsive` is used but `@tailwind utilities` is missing.");
          }
        } else if (rule2.name === "variants") {
          if (!tailwindDirectives.has("utilities")) {
            throw rule2.error("`@variants` is used but `@tailwind utilities` is missing.");
          }
        }
      }
    }
    return { tailwindDirectives, applyDirectives };
  }
  var preflight_default = '*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:theme("borderColor.DEFAULT",currentColor)}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:theme("fontFamily.sans",ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:theme("fontFamily.sans[1].fontFeatureSettings",normal);font-variation-settings:theme("fontFamily.sans[1].fontVariationSettings",normal);-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:theme("fontFamily.mono",ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:theme("fontFamily.mono[1].fontFeatureSettings",normal);font-variation-settings:theme("fontFamily.mono[1].fontVariationSettings",normal);font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:theme("colors.gray.400",#9ca3af)}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}\n';
  var fs_default = {
    readFileSync: () => preflight_default
  };
  var import_quick_lru = __toESM2(require_quick_lru());
  var version = "3.4.1";
  var package_default = {
    name: "tailwindcss",
    version,
    description: "A utility-first CSS framework for rapidly building custom user interfaces.",
    license: "MIT",
    main: "lib/index.js",
    types: "types/index.d.ts",
    repository: "https://github.com/tailwindlabs/tailwindcss.git",
    bugs: "https://github.com/tailwindlabs/tailwindcss/issues",
    homepage: "https://tailwindcss.com",
    bin: {
      tailwind: "lib/cli.js",
      tailwindcss: "lib/cli.js"
    },
    tailwindcss: {
      engine: "stable"
    },
    scripts: {
      prebuild: "npm run generate && rimraf lib",
      build: `swc src --out-dir lib --copy-files --config jsc.transform.optimizer.globals.vars.__OXIDE__='"false"'`,
      postbuild: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false",
      "rebuild-fixtures": "npm run build && node -r @swc/register scripts/rebuildFixtures.js",
      style: "eslint .",
      pretest: "npm run generate",
      test: "jest",
      "test:integrations": "npm run test --prefix ./integrations",
      "install:integrations": "node scripts/install-integrations.js",
      "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js",
      "generate:types": "node -r @swc/register scripts/generate-types.js",
      generate: "npm run generate:plugin-list && npm run generate:types",
      "release-channel": "node ./scripts/release-channel.js",
      "release-notes": "node ./scripts/release-notes.js",
      prepublishOnly: "npm install --force && npm run build"
    },
    files: [
      "src/*",
      "cli/*",
      "lib/*",
      "peers/*",
      "scripts/*.js",
      "stubs/*",
      "nesting/*",
      "types/**/*",
      "*.d.ts",
      "*.css",
      "*.js"
    ],
    devDependencies: {
      "@swc/cli": "^0.1.62",
      "@swc/core": "^1.3.55",
      "@swc/jest": "^0.2.26",
      "@swc/register": "^0.1.10",
      autoprefixer: "^10.4.14",
      browserslist: "^4.21.5",
      concurrently: "^8.0.1",
      cssnano: "^6.0.0",
      esbuild: "^0.17.18",
      eslint: "^8.39.0",
      "eslint-config-prettier": "^8.8.0",
      "eslint-plugin-prettier": "^4.2.1",
      jest: "^29.6.0",
      "jest-diff": "^29.6.0",
      lightningcss: "1.18.0",
      prettier: "^2.8.8",
      rimraf: "^5.0.0",
      "source-map-js": "^1.0.2",
      turbo: "^1.9.3"
    },
    dependencies: {
      "@alloc/quick-lru": "^5.2.0",
      arg: "^5.0.2",
      chokidar: "^3.5.3",
      didyoumean: "^1.2.2",
      dlv: "^1.1.3",
      "fast-glob": "^3.3.0",
      "glob-parent": "^6.0.2",
      "is-glob": "^4.0.3",
      jiti: "^1.19.1",
      lilconfig: "^2.1.0",
      micromatch: "^4.0.5",
      "normalize-path": "^3.0.0",
      "object-hash": "^3.0.0",
      picocolors: "^1.0.0",
      postcss: "^8.4.23",
      "postcss-import": "^15.1.0",
      "postcss-js": "^4.0.1",
      "postcss-load-config": "^4.0.1",
      "postcss-nested": "^6.0.1",
      "postcss-selector-parser": "^6.0.11",
      resolve: "^1.22.2",
      sucrase: "^3.32.0"
    },
    browserslist: [
      "> 1%",
      "not edge <= 18",
      "not ie 11",
      "not op_mini all"
    ],
    jest: {
      testTimeout: 3e4,
      setupFilesAfterEnv: [
        "<rootDir>/jest/customMatchers.js"
      ],
      testPathIgnorePatterns: [
        "/node_modules/",
        "/integrations/",
        "/standalone-cli/",
        "\\.test\\.skip\\.js$"
      ],
      transformIgnorePatterns: [
        "node_modules/(?!lightningcss)"
      ],
      transform: {
        "\\.js$": "@swc/jest",
        "\\.ts$": "@swc/jest"
      }
    },
    engines: {
      node: ">=14.0.0"
    }
  };
  var env = typeof process !== "undefined" ? {
    NODE_ENV: "development",
    DEBUG: resolveDebug(void 0),
    ENGINE: package_default.tailwindcss.engine
  } : {
    NODE_ENV: "production",
    DEBUG: false,
    ENGINE: package_default.tailwindcss.engine
  };
  var contextSourcesMap = /* @__PURE__ */ new Map();
  var NOT_ON_DEMAND = new String("*");
  var NONE = Symbol("__NONE__");
  function resolveDebug(debug) {
    if (debug === void 0) {
      return false;
    }
    if (debug === "true" || debug === "1") {
      return true;
    }
    if (debug === "false" || debug === "0") {
      return false;
    }
    if (debug === "*") {
      return true;
    }
    let debuggers = debug.split(",").map((d) => d.split(":")[0]);
    if (debuggers.includes("-tailwindcss")) {
      return false;
    }
    if (debuggers.includes("tailwindcss")) {
      return true;
    }
    return false;
  }
  function parseObjectStyles(styles) {
    if (!Array.isArray(styles)) {
      return parseObjectStyles([styles]);
    }
    return styles.flatMap((style) => {
      return postcss_default([
        (0, import_postcss_nested.default)({
          bubble: ["screen"]
        })
      ]).process(style, {
        parser: postcss_js_default
      }).root.nodes;
    });
  }
  function isPlainObject(value2) {
    if (Object.prototype.toString.call(value2) !== "[object Object]") {
      return false;
    }
    const prototype = Object.getPrototypeOf(value2);
    return prototype === null || Object.getPrototypeOf(prototype) === null;
  }
  function prefixSelector_default(prefix3, selector, prependNegative = false) {
    if (prefix3 === "") {
      return selector;
    }
    let ast = typeof selector === "string" ? (0, import_postcss_selector_parser2.default)().astSync(selector) : selector;
    ast.walkClasses((classSelector) => {
      let baseClass = classSelector.value;
      let shouldPlaceNegativeBeforePrefix = prependNegative && baseClass.startsWith("-");
      classSelector.value = shouldPlaceNegativeBeforePrefix ? `-${prefix3}${baseClass.slice(1)}` : `${prefix3}${baseClass}`;
    });
    return typeof selector === "string" ? ast.toString() : ast;
  }
  function escapeCommas(className) {
    return className.replace(/\\,/g, "\\2c ");
  }
  var colorNames_default = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
  var HEX = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
  var SHORT_HEX = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
  var VALUE = /(?:\d+|\d*\.\d+)%?/;
  var SEP = /(?:\s*,\s*|\s+)/;
  var ALPHA_SEP = /\s*[,/]\s*/;
  var CUSTOM_PROPERTY = /var\(--(?:[^ )]*?)(?:,(?:[^ )]*?|var\(--[^ )]*?\)))?\)/;
  var RGB = new RegExp(
    `^(rgba?)\\(\\s*(${VALUE.source}|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`
  );
  var HSL = new RegExp(
    `^(hsla?)\\(\\s*((?:${VALUE.source})(?:deg|rad|grad|turn)?|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`
  );
  function parseColor(value2, { loose = false } = {}) {
    if (typeof value2 !== "string") {
      return null;
    }
    value2 = value2.trim();
    if (value2 === "transparent") {
      return { mode: "rgb", color: ["0", "0", "0"], alpha: "0" };
    }
    if (value2 in colorNames_default) {
      return { mode: "rgb", color: colorNames_default[value2].map((v) => v.toString()) };
    }
    let hex = value2.replace(SHORT_HEX, (_, r2, g, b, a) => ["#", r2, r2, g, g, b, b, a ? a + a : ""].join("")).match(HEX);
    if (hex !== null) {
      return {
        mode: "rgb",
        color: [parseInt(hex[1], 16), parseInt(hex[2], 16), parseInt(hex[3], 16)].map(
          (v) => v.toString()
        ),
        alpha: hex[4] ? (parseInt(hex[4], 16) / 255).toString() : void 0
      };
    }
    let match = value2.match(RGB) ?? value2.match(HSL);
    if (match === null) {
      return null;
    }
    let color2 = [match[2], match[3], match[4]].filter(Boolean).map((v) => v.toString());
    if (color2.length === 2 && color2[0].startsWith("var(")) {
      return {
        mode: match[1],
        color: [color2[0]],
        alpha: color2[1]
      };
    }
    if (!loose && color2.length !== 3) {
      return null;
    }
    if (color2.length < 3 && !color2.some((part) => /^var\(.*?\)$/.test(part))) {
      return null;
    }
    return {
      mode: match[1],
      color: color2,
      alpha: match[5]?.toString?.()
    };
  }
  function formatColor({ mode, color: color2, alpha }) {
    let hasAlpha = alpha !== void 0;
    if (mode === "rgba" || mode === "hsla") {
      return `${mode}(${color2.join(", ")}${hasAlpha ? `, ${alpha}` : ""})`;
    }
    return `${mode}(${color2.join(" ")}${hasAlpha ? ` / ${alpha}` : ""})`;
  }
  function withAlphaValue(color2, alphaValue, defaultValue) {
    if (typeof color2 === "function") {
      return color2({ opacityValue: alphaValue });
    }
    let parsed = parseColor(color2, { loose: true });
    if (parsed === null) {
      return defaultValue;
    }
    return formatColor({ ...parsed, alpha: alphaValue });
  }
  function withAlphaVariable({ color: color2, property, variable }) {
    let properties = [].concat(property);
    if (typeof color2 === "function") {
      return {
        [variable]: "1",
        ...Object.fromEntries(
          properties.map((p) => {
            return [p, color2({ opacityVariable: variable, opacityValue: `var(${variable})` })];
          })
        )
      };
    }
    const parsed = parseColor(color2);
    if (parsed === null) {
      return Object.fromEntries(properties.map((p) => [p, color2]));
    }
    if (parsed.alpha !== void 0) {
      return Object.fromEntries(properties.map((p) => [p, color2]));
    }
    return {
      [variable]: "1",
      ...Object.fromEntries(
        properties.map((p) => {
          return [p, formatColor({ ...parsed, alpha: `var(${variable})` })];
        })
      )
    };
  }
  function splitAtTopLevelOnly(input, separator) {
    let stack2 = [];
    let parts = [];
    let lastPos = 0;
    let isEscaped = false;
    for (let idx = 0; idx < input.length; idx++) {
      let char = input[idx];
      if (stack2.length === 0 && char === separator[0] && !isEscaped) {
        if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {
          parts.push(input.slice(lastPos, idx));
          lastPos = idx + separator.length;
        }
      }
      if (isEscaped) {
        isEscaped = false;
      } else if (char === "\\") {
        isEscaped = true;
      }
      if (char === "(" || char === "[" || char === "{") {
        stack2.push(char);
      } else if (char === ")" && stack2[stack2.length - 1] === "(" || char === "]" && stack2[stack2.length - 1] === "[" || char === "}" && stack2[stack2.length - 1] === "{") {
        stack2.pop();
      }
    }
    parts.push(input.slice(lastPos));
    return parts;
  }
  var KEYWORDS = /* @__PURE__ */ new Set(["inset", "inherit", "initial", "revert", "unset"]);
  var SPACE = /\ +(?![^(]*\))/g;
  var LENGTH = /^-?(\d+|\.\d+)(.*?)$/g;
  function parseBoxShadowValue(input) {
    let shadows = splitAtTopLevelOnly(input, ",");
    return shadows.map((shadow2) => {
      let value2 = shadow2.trim();
      let result = { raw: value2 };
      let parts = value2.split(SPACE);
      let seen = /* @__PURE__ */ new Set();
      for (let part of parts) {
        LENGTH.lastIndex = 0;
        if (!seen.has("KEYWORD") && KEYWORDS.has(part)) {
          result.keyword = part;
          seen.add("KEYWORD");
        } else if (LENGTH.test(part)) {
          if (!seen.has("X")) {
            result.x = part;
            seen.add("X");
          } else if (!seen.has("Y")) {
            result.y = part;
            seen.add("Y");
          } else if (!seen.has("BLUR")) {
            result.blur = part;
            seen.add("BLUR");
          } else if (!seen.has("SPREAD")) {
            result.spread = part;
            seen.add("SPREAD");
          }
        } else {
          if (!result.color) {
            result.color = part;
          } else {
            if (!result.unknown)
              result.unknown = [];
            result.unknown.push(part);
          }
        }
      }
      result.valid = result.x !== void 0 && result.y !== void 0;
      return result;
    });
  }
  function formatBoxShadowValue(shadows) {
    return shadows.map((shadow2) => {
      if (!shadow2.valid) {
        return shadow2.raw;
      }
      return [shadow2.keyword, shadow2.x, shadow2.y, shadow2.blur, shadow2.spread, shadow2.color].filter(Boolean).join(" ");
    }).join(", ");
  }
  var cssFunctions = ["min", "max", "clamp", "calc"];
  function isCSSFunction(value2) {
    return cssFunctions.some((fn) => new RegExp(`^${fn}\\(.*\\)`).test(value2));
  }
  var AUTO_VAR_INJECTION_EXCEPTIONS = /* @__PURE__ */ new Set([
    "scroll-timeline-name",
    "timeline-scope",
    "view-timeline-name",
    "font-palette",
    "scroll-timeline",
    "animation-timeline",
    "view-timeline"
  ]);
  function normalize(value2, context = null, isRoot2 = true) {
    let isVarException = context && AUTO_VAR_INJECTION_EXCEPTIONS.has(context.property);
    if (value2.startsWith("--") && !isVarException) {
      return `var(${value2})`;
    }
    if (value2.includes("url(")) {
      return value2.split(/(url\(.*?\))/g).filter(Boolean).map((part) => {
        if (/^url\(.*?\)$/.test(part)) {
          return part;
        }
        return normalize(part, context, false);
      }).join("");
    }
    value2 = value2.replace(
      /([^\\])_+/g,
      (fullMatch, characterBefore) => characterBefore + " ".repeat(fullMatch.length - 1)
    ).replace(/^_/g, " ").replace(/\\_/g, "_");
    if (isRoot2) {
      value2 = value2.trim();
    }
    value2 = normalizeMathOperatorSpacing(value2);
    return value2;
  }
  function normalizeMathOperatorSpacing(value2) {
    let preventFormattingInFunctions = ["theme"];
    let preventFormattingKeywords = [
      "min-content",
      "max-content",
      "fit-content",
      "safe-area-inset-top",
      "safe-area-inset-right",
      "safe-area-inset-bottom",
      "safe-area-inset-left",
      "titlebar-area-x",
      "titlebar-area-y",
      "titlebar-area-width",
      "titlebar-area-height",
      "keyboard-inset-top",
      "keyboard-inset-right",
      "keyboard-inset-bottom",
      "keyboard-inset-left",
      "keyboard-inset-width",
      "keyboard-inset-height",
      "radial-gradient",
      "linear-gradient",
      "conic-gradient",
      "repeating-radial-gradient",
      "repeating-linear-gradient",
      "repeating-conic-gradient"
    ];
    return value2.replace(/(calc|min|max|clamp)\(.+\)/g, (match) => {
      let result = "";
      function lastChar() {
        let char = result.trimEnd();
        return char[char.length - 1];
      }
      for (let i = 0; i < match.length; i++) {
        let peek = function(word) {
          return word.split("").every((char2, j) => match[i + j] === char2);
        }, consumeUntil = function(chars) {
          let minIndex = Infinity;
          for (let char2 of chars) {
            let index5 = match.indexOf(char2, i);
            if (index5 !== -1 && index5 < minIndex) {
              minIndex = index5;
            }
          }
          let result2 = match.slice(i, minIndex);
          i += result2.length - 1;
          return result2;
        };
        let char = match[i];
        if (peek("var")) {
          result += consumeUntil([")", ","]);
        } else if (preventFormattingKeywords.some((keyword) => peek(keyword))) {
          let keyword = preventFormattingKeywords.find((keyword2) => peek(keyword2));
          result += keyword;
          i += keyword.length - 1;
        } else if (preventFormattingInFunctions.some((fn) => peek(fn))) {
          result += consumeUntil([")"]);
        } else if (peek("[")) {
          result += consumeUntil(["]"]);
        } else if (["+", "-", "*", "/"].includes(char) && !["(", "+", "-", "*", "/", ","].includes(lastChar())) {
          result += ` ${char} `;
        } else {
          result += char;
        }
      }
      return result.replace(/\s+/g, " ");
    });
  }
  function url(value2) {
    return value2.startsWith("url(");
  }
  function number(value2) {
    return !isNaN(Number(value2)) || isCSSFunction(value2);
  }
  function percentage(value2) {
    return value2.endsWith("%") && number(value2.slice(0, -1)) || isCSSFunction(value2);
  }
  var lengthUnits = [
    "cm",
    "mm",
    "Q",
    "in",
    "pc",
    "pt",
    "px",
    "em",
    "ex",
    "ch",
    "rem",
    "lh",
    "rlh",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "vb",
    "vi",
    "svw",
    "svh",
    "lvw",
    "lvh",
    "dvw",
    "dvh",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
  ];
  var lengthUnitsPattern = `(?:${lengthUnits.join("|")})`;
  function length(value2) {
    return value2 === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${lengthUnitsPattern}$`).test(value2) || isCSSFunction(value2);
  }
  var lineWidths = /* @__PURE__ */ new Set(["thin", "medium", "thick"]);
  function lineWidth(value2) {
    return lineWidths.has(value2);
  }
  function shadow(value2) {
    let parsedShadows = parseBoxShadowValue(normalize(value2));
    for (let parsedShadow of parsedShadows) {
      if (!parsedShadow.valid) {
        return false;
      }
    }
    return true;
  }
  function color(value2) {
    let colors2 = 0;
    let result = splitAtTopLevelOnly(value2, "_").every((part) => {
      part = normalize(part);
      if (part.startsWith("var("))
        return true;
      if (parseColor(part, { loose: true }) !== null)
        return colors2++, true;
      return false;
    });
    if (!result)
      return false;
    return colors2 > 0;
  }
  function image(value2) {
    let images = 0;
    let result = splitAtTopLevelOnly(value2, ",").every((part) => {
      part = normalize(part);
      if (part.startsWith("var("))
        return true;
      if (url(part) || gradient(part) || ["element(", "image(", "cross-fade(", "image-set("].some((fn) => part.startsWith(fn))) {
        images++;
        return true;
      }
      return false;
    });
    if (!result)
      return false;
    return images > 0;
  }
  var gradientTypes = /* @__PURE__ */ new Set([
    "conic-gradient",
    "linear-gradient",
    "radial-gradient",
    "repeating-conic-gradient",
    "repeating-linear-gradient",
    "repeating-radial-gradient"
  ]);
  function gradient(value2) {
    value2 = normalize(value2);
    for (let type of gradientTypes) {
      if (value2.startsWith(`${type}(`)) {
        return true;
      }
    }
    return false;
  }
  var validPositions = /* @__PURE__ */ new Set(["center", "top", "right", "bottom", "left"]);
  function position(value2) {
    let positions = 0;
    let result = splitAtTopLevelOnly(value2, "_").every((part) => {
      part = normalize(part);
      if (part.startsWith("var("))
        return true;
      if (validPositions.has(part) || length(part) || percentage(part)) {
        positions++;
        return true;
      }
      return false;
    });
    if (!result)
      return false;
    return positions > 0;
  }
  function familyName(value2) {
    let fonts = 0;
    let result = splitAtTopLevelOnly(value2, ",").every((part) => {
      part = normalize(part);
      if (part.startsWith("var("))
        return true;
      if (part.includes(" ")) {
        if (!/(['"])([^"']+)\1/g.test(part)) {
          return false;
        }
      }
      if (/^\d/g.test(part)) {
        return false;
      }
      fonts++;
      return true;
    });
    if (!result)
      return false;
    return fonts > 0;
  }
  var genericNames = /* @__PURE__ */ new Set([
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
    "ui-serif",
    "ui-sans-serif",
    "ui-monospace",
    "ui-rounded",
    "math",
    "emoji",
    "fangsong"
  ]);
  function genericName(value2) {
    return genericNames.has(value2);
  }
  var absoluteSizes = /* @__PURE__ */ new Set([
    "xx-small",
    "x-small",
    "small",
    "medium",
    "large",
    "x-large",
    "x-large",
    "xxx-large"
  ]);
  function absoluteSize(value2) {
    return absoluteSizes.has(value2);
  }
  var relativeSizes = /* @__PURE__ */ new Set(["larger", "smaller"]);
  function relativeSize(value2) {
    return relativeSizes.has(value2);
  }
  function negateValue(value2) {
    value2 = `${value2}`;
    if (value2 === "0") {
      return "0";
    }
    if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(value2)) {
      return value2.replace(/^[+-]?/, (sign) => sign === "-" ? "" : "-");
    }
    let numericFunctions = ["var", "calc", "min", "max", "clamp"];
    for (const fn of numericFunctions) {
      if (value2.includes(`${fn}(`)) {
        return `calc(${value2} * -1)`;
      }
    }
  }
  function backgroundSize(value2) {
    let keywordValues = ["cover", "contain"];
    return splitAtTopLevelOnly(value2, ",").every((part) => {
      let sizes = splitAtTopLevelOnly(part, "_").filter(Boolean);
      if (sizes.length === 1 && keywordValues.includes(sizes[0]))
        return true;
      if (sizes.length !== 1 && sizes.length !== 2)
        return false;
      return sizes.every((size) => length(size) || percentage(size) || size === "auto");
    });
  }
  var picocolors_default = {
    yellow: (input) => input
  };
  var defaults = {
    optimizeUniversalDefaults: false,
    generalizedModifiers: true,
    get disableColorOpacityUtilitiesByDefault() {
      return false;
    },
    get relativeContentPathsByDefault() {
      return false;
    }
  };
  var featureFlags = {
    future: [
      "hoverOnlyWhenSupported",
      "respectDefaultRingColorOpacity",
      "disableColorOpacityUtilitiesByDefault",
      "relativeContentPathsByDefault"
    ],
    experimental: ["optimizeUniversalDefaults", "generalizedModifiers"]
  };
  function flagEnabled(config5, flag) {
    if (featureFlags.future.includes(flag)) {
      return config5.future === "all" || (config5?.future?.[flag] ?? defaults[flag] ?? false);
    }
    if (featureFlags.experimental.includes(flag)) {
      return config5.experimental === "all" || (config5?.experimental?.[flag] ?? defaults[flag] ?? false);
    }
    return false;
  }
  function experimentalFlagsEnabled(config5) {
    if (config5.experimental === "all") {
      return featureFlags.experimental;
    }
    return Object.keys(config5?.experimental ?? {}).filter(
      (flag) => featureFlags.experimental.includes(flag) && config5.experimental[flag]
    );
  }
  function issueFlagNotices(config5) {
    if (true) {
      return;
    }
    if (experimentalFlagsEnabled(config5).length > 0) {
      let changes = experimentalFlagsEnabled(config5).map((s) => picocolors_default.yellow(s)).join(", ");
      log_default.warn("experimental-flags-enabled", [
        `You have enabled experimental features: ${changes}`,
        "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
      ]);
    }
  }
  function updateAllClasses(selectors, updateClass) {
    selectors.walkClasses((sel) => {
      sel.value = updateClass(sel.value);
      if (sel.raws && sel.raws.value) {
        sel.raws.value = escapeCommas(sel.raws.value);
      }
    });
  }
  function resolveArbitraryValue(modifier, validate) {
    if (!isArbitraryValue(modifier)) {
      return void 0;
    }
    let value2 = modifier.slice(1, -1);
    if (!validate(value2)) {
      return void 0;
    }
    return normalize(value2);
  }
  function asNegativeValue(modifier, lookup = {}, validate) {
    let positiveValue = lookup[modifier];
    if (positiveValue !== void 0) {
      return negateValue(positiveValue);
    }
    if (isArbitraryValue(modifier)) {
      let resolved = resolveArbitraryValue(modifier, validate);
      if (resolved === void 0) {
        return void 0;
      }
      return negateValue(resolved);
    }
  }
  function asValue(modifier, options = {}, { validate = () => true } = {}) {
    let value2 = options.values?.[modifier];
    if (value2 !== void 0) {
      return value2;
    }
    if (options.supportsNegativeValues && modifier.startsWith("-")) {
      return asNegativeValue(modifier.slice(1), options.values, validate);
    }
    return resolveArbitraryValue(modifier, validate);
  }
  function isArbitraryValue(input) {
    return input.startsWith("[") && input.endsWith("]");
  }
  function splitUtilityModifier(modifier) {
    let slashIdx = modifier.lastIndexOf("/");
    let arbitraryStartIdx = modifier.lastIndexOf("[", slashIdx);
    let arbitraryEndIdx = modifier.indexOf("]", slashIdx);
    let isNextToArbitrary = modifier[slashIdx - 1] === "]" || modifier[slashIdx + 1] === "[";
    if (!isNextToArbitrary) {
      if (arbitraryStartIdx !== -1 && arbitraryEndIdx !== -1) {
        if (arbitraryStartIdx < slashIdx && slashIdx < arbitraryEndIdx) {
          slashIdx = modifier.lastIndexOf("/", arbitraryStartIdx);
        }
      }
    }
    if (slashIdx === -1 || slashIdx === modifier.length - 1) {
      return [modifier, void 0];
    }
    let arbitrary = isArbitraryValue(modifier);
    if (arbitrary && !modifier.includes("]/[")) {
      return [modifier, void 0];
    }
    return [modifier.slice(0, slashIdx), modifier.slice(slashIdx + 1)];
  }
  function parseColorFormat(value2) {
    if (typeof value2 === "string" && value2.includes("<alpha-value>")) {
      let oldValue = value2;
      return ({ opacityValue = 1 }) => oldValue.replace("<alpha-value>", opacityValue);
    }
    return value2;
  }
  function unwrapArbitraryModifier(modifier) {
    return normalize(modifier.slice(1, -1));
  }
  function asColor(modifier, options = {}, { tailwindConfig: tailwindConfig2 = {} } = {}) {
    if (options.values?.[modifier] !== void 0) {
      return parseColorFormat(options.values?.[modifier]);
    }
    let [color2, alpha] = splitUtilityModifier(modifier);
    if (alpha !== void 0) {
      let normalizedColor = options.values?.[color2] ?? (isArbitraryValue(color2) ? color2.slice(1, -1) : void 0);
      if (normalizedColor === void 0) {
        return void 0;
      }
      normalizedColor = parseColorFormat(normalizedColor);
      if (isArbitraryValue(alpha)) {
        return withAlphaValue(normalizedColor, unwrapArbitraryModifier(alpha));
      }
      if (tailwindConfig2.theme?.opacity?.[alpha] === void 0) {
        return void 0;
      }
      return withAlphaValue(normalizedColor, tailwindConfig2.theme.opacity[alpha]);
    }
    return asValue(modifier, options, { validate: color });
  }
  function asLookupValue(modifier, options = {}) {
    return options.values?.[modifier];
  }
  function guess(validate) {
    return (modifier, options) => {
      return asValue(modifier, options, { validate });
    };
  }
  var typeMap = {
    any: asValue,
    color: asColor,
    url: guess(url),
    image: guess(image),
    length: guess(length),
    percentage: guess(percentage),
    position: guess(position),
    lookup: asLookupValue,
    "generic-name": guess(genericName),
    "family-name": guess(familyName),
    number: guess(number),
    "line-width": guess(lineWidth),
    "absolute-size": guess(absoluteSize),
    "relative-size": guess(relativeSize),
    shadow: guess(shadow),
    size: guess(backgroundSize)
  };
  var supportedTypes = Object.keys(typeMap);
  function splitAtFirst(input, delim) {
    let idx = input.indexOf(delim);
    if (idx === -1)
      return [void 0, input];
    return [input.slice(0, idx), input.slice(idx + 1)];
  }
  function coerceValue(types2, modifier, options, tailwindConfig2) {
    if (options.values && modifier in options.values) {
      for (let { type } of types2 ?? []) {
        let result = typeMap[type](modifier, options, {
          tailwindConfig: tailwindConfig2
        });
        if (result === void 0) {
          continue;
        }
        return [result, type, null];
      }
    }
    if (isArbitraryValue(modifier)) {
      let arbitraryValue = modifier.slice(1, -1);
      let [explicitType, value2] = splitAtFirst(arbitraryValue, ":");
      if (!/^[\w-_]+$/g.test(explicitType)) {
        value2 = arbitraryValue;
      } else if (explicitType !== void 0 && !supportedTypes.includes(explicitType)) {
        return [];
      }
      if (value2.length > 0 && supportedTypes.includes(explicitType)) {
        return [asValue(`[${value2}]`, options), explicitType, null];
      }
    }
    let matches = getMatchingTypes(types2, modifier, options, tailwindConfig2);
    for (let match of matches) {
      return match;
    }
    return [];
  }
  function* getMatchingTypes(types2, rawModifier, options, tailwindConfig2) {
    let modifiersEnabled = flagEnabled(tailwindConfig2, "generalizedModifiers");
    let [modifier, utilityModifier] = splitUtilityModifier(rawModifier);
    let canUseUtilityModifier = modifiersEnabled && options.modifiers != null && (options.modifiers === "any" || typeof options.modifiers === "object" && (utilityModifier && isArbitraryValue(utilityModifier) || utilityModifier in options.modifiers));
    if (!canUseUtilityModifier) {
      modifier = rawModifier;
      utilityModifier = void 0;
    }
    if (utilityModifier !== void 0 && modifier === "") {
      modifier = "DEFAULT";
    }
    if (utilityModifier !== void 0) {
      if (typeof options.modifiers === "object") {
        let configValue = options.modifiers?.[utilityModifier] ?? null;
        if (configValue !== null) {
          utilityModifier = configValue;
        } else if (isArbitraryValue(utilityModifier)) {
          utilityModifier = unwrapArbitraryModifier(utilityModifier);
        }
      }
    }
    for (let { type } of types2 ?? []) {
      let result = typeMap[type](modifier, options, {
        tailwindConfig: tailwindConfig2
      });
      if (result === void 0) {
        continue;
      }
      yield [result, type, utilityModifier ?? null];
    }
  }
  function escapeClassName(className) {
    let node = import_postcss_selector_parser4.default.className();
    node.value = className;
    return escapeCommas(node?.raws?.value ?? node.value);
  }
  var elementProperties = {
    "::after": ["terminal", "jumpable"],
    "::backdrop": ["terminal", "jumpable"],
    "::before": ["terminal", "jumpable"],
    "::cue": ["terminal"],
    "::cue-region": ["terminal"],
    "::first-letter": ["terminal", "jumpable"],
    "::first-line": ["terminal", "jumpable"],
    "::grammar-error": ["terminal"],
    "::marker": ["terminal", "jumpable"],
    "::part": ["terminal", "actionable"],
    "::placeholder": ["terminal", "jumpable"],
    "::selection": ["terminal", "jumpable"],
    "::slotted": ["terminal"],
    "::spelling-error": ["terminal"],
    "::target-text": ["terminal"],
    "::file-selector-button": ["terminal", "actionable"],
    "::deep": ["actionable"],
    "::v-deep": ["actionable"],
    "::ng-deep": ["actionable"],
    ":after": ["terminal", "jumpable"],
    ":before": ["terminal", "jumpable"],
    ":first-letter": ["terminal", "jumpable"],
    ":first-line": ["terminal", "jumpable"],
    ":where": [],
    ":is": [],
    ":has": [],
    __default__: ["terminal", "actionable"]
  };
  function movePseudos(sel) {
    let [pseudos] = movablePseudos(sel);
    pseudos.forEach(([sel2, pseudo]) => sel2.removeChild(pseudo));
    sel.nodes.push(...pseudos.map(([, pseudo]) => pseudo));
    return sel;
  }
  function movablePseudos(sel) {
    let buffer = [];
    let lastSeenElement = null;
    for (let node of sel.nodes) {
      if (node.type === "combinator") {
        buffer = buffer.filter(([, node2]) => propertiesForPseudo(node2).includes("jumpable"));
        lastSeenElement = null;
      } else if (node.type === "pseudo") {
        if (isMovablePseudoElement(node)) {
          lastSeenElement = node;
          buffer.push([sel, node, null]);
        } else if (lastSeenElement && isAttachablePseudoClass(node, lastSeenElement)) {
          buffer.push([sel, node, lastSeenElement]);
        } else {
          lastSeenElement = null;
        }
        for (let sub of node.nodes ?? []) {
          let [movable, lastSeenElementInSub] = movablePseudos(sub);
          lastSeenElement = lastSeenElementInSub || lastSeenElement;
          buffer.push(...movable);
        }
      }
    }
    return [buffer, lastSeenElement];
  }
  function isPseudoElement(node) {
    return node.value.startsWith("::") || elementProperties[node.value] !== void 0;
  }
  function isMovablePseudoElement(node) {
    return isPseudoElement(node) && propertiesForPseudo(node).includes("terminal");
  }
  function isAttachablePseudoClass(node, pseudo) {
    if (node.type !== "pseudo")
      return false;
    if (isPseudoElement(node))
      return false;
    return propertiesForPseudo(pseudo).includes("actionable");
  }
  function propertiesForPseudo(pseudo) {
    return elementProperties[pseudo.value] ?? elementProperties.__default__;
  }
  var MERGE = ":merge";
  function formatVariantSelector(formats, { context, candidate }) {
    let prefix3 = context?.tailwindConfig.prefix ?? "";
    let parsedFormats = formats.map((format) => {
      let ast = (0, import_postcss_selector_parser3.default)().astSync(format.format);
      return {
        ...format,
        ast: format.respectPrefix ? prefixSelector_default(prefix3, ast) : ast
      };
    });
    let formatAst = import_postcss_selector_parser3.default.root({
      nodes: [
        import_postcss_selector_parser3.default.selector({
          nodes: [import_postcss_selector_parser3.default.className({ value: escapeClassName(candidate) })]
        })
      ]
    });
    for (let { ast } of parsedFormats) {
      ;
      [formatAst, ast] = handleMergePseudo(formatAst, ast);
      ast.walkNesting((nesting) => nesting.replaceWith(...formatAst.nodes[0].nodes));
      formatAst = ast;
    }
    return formatAst;
  }
  function simpleSelectorForNode(node) {
    let nodes = [];
    while (node.prev() && node.prev().type !== "combinator") {
      node = node.prev();
    }
    while (node && node.type !== "combinator") {
      nodes.push(node);
      node = node.next();
    }
    return nodes;
  }
  function resortSelector(sel) {
    sel.sort((a, b) => {
      if (a.type === "tag" && b.type === "class") {
        return -1;
      } else if (a.type === "class" && b.type === "tag") {
        return 1;
      } else if (a.type === "class" && b.type === "pseudo" && b.value.startsWith("::")) {
        return -1;
      } else if (a.type === "pseudo" && a.value.startsWith("::") && b.type === "class") {
        return 1;
      }
      return sel.index(a) - sel.index(b);
    });
    return sel;
  }
  function eliminateIrrelevantSelectors(sel, base) {
    let hasClassesMatchingCandidate = false;
    sel.walk((child2) => {
      if (child2.type === "class" && child2.value === base) {
        hasClassesMatchingCandidate = true;
        return false;
      }
    });
    if (!hasClassesMatchingCandidate) {
      sel.remove();
    }
  }
  function finalizeSelector(current, formats, { context, candidate, base }) {
    let separator = context?.tailwindConfig?.separator ?? ":";
    base = base ?? splitAtTopLevelOnly(candidate, separator).pop();
    let selector = (0, import_postcss_selector_parser3.default)().astSync(current);
    selector.walkClasses((node) => {
      if (node.raws && node.value.includes(base)) {
        node.raws.value = escapeClassName((0, import_unesc.default)(node.raws.value));
      }
    });
    selector.each((sel) => eliminateIrrelevantSelectors(sel, base));
    if (selector.length === 0) {
      return null;
    }
    let formatAst = Array.isArray(formats) ? formatVariantSelector(formats, { context, candidate }) : formats;
    if (formatAst === null) {
      return selector.toString();
    }
    let simpleStart = import_postcss_selector_parser3.default.comment({ value: "/*__simple__*/" });
    let simpleEnd = import_postcss_selector_parser3.default.comment({ value: "/*__simple__*/" });
    selector.walkClasses((node) => {
      if (node.value !== base) {
        return;
      }
      let parent = node.parent;
      let formatNodes = formatAst.nodes[0].nodes;
      if (parent.nodes.length === 1) {
        node.replaceWith(...formatNodes);
        return;
      }
      let simpleSelector = simpleSelectorForNode(node);
      parent.insertBefore(simpleSelector[0], simpleStart);
      parent.insertAfter(simpleSelector[simpleSelector.length - 1], simpleEnd);
      for (let child2 of formatNodes) {
        parent.insertBefore(simpleSelector[0], child2.clone());
      }
      node.remove();
      simpleSelector = simpleSelectorForNode(simpleStart);
      let firstNode = parent.index(simpleStart);
      parent.nodes.splice(
        firstNode,
        simpleSelector.length,
        ...resortSelector(import_postcss_selector_parser3.default.selector({ nodes: simpleSelector })).nodes
      );
      simpleStart.remove();
      simpleEnd.remove();
    });
    selector.walkPseudos((p) => {
      if (p.value === MERGE) {
        p.replaceWith(p.nodes);
      }
    });
    selector.each((sel) => movePseudos(sel));
    return selector.toString();
  }
  function handleMergePseudo(selector, format) {
    let merges = [];
    selector.walkPseudos((pseudo) => {
      if (pseudo.value === MERGE) {
        merges.push({
          pseudo,
          value: pseudo.nodes[0].toString()
        });
      }
    });
    format.walkPseudos((pseudo) => {
      if (pseudo.value !== MERGE) {
        return;
      }
      let value2 = pseudo.nodes[0].toString();
      let existing = merges.find((merge3) => merge3.value === value2);
      if (!existing) {
        return;
      }
      let attachments = [];
      let next2 = pseudo.next();
      while (next2 && next2.type !== "combinator") {
        attachments.push(next2);
        next2 = next2.next();
      }
      let combinator = next2;
      existing.pseudo.parent.insertAfter(
        existing.pseudo,
        import_postcss_selector_parser3.default.selector({ nodes: attachments.map((node) => node.clone()) })
      );
      pseudo.remove();
      attachments.forEach((node) => node.remove());
      if (combinator && combinator.type === "combinator") {
        combinator.remove();
      }
    });
    return [selector, format];
  }
  function asClass(name) {
    return escapeCommas(`.${escapeClassName(name)}`);
  }
  function nameClass(classPrefix, key) {
    return asClass(formatClass(classPrefix, key));
  }
  function formatClass(classPrefix, key) {
    if (key === "DEFAULT") {
      return classPrefix;
    }
    if (key === "-" || key === "-DEFAULT") {
      return `-${classPrefix}`;
    }
    if (key.startsWith("-")) {
      return `-${classPrefix}${key}`;
    }
    if (key.startsWith("/")) {
      return `${classPrefix}${key}`;
    }
    return `${classPrefix}-${key}`;
  }
  function transformThemeValue(themeSection) {
    if (["fontSize", "outline"].includes(themeSection)) {
      return (value2) => {
        if (typeof value2 === "function")
          value2 = value2({});
        if (Array.isArray(value2))
          value2 = value2[0];
        return value2;
      };
    }
    if (themeSection === "fontFamily") {
      return (value2) => {
        if (typeof value2 === "function")
          value2 = value2({});
        let families = Array.isArray(value2) && isPlainObject(value2[1]) ? value2[0] : value2;
        return Array.isArray(families) ? families.join(", ") : families;
      };
    }
    if ([
      "boxShadow",
      "transitionProperty",
      "transitionDuration",
      "transitionDelay",
      "transitionTimingFunction",
      "backgroundImage",
      "backgroundSize",
      "backgroundColor",
      "cursor",
      "animation"
    ].includes(themeSection)) {
      return (value2) => {
        if (typeof value2 === "function")
          value2 = value2({});
        if (Array.isArray(value2))
          value2 = value2.join(", ");
        return value2;
      };
    }
    if (["gridTemplateColumns", "gridTemplateRows", "objectPosition"].includes(themeSection)) {
      return (value2) => {
        if (typeof value2 === "function")
          value2 = value2({});
        if (typeof value2 === "string")
          value2 = postcss_default.list.comma(value2).join(" ");
        return value2;
      };
    }
    return (value2, opts = {}) => {
      if (typeof value2 === "function") {
        value2 = value2(opts);
      }
      return value2;
    };
  }
  var join = () => "";
  function createUtilityPlugin(themeKey, utilityVariations = [[themeKey, [themeKey]]], { filterDefault = false, ...options } = {}) {
    let transformValue = transformThemeValue(themeKey);
    return function({ matchUtilities, theme: theme2 }) {
      for (let utilityVariation of utilityVariations) {
        let group = Array.isArray(utilityVariation[0]) ? utilityVariation : [utilityVariation];
        matchUtilities(
          group.reduce((obj, [classPrefix, properties]) => {
            return Object.assign(obj, {
              [classPrefix]: (value2) => {
                return properties.reduce((obj2, name) => {
                  if (Array.isArray(name)) {
                    return Object.assign(obj2, { [name[0]]: name[1] });
                  }
                  return Object.assign(obj2, { [name]: transformValue(value2) });
                }, {});
              }
            });
          }, {}),
          {
            ...options,
            values: filterDefault ? Object.fromEntries(
              Object.entries(theme2(themeKey) ?? {}).filter(([modifier]) => modifier !== "DEFAULT")
            ) : theme2(themeKey)
          }
        );
      }
    };
  }
  function buildMediaQuery(screens) {
    screens = Array.isArray(screens) ? screens : [screens];
    return screens.map((screen) => {
      let values = screen.values.map((screen2) => {
        if (screen2.raw !== void 0) {
          return screen2.raw;
        }
        return [
          screen2.min && `(min-width: ${screen2.min})`,
          screen2.max && `(max-width: ${screen2.max})`
        ].filter(Boolean).join(" and ");
      });
      return screen.not ? `not all and ${values}` : values;
    }).join(", ");
  }
  var DIRECTIONS = /* @__PURE__ */ new Set(["normal", "reverse", "alternate", "alternate-reverse"]);
  var PLAY_STATES = /* @__PURE__ */ new Set(["running", "paused"]);
  var FILL_MODES = /* @__PURE__ */ new Set(["none", "forwards", "backwards", "both"]);
  var ITERATION_COUNTS = /* @__PURE__ */ new Set(["infinite"]);
  var TIMINGS = /* @__PURE__ */ new Set([
    "linear",
    "ease",
    "ease-in",
    "ease-out",
    "ease-in-out",
    "step-start",
    "step-end"
  ]);
  var TIMING_FNS = ["cubic-bezier", "steps"];
  var COMMA = /\,(?![^(]*\))/g;
  var SPACE2 = /\ +(?![^(]*\))/g;
  var TIME = /^(-?[\d.]+m?s)$/;
  var DIGIT = /^(\d+)$/;
  function parseAnimationValue(input) {
    let animations = input.split(COMMA);
    return animations.map((animation2) => {
      let value2 = animation2.trim();
      let result = { value: value2 };
      let parts = value2.split(SPACE2);
      let seen = /* @__PURE__ */ new Set();
      for (let part of parts) {
        if (!seen.has("DIRECTIONS") && DIRECTIONS.has(part)) {
          result.direction = part;
          seen.add("DIRECTIONS");
        } else if (!seen.has("PLAY_STATES") && PLAY_STATES.has(part)) {
          result.playState = part;
          seen.add("PLAY_STATES");
        } else if (!seen.has("FILL_MODES") && FILL_MODES.has(part)) {
          result.fillMode = part;
          seen.add("FILL_MODES");
        } else if (!seen.has("ITERATION_COUNTS") && (ITERATION_COUNTS.has(part) || DIGIT.test(part))) {
          result.iterationCount = part;
          seen.add("ITERATION_COUNTS");
        } else if (!seen.has("TIMING_FUNCTION") && TIMINGS.has(part)) {
          result.timingFunction = part;
          seen.add("TIMING_FUNCTION");
        } else if (!seen.has("TIMING_FUNCTION") && TIMING_FNS.some((f) => part.startsWith(`${f}(`))) {
          result.timingFunction = part;
          seen.add("TIMING_FUNCTION");
        } else if (!seen.has("DURATION") && TIME.test(part)) {
          result.duration = part;
          seen.add("DURATION");
        } else if (!seen.has("DELAY") && TIME.test(part)) {
          result.delay = part;
          seen.add("DELAY");
        } else if (!seen.has("NAME")) {
          result.name = part;
          seen.add("NAME");
        } else {
          if (!result.unknown)
            result.unknown = [];
          result.unknown.push(part);
        }
      }
      return result;
    });
  }
  var flattenColorPalette = (colors2) => Object.assign(
    {},
    ...Object.entries(colors2 ?? {}).flatMap(
      ([color2, values]) => typeof values == "object" ? Object.entries(flattenColorPalette(values)).map(([number2, hex]) => ({
        [color2 + (number2 === "DEFAULT" ? "" : `-${number2}`)]: hex
      })) : [{ [`${color2}`]: values }]
    )
  );
  var flattenColorPalette_default = flattenColorPalette;
  function toColorValue(maybeFunction) {
    return typeof maybeFunction === "function" ? maybeFunction({}) : maybeFunction;
  }
  function normalizeScreens(screens, root12 = true) {
    if (Array.isArray(screens)) {
      return screens.map((screen) => {
        if (root12 && Array.isArray(screen)) {
          throw new Error("The tuple syntax is not supported for `screens`.");
        }
        if (typeof screen === "string") {
          return { name: screen.toString(), not: false, values: [{ min: screen, max: void 0 }] };
        }
        let [name, options] = screen;
        name = name.toString();
        if (typeof options === "string") {
          return { name, not: false, values: [{ min: options, max: void 0 }] };
        }
        if (Array.isArray(options)) {
          return { name, not: false, values: options.map((option) => resolveValue(option)) };
        }
        return { name, not: false, values: [resolveValue(options)] };
      });
    }
    return normalizeScreens(Object.entries(screens ?? {}), false);
  }
  function isScreenSortable(screen) {
    if (screen.values.length !== 1) {
      return { result: false, reason: "multiple-values" };
    } else if (screen.values[0].raw !== void 0) {
      return { result: false, reason: "raw-values" };
    } else if (screen.values[0].min !== void 0 && screen.values[0].max !== void 0) {
      return { result: false, reason: "min-and-max" };
    }
    return { result: true, reason: null };
  }
  function compareScreens(type, a, z) {
    let aScreen = toScreen(a, type);
    let zScreen = toScreen(z, type);
    let aSorting = isScreenSortable(aScreen);
    let bSorting = isScreenSortable(zScreen);
    if (aSorting.reason === "multiple-values" || bSorting.reason === "multiple-values") {
      throw new Error(
        "Attempted to sort a screen with multiple values. This should never happen. Please open a bug report."
      );
    } else if (aSorting.reason === "raw-values" || bSorting.reason === "raw-values") {
      throw new Error(
        "Attempted to sort a screen with raw values. This should never happen. Please open a bug report."
      );
    } else if (aSorting.reason === "min-and-max" || bSorting.reason === "min-and-max") {
      throw new Error(
        "Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report."
      );
    }
    let { min: aMin, max: aMax } = aScreen.values[0];
    let { min: zMin, max: zMax } = zScreen.values[0];
    if (a.not)
      [aMin, aMax] = [aMax, aMin];
    if (z.not)
      [zMin, zMax] = [zMax, zMin];
    aMin = aMin === void 0 ? aMin : parseFloat(aMin);
    aMax = aMax === void 0 ? aMax : parseFloat(aMax);
    zMin = zMin === void 0 ? zMin : parseFloat(zMin);
    zMax = zMax === void 0 ? zMax : parseFloat(zMax);
    let [aValue, zValue] = type === "min" ? [aMin, zMin] : [zMax, aMax];
    return aValue - zValue;
  }
  function toScreen(value2, type) {
    if (typeof value2 === "object") {
      return value2;
    }
    return {
      name: "arbitrary-screen",
      values: [{ [type]: value2 }]
    };
  }
  function resolveValue({ "min-width": _minWidth, min = _minWidth, max: max2, raw } = {}) {
    return { min, max: max2, raw };
  }
  function removeAlphaVariables(container, toRemove) {
    container.walkDecls((decl2) => {
      if (toRemove.includes(decl2.prop)) {
        decl2.remove();
        return;
      }
      for (let varName of toRemove) {
        if (decl2.value.includes(`/ var(${varName})`)) {
          decl2.value = decl2.value.replace(`/ var(${varName})`, "");
        }
      }
    });
  }
  var variantPlugins = {
    childVariant: ({ addVariant }) => {
      addVariant("*", "& > *");
    },
    pseudoElementVariants: ({ addVariant }) => {
      addVariant("first-letter", "&::first-letter");
      addVariant("first-line", "&::first-line");
      addVariant("marker", [
        ({ container }) => {
          removeAlphaVariables(container, ["--tw-text-opacity"]);
          return "& *::marker";
        },
        ({ container }) => {
          removeAlphaVariables(container, ["--tw-text-opacity"]);
          return "&::marker";
        }
      ]);
      addVariant("selection", ["& *::selection", "&::selection"]);
      addVariant("file", "&::file-selector-button");
      addVariant("placeholder", "&::placeholder");
      addVariant("backdrop", "&::backdrop");
      addVariant("before", ({ container }) => {
        container.walkRules((rule2) => {
          let foundContent = false;
          rule2.walkDecls("content", () => {
            foundContent = true;
          });
          if (!foundContent) {
            rule2.prepend(postcss_default.decl({ prop: "content", value: "var(--tw-content)" }));
          }
        });
        return "&::before";
      });
      addVariant("after", ({ container }) => {
        container.walkRules((rule2) => {
          let foundContent = false;
          rule2.walkDecls("content", () => {
            foundContent = true;
          });
          if (!foundContent) {
            rule2.prepend(postcss_default.decl({ prop: "content", value: "var(--tw-content)" }));
          }
        });
        return "&::after";
      });
    },
    pseudoClassVariants: ({ addVariant, matchVariant, config: config5, prefix: prefix3 }) => {
      let pseudoVariants = [
        ["first", "&:first-child"],
        ["last", "&:last-child"],
        ["only", "&:only-child"],
        ["odd", "&:nth-child(odd)"],
        ["even", "&:nth-child(even)"],
        "first-of-type",
        "last-of-type",
        "only-of-type",
        [
          "visited",
          ({ container }) => {
            removeAlphaVariables(container, [
              "--tw-text-opacity",
              "--tw-border-opacity",
              "--tw-bg-opacity"
            ]);
            return "&:visited";
          }
        ],
        "target",
        ["open", "&[open]"],
        "default",
        "checked",
        "indeterminate",
        "placeholder-shown",
        "autofill",
        "optional",
        "required",
        "valid",
        "invalid",
        "in-range",
        "out-of-range",
        "read-only",
        "empty",
        "focus-within",
        [
          "hover",
          !flagEnabled(config5(), "hoverOnlyWhenSupported") ? "&:hover" : "@media (hover: hover) and (pointer: fine) { &:hover }"
        ],
        "focus",
        "focus-visible",
        "active",
        "enabled",
        "disabled"
      ].map((variant) => Array.isArray(variant) ? variant : [variant, `&:${variant}`]);
      for (let [variantName, state2] of pseudoVariants) {
        addVariant(variantName, (ctx) => {
          let result = typeof state2 === "function" ? state2(ctx) : state2;
          return result;
        });
      }
      let variants = {
        group: (_, { modifier }) => modifier ? [`:merge(${prefix3(".group")}\\/${escapeClassName(modifier)})`, " &"] : [`:merge(${prefix3(".group")})`, " &"],
        peer: (_, { modifier }) => modifier ? [`:merge(${prefix3(".peer")}\\/${escapeClassName(modifier)})`, " ~ &"] : [`:merge(${prefix3(".peer")})`, " ~ &"]
      };
      for (let [name, fn] of Object.entries(variants)) {
        matchVariant(
          name,
          (value2 = "", extra) => {
            let result = normalize(typeof value2 === "function" ? value2(extra) : value2);
            if (!result.includes("&"))
              result = "&" + result;
            let [a, b] = fn("", extra);
            let start = null;
            let end = null;
            let quotes2 = 0;
            for (let i = 0; i < result.length; ++i) {
              let c = result[i];
              if (c === "&") {
                start = i;
              } else if (c === "'" || c === '"') {
                quotes2 += 1;
              } else if (start !== null && c === " " && !quotes2) {
                end = i;
              }
            }
            if (start !== null && end === null) {
              end = result.length;
            }
            return result.slice(0, start) + a + result.slice(start + 1, end) + b + result.slice(end);
          },
          {
            values: Object.fromEntries(pseudoVariants),
            [INTERNAL_FEATURES]: {
              respectPrefix: false
            }
          }
        );
      }
    },
    directionVariants: ({ addVariant }) => {
      addVariant("ltr", '&:where([dir="ltr"], [dir="ltr"] *)');
      addVariant("rtl", '&:where([dir="rtl"], [dir="rtl"] *)');
    },
    reducedMotionVariants: ({ addVariant }) => {
      addVariant("motion-safe", "@media (prefers-reduced-motion: no-preference)");
      addVariant("motion-reduce", "@media (prefers-reduced-motion: reduce)");
    },
    darkVariants: ({ config: config5, addVariant }) => {
      let [mode, selector = ".dark"] = [].concat(config5("darkMode", "media"));
      if (mode === false) {
        mode = "media";
        log_default.warn("darkmode-false", [
          "The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.",
          "Change `darkMode` to `media` or remove it entirely.",
          "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"
        ]);
      }
      if (mode === "variant") {
        let formats;
        if (Array.isArray(selector)) {
          formats = selector;
        } else if (typeof selector === "function") {
          formats = selector;
        } else if (typeof selector === "string") {
          formats = [selector];
        }
        if (Array.isArray(formats)) {
          for (let format of formats) {
            if (format === ".dark") {
              mode = false;
              log_default.warn("darkmode-variant-without-selector", [
                "When using `variant` for `darkMode`, you must provide a selector.",
                'Example: `darkMode: ["variant", ".your-selector &"]`'
              ]);
            } else if (!format.includes("&")) {
              mode = false;
              log_default.warn("darkmode-variant-without-ampersand", [
                "When using `variant` for `darkMode`, your selector must contain `&`.",
                'Example `darkMode: ["variant", ".your-selector &"]`'
              ]);
            }
          }
        }
        selector = formats;
      }
      if (mode === "selector") {
        addVariant("dark", `&:where(${selector}, ${selector} *)`);
      } else if (mode === "media") {
        addVariant("dark", "@media (prefers-color-scheme: dark)");
      } else if (mode === "variant") {
        addVariant("dark", selector);
      } else if (mode === "class") {
        addVariant("dark", `:is(${selector} &)`);
      }
    },
    printVariant: ({ addVariant }) => {
      addVariant("print", "@media print");
    },
    screenVariants: ({ theme: theme2, addVariant, matchVariant }) => {
      let rawScreens = theme2("screens") ?? {};
      let areSimpleScreens = Object.values(rawScreens).every((v) => typeof v === "string");
      let screens = normalizeScreens(theme2("screens"));
      let unitCache = /* @__PURE__ */ new Set([]);
      function units(value2) {
        return value2.match(/(\D+)$/)?.[1] ?? "(none)";
      }
      function recordUnits(value2) {
        if (value2 !== void 0) {
          unitCache.add(units(value2));
        }
      }
      function canUseUnits(value2) {
        recordUnits(value2);
        return unitCache.size === 1;
      }
      for (const screen of screens) {
        for (const value2 of screen.values) {
          recordUnits(value2.min);
          recordUnits(value2.max);
        }
      }
      let screensUseConsistentUnits = unitCache.size <= 1;
      function buildScreenValues(type) {
        return Object.fromEntries(
          screens.filter((screen) => isScreenSortable(screen).result).map((screen) => {
            let { min, max: max2 } = screen.values[0];
            if (type === "min" && min !== void 0) {
              return screen;
            } else if (type === "min" && max2 !== void 0) {
              return { ...screen, not: !screen.not };
            } else if (type === "max" && max2 !== void 0) {
              return screen;
            } else if (type === "max" && min !== void 0) {
              return { ...screen, not: !screen.not };
            }
          }).map((screen) => [screen.name, screen])
        );
      }
      function buildSort(type) {
        return (a, z) => compareScreens(type, a.value, z.value);
      }
      let maxSort = buildSort("max");
      let minSort = buildSort("min");
      function buildScreenVariant(type) {
        return (value2) => {
          if (!areSimpleScreens) {
            log_default.warn("complex-screen-config", [
              "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."
            ]);
            return [];
          } else if (!screensUseConsistentUnits) {
            log_default.warn("mixed-screen-units", [
              "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
            ]);
            return [];
          } else if (typeof value2 === "string" && !canUseUnits(value2)) {
            log_default.warn("minmax-have-mixed-units", [
              "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
            ]);
            return [];
          }
          return [`@media ${buildMediaQuery(toScreen(value2, type))}`];
        };
      }
      matchVariant("max", buildScreenVariant("max"), {
        sort: maxSort,
        values: areSimpleScreens ? buildScreenValues("max") : {}
      });
      let id = "min-screens";
      for (let screen of screens) {
        addVariant(screen.name, `@media ${buildMediaQuery(screen)}`, {
          id,
          sort: areSimpleScreens && screensUseConsistentUnits ? minSort : void 0,
          value: screen
        });
      }
      matchVariant("min", buildScreenVariant("min"), {
        id,
        sort: minSort
      });
    },
    supportsVariants: ({ matchVariant, theme: theme2 }) => {
      matchVariant(
        "supports",
        (value2 = "") => {
          let check = normalize(value2);
          let isRaw = /^\w*\s*\(/.test(check);
          check = isRaw ? check.replace(/\b(and|or|not)\b/g, " $1 ") : check;
          if (isRaw) {
            return `@supports ${check}`;
          }
          if (!check.includes(":")) {
            check = `${check}: var(--tw)`;
          }
          if (!(check.startsWith("(") && check.endsWith(")"))) {
            check = `(${check})`;
          }
          return `@supports ${check}`;
        },
        { values: theme2("supports") ?? {} }
      );
    },
    hasVariants: ({ matchVariant }) => {
      matchVariant("has", (value2) => `&:has(${normalize(value2)})`, { values: {} });
      matchVariant(
        "group-has",
        (value2, { modifier }) => modifier ? `:merge(.group\\/${modifier}):has(${normalize(value2)}) &` : `:merge(.group):has(${normalize(value2)}) &`,
        { values: {} }
      );
      matchVariant(
        "peer-has",
        (value2, { modifier }) => modifier ? `:merge(.peer\\/${modifier}):has(${normalize(value2)}) ~ &` : `:merge(.peer):has(${normalize(value2)}) ~ &`,
        { values: {} }
      );
    },
    ariaVariants: ({ matchVariant, theme: theme2 }) => {
      matchVariant("aria", (value2) => `&[aria-${normalize(value2)}]`, { values: theme2("aria") ?? {} });
      matchVariant(
        "group-aria",
        (value2, { modifier }) => modifier ? `:merge(.group\\/${modifier})[aria-${normalize(value2)}] &` : `:merge(.group)[aria-${normalize(value2)}] &`,
        { values: theme2("aria") ?? {} }
      );
      matchVariant(
        "peer-aria",
        (value2, { modifier }) => modifier ? `:merge(.peer\\/${modifier})[aria-${normalize(value2)}] ~ &` : `:merge(.peer)[aria-${normalize(value2)}] ~ &`,
        { values: theme2("aria") ?? {} }
      );
    },
    dataVariants: ({ matchVariant, theme: theme2 }) => {
      matchVariant("data", (value2) => `&[data-${normalize(value2)}]`, { values: theme2("data") ?? {} });
      matchVariant(
        "group-data",
        (value2, { modifier }) => modifier ? `:merge(.group\\/${modifier})[data-${normalize(value2)}] &` : `:merge(.group)[data-${normalize(value2)}] &`,
        { values: theme2("data") ?? {} }
      );
      matchVariant(
        "peer-data",
        (value2, { modifier }) => modifier ? `:merge(.peer\\/${modifier})[data-${normalize(value2)}] ~ &` : `:merge(.peer)[data-${normalize(value2)}] ~ &`,
        { values: theme2("data") ?? {} }
      );
    },
    orientationVariants: ({ addVariant }) => {
      addVariant("portrait", "@media (orientation: portrait)");
      addVariant("landscape", "@media (orientation: landscape)");
    },
    prefersContrastVariants: ({ addVariant }) => {
      addVariant("contrast-more", "@media (prefers-contrast: more)");
      addVariant("contrast-less", "@media (prefers-contrast: less)");
    },
    forcedColorsVariants: ({ addVariant }) => {
      addVariant("forced-colors", "@media (forced-colors: active)");
    }
  };
  var cssTransformValue = [
    "translate(var(--tw-translate-x), var(--tw-translate-y))",
    "rotate(var(--tw-rotate))",
    "skewX(var(--tw-skew-x))",
    "skewY(var(--tw-skew-y))",
    "scaleX(var(--tw-scale-x))",
    "scaleY(var(--tw-scale-y))"
  ].join(" ");
  var cssFilterValue = [
    "var(--tw-blur)",
    "var(--tw-brightness)",
    "var(--tw-contrast)",
    "var(--tw-grayscale)",
    "var(--tw-hue-rotate)",
    "var(--tw-invert)",
    "var(--tw-saturate)",
    "var(--tw-sepia)",
    "var(--tw-drop-shadow)"
  ].join(" ");
  var cssBackdropFilterValue = [
    "var(--tw-backdrop-blur)",
    "var(--tw-backdrop-brightness)",
    "var(--tw-backdrop-contrast)",
    "var(--tw-backdrop-grayscale)",
    "var(--tw-backdrop-hue-rotate)",
    "var(--tw-backdrop-invert)",
    "var(--tw-backdrop-opacity)",
    "var(--tw-backdrop-saturate)",
    "var(--tw-backdrop-sepia)"
  ].join(" ");
  var corePlugins = {
    preflight: ({ addBase }) => {
      let preflightStyles = postcss_default.parse(
        fs_default.readFileSync(join("/", "./css/preflight.css"), "utf8")
      );
      addBase([
        postcss_default.comment({
          text: `! tailwindcss v${version} | MIT License | https://tailwindcss.com`
        }),
        ...preflightStyles.nodes
      ]);
    },
    container: /* @__PURE__ */ (() => {
      function extractMinWidths(breakpoints = []) {
        return breakpoints.flatMap((breakpoint) => breakpoint.values.map((breakpoint2) => breakpoint2.min)).filter((v) => v !== void 0);
      }
      function mapMinWidthsToPadding(minWidths, screens, paddings) {
        if (typeof paddings === "undefined") {
          return [];
        }
        if (!(typeof paddings === "object" && paddings !== null)) {
          return [
            {
              screen: "DEFAULT",
              minWidth: 0,
              padding: paddings
            }
          ];
        }
        let mapping = [];
        if (paddings.DEFAULT) {
          mapping.push({
            screen: "DEFAULT",
            minWidth: 0,
            padding: paddings.DEFAULT
          });
        }
        for (let minWidth of minWidths) {
          for (let screen of screens) {
            for (let { min } of screen.values) {
              if (min === minWidth) {
                mapping.push({ minWidth, padding: paddings[screen.name] });
              }
            }
          }
        }
        return mapping;
      }
      return function({ addComponents, theme: theme2 }) {
        let screens = normalizeScreens(theme2("container.screens", theme2("screens")));
        let minWidths = extractMinWidths(screens);
        let paddings = mapMinWidthsToPadding(minWidths, screens, theme2("container.padding"));
        let generatePaddingFor = (minWidth) => {
          let paddingConfig = paddings.find((padding) => padding.minWidth === minWidth);
          if (!paddingConfig) {
            return {};
          }
          return {
            paddingRight: paddingConfig.padding,
            paddingLeft: paddingConfig.padding
          };
        };
        let atRules = Array.from(
          new Set(minWidths.slice().sort((a, z) => parseInt(a) - parseInt(z)))
        ).map((minWidth) => ({
          [`@media (min-width: ${minWidth})`]: {
            ".container": {
              "max-width": minWidth,
              ...generatePaddingFor(minWidth)
            }
          }
        }));
        addComponents([
          {
            ".container": Object.assign(
              { width: "100%" },
              theme2("container.center", false) ? { marginRight: "auto", marginLeft: "auto" } : {},
              generatePaddingFor(0)
            )
          },
          ...atRules
        ]);
      };
    })(),
    accessibility: ({ addUtilities }) => {
      addUtilities({
        ".sr-only": {
          position: "absolute",
          width: "1px",
          height: "1px",
          padding: "0",
          margin: "-1px",
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          borderWidth: "0"
        },
        ".not-sr-only": {
          position: "static",
          width: "auto",
          height: "auto",
          padding: "0",
          margin: "0",
          overflow: "visible",
          clip: "auto",
          whiteSpace: "normal"
        }
      });
    },
    pointerEvents: ({ addUtilities }) => {
      addUtilities({
        ".pointer-events-none": { "pointer-events": "none" },
        ".pointer-events-auto": { "pointer-events": "auto" }
      });
    },
    visibility: ({ addUtilities }) => {
      addUtilities({
        ".visible": { visibility: "visible" },
        ".invisible": { visibility: "hidden" },
        ".collapse": { visibility: "collapse" }
      });
    },
    position: ({ addUtilities }) => {
      addUtilities({
        ".static": { position: "static" },
        ".fixed": { position: "fixed" },
        ".absolute": { position: "absolute" },
        ".relative": { position: "relative" },
        ".sticky": { position: "sticky" }
      });
    },
    inset: createUtilityPlugin(
      "inset",
      [
        ["inset", ["inset"]],
        [
          ["inset-x", ["left", "right"]],
          ["inset-y", ["top", "bottom"]]
        ],
        [
          ["start", ["inset-inline-start"]],
          ["end", ["inset-inline-end"]],
          ["top", ["top"]],
          ["right", ["right"]],
          ["bottom", ["bottom"]],
          ["left", ["left"]]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    isolation: ({ addUtilities }) => {
      addUtilities({
        ".isolate": { isolation: "isolate" },
        ".isolation-auto": { isolation: "auto" }
      });
    },
    zIndex: createUtilityPlugin("zIndex", [["z", ["zIndex"]]], { supportsNegativeValues: true }),
    order: createUtilityPlugin("order", void 0, { supportsNegativeValues: true }),
    gridColumn: createUtilityPlugin("gridColumn", [["col", ["gridColumn"]]]),
    gridColumnStart: createUtilityPlugin("gridColumnStart", [["col-start", ["gridColumnStart"]]]),
    gridColumnEnd: createUtilityPlugin("gridColumnEnd", [["col-end", ["gridColumnEnd"]]]),
    gridRow: createUtilityPlugin("gridRow", [["row", ["gridRow"]]]),
    gridRowStart: createUtilityPlugin("gridRowStart", [["row-start", ["gridRowStart"]]]),
    gridRowEnd: createUtilityPlugin("gridRowEnd", [["row-end", ["gridRowEnd"]]]),
    float: ({ addUtilities }) => {
      addUtilities({
        ".float-start": { float: "inline-start" },
        ".float-end": { float: "inline-end" },
        ".float-right": { float: "right" },
        ".float-left": { float: "left" },
        ".float-none": { float: "none" }
      });
    },
    clear: ({ addUtilities }) => {
      addUtilities({
        ".clear-start": { clear: "inline-start" },
        ".clear-end": { clear: "inline-end" },
        ".clear-left": { clear: "left" },
        ".clear-right": { clear: "right" },
        ".clear-both": { clear: "both" },
        ".clear-none": { clear: "none" }
      });
    },
    margin: createUtilityPlugin(
      "margin",
      [
        ["m", ["margin"]],
        [
          ["mx", ["margin-left", "margin-right"]],
          ["my", ["margin-top", "margin-bottom"]]
        ],
        [
          ["ms", ["margin-inline-start"]],
          ["me", ["margin-inline-end"]],
          ["mt", ["margin-top"]],
          ["mr", ["margin-right"]],
          ["mb", ["margin-bottom"]],
          ["ml", ["margin-left"]]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    boxSizing: ({ addUtilities }) => {
      addUtilities({
        ".box-border": { "box-sizing": "border-box" },
        ".box-content": { "box-sizing": "content-box" }
      });
    },
    lineClamp: ({ matchUtilities, addUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "line-clamp": (value2) => ({
            overflow: "hidden",
            display: "-webkit-box",
            "-webkit-box-orient": "vertical",
            "-webkit-line-clamp": `${value2}`
          })
        },
        { values: theme2("lineClamp") }
      );
      addUtilities({
        ".line-clamp-none": {
          overflow: "visible",
          display: "block",
          "-webkit-box-orient": "horizontal",
          "-webkit-line-clamp": "none"
        }
      });
    },
    display: ({ addUtilities }) => {
      addUtilities({
        ".block": { display: "block" },
        ".inline-block": { display: "inline-block" },
        ".inline": { display: "inline" },
        ".flex": { display: "flex" },
        ".inline-flex": { display: "inline-flex" },
        ".table": { display: "table" },
        ".inline-table": { display: "inline-table" },
        ".table-caption": { display: "table-caption" },
        ".table-cell": { display: "table-cell" },
        ".table-column": { display: "table-column" },
        ".table-column-group": { display: "table-column-group" },
        ".table-footer-group": { display: "table-footer-group" },
        ".table-header-group": { display: "table-header-group" },
        ".table-row-group": { display: "table-row-group" },
        ".table-row": { display: "table-row" },
        ".flow-root": { display: "flow-root" },
        ".grid": { display: "grid" },
        ".inline-grid": { display: "inline-grid" },
        ".contents": { display: "contents" },
        ".list-item": { display: "list-item" },
        ".hidden": { display: "none" }
      });
    },
    aspectRatio: createUtilityPlugin("aspectRatio", [["aspect", ["aspect-ratio"]]]),
    size: createUtilityPlugin("size", [["size", ["width", "height"]]]),
    height: createUtilityPlugin("height", [["h", ["height"]]]),
    maxHeight: createUtilityPlugin("maxHeight", [["max-h", ["maxHeight"]]]),
    minHeight: createUtilityPlugin("minHeight", [["min-h", ["minHeight"]]]),
    width: createUtilityPlugin("width", [["w", ["width"]]]),
    minWidth: createUtilityPlugin("minWidth", [["min-w", ["minWidth"]]]),
    maxWidth: createUtilityPlugin("maxWidth", [["max-w", ["maxWidth"]]]),
    flex: createUtilityPlugin("flex"),
    flexShrink: createUtilityPlugin("flexShrink", [
      ["flex-shrink", ["flex-shrink"]],
      ["shrink", ["flex-shrink"]]
    ]),
    flexGrow: createUtilityPlugin("flexGrow", [
      ["flex-grow", ["flex-grow"]],
      ["grow", ["flex-grow"]]
    ]),
    flexBasis: createUtilityPlugin("flexBasis", [["basis", ["flex-basis"]]]),
    tableLayout: ({ addUtilities }) => {
      addUtilities({
        ".table-auto": { "table-layout": "auto" },
        ".table-fixed": { "table-layout": "fixed" }
      });
    },
    captionSide: ({ addUtilities }) => {
      addUtilities({
        ".caption-top": { "caption-side": "top" },
        ".caption-bottom": { "caption-side": "bottom" }
      });
    },
    borderCollapse: ({ addUtilities }) => {
      addUtilities({
        ".border-collapse": { "border-collapse": "collapse" },
        ".border-separate": { "border-collapse": "separate" }
      });
    },
    borderSpacing: ({ addDefaults, matchUtilities, theme: theme2 }) => {
      addDefaults("border-spacing", {
        "--tw-border-spacing-x": 0,
        "--tw-border-spacing-y": 0
      });
      matchUtilities(
        {
          "border-spacing": (value2) => {
            return {
              "--tw-border-spacing-x": value2,
              "--tw-border-spacing-y": value2,
              "@defaults border-spacing": {},
              "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
            };
          },
          "border-spacing-x": (value2) => {
            return {
              "--tw-border-spacing-x": value2,
              "@defaults border-spacing": {},
              "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
            };
          },
          "border-spacing-y": (value2) => {
            return {
              "--tw-border-spacing-y": value2,
              "@defaults border-spacing": {},
              "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
            };
          }
        },
        { values: theme2("borderSpacing") }
      );
    },
    transformOrigin: createUtilityPlugin("transformOrigin", [["origin", ["transformOrigin"]]]),
    translate: createUtilityPlugin(
      "translate",
      [
        [
          [
            "translate-x",
            [["@defaults transform", {}], "--tw-translate-x", ["transform", cssTransformValue]]
          ],
          [
            "translate-y",
            [["@defaults transform", {}], "--tw-translate-y", ["transform", cssTransformValue]]
          ]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    rotate: createUtilityPlugin(
      "rotate",
      [["rotate", [["@defaults transform", {}], "--tw-rotate", ["transform", cssTransformValue]]]],
      { supportsNegativeValues: true }
    ),
    skew: createUtilityPlugin(
      "skew",
      [
        [
          ["skew-x", [["@defaults transform", {}], "--tw-skew-x", ["transform", cssTransformValue]]],
          ["skew-y", [["@defaults transform", {}], "--tw-skew-y", ["transform", cssTransformValue]]]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    scale: createUtilityPlugin(
      "scale",
      [
        [
          "scale",
          [
            ["@defaults transform", {}],
            "--tw-scale-x",
            "--tw-scale-y",
            ["transform", cssTransformValue]
          ]
        ],
        [
          [
            "scale-x",
            [["@defaults transform", {}], "--tw-scale-x", ["transform", cssTransformValue]]
          ],
          [
            "scale-y",
            [["@defaults transform", {}], "--tw-scale-y", ["transform", cssTransformValue]]
          ]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    transform: ({ addDefaults, addUtilities }) => {
      addDefaults("transform", {
        "--tw-translate-x": "0",
        "--tw-translate-y": "0",
        "--tw-rotate": "0",
        "--tw-skew-x": "0",
        "--tw-skew-y": "0",
        "--tw-scale-x": "1",
        "--tw-scale-y": "1"
      });
      addUtilities({
        ".transform": { "@defaults transform": {}, transform: cssTransformValue },
        ".transform-cpu": {
          transform: cssTransformValue
        },
        ".transform-gpu": {
          transform: cssTransformValue.replace(
            "translate(var(--tw-translate-x), var(--tw-translate-y))",
            "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)"
          )
        },
        ".transform-none": { transform: "none" }
      });
    },
    animation: ({ matchUtilities, theme: theme2, config: config5 }) => {
      let prefixName = (name) => escapeClassName(config5("prefix") + name);
      let keyframes = Object.fromEntries(
        Object.entries(theme2("keyframes") ?? {}).map(([key, value2]) => {
          return [key, { [`@keyframes ${prefixName(key)}`]: value2 }];
        })
      );
      matchUtilities(
        {
          animate: (value2) => {
            let animations = parseAnimationValue(value2);
            return [
              ...animations.flatMap((animation2) => keyframes[animation2.name]),
              {
                animation: animations.map(({ name, value: value3 }) => {
                  if (name === void 0 || keyframes[name] === void 0) {
                    return value3;
                  }
                  return value3.replace(name, prefixName(name));
                }).join(", ")
              }
            ];
          }
        },
        { values: theme2("animation") }
      );
    },
    cursor: createUtilityPlugin("cursor"),
    touchAction: ({ addDefaults, addUtilities }) => {
      addDefaults("touch-action", {
        "--tw-pan-x": " ",
        "--tw-pan-y": " ",
        "--tw-pinch-zoom": " "
      });
      let cssTouchActionValue = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
      addUtilities({
        ".touch-auto": { "touch-action": "auto" },
        ".touch-none": { "touch-action": "none" },
        ".touch-pan-x": {
          "@defaults touch-action": {},
          "--tw-pan-x": "pan-x",
          "touch-action": cssTouchActionValue
        },
        ".touch-pan-left": {
          "@defaults touch-action": {},
          "--tw-pan-x": "pan-left",
          "touch-action": cssTouchActionValue
        },
        ".touch-pan-right": {
          "@defaults touch-action": {},
          "--tw-pan-x": "pan-right",
          "touch-action": cssTouchActionValue
        },
        ".touch-pan-y": {
          "@defaults touch-action": {},
          "--tw-pan-y": "pan-y",
          "touch-action": cssTouchActionValue
        },
        ".touch-pan-up": {
          "@defaults touch-action": {},
          "--tw-pan-y": "pan-up",
          "touch-action": cssTouchActionValue
        },
        ".touch-pan-down": {
          "@defaults touch-action": {},
          "--tw-pan-y": "pan-down",
          "touch-action": cssTouchActionValue
        },
        ".touch-pinch-zoom": {
          "@defaults touch-action": {},
          "--tw-pinch-zoom": "pinch-zoom",
          "touch-action": cssTouchActionValue
        },
        ".touch-manipulation": { "touch-action": "manipulation" }
      });
    },
    userSelect: ({ addUtilities }) => {
      addUtilities({
        ".select-none": { "user-select": "none" },
        ".select-text": { "user-select": "text" },
        ".select-all": { "user-select": "all" },
        ".select-auto": { "user-select": "auto" }
      });
    },
    resize: ({ addUtilities }) => {
      addUtilities({
        ".resize-none": { resize: "none" },
        ".resize-y": { resize: "vertical" },
        ".resize-x": { resize: "horizontal" },
        ".resize": { resize: "both" }
      });
    },
    scrollSnapType: ({ addDefaults, addUtilities }) => {
      addDefaults("scroll-snap-type", {
        "--tw-scroll-snap-strictness": "proximity"
      });
      addUtilities({
        ".snap-none": { "scroll-snap-type": "none" },
        ".snap-x": {
          "@defaults scroll-snap-type": {},
          "scroll-snap-type": "x var(--tw-scroll-snap-strictness)"
        },
        ".snap-y": {
          "@defaults scroll-snap-type": {},
          "scroll-snap-type": "y var(--tw-scroll-snap-strictness)"
        },
        ".snap-both": {
          "@defaults scroll-snap-type": {},
          "scroll-snap-type": "both var(--tw-scroll-snap-strictness)"
        },
        ".snap-mandatory": { "--tw-scroll-snap-strictness": "mandatory" },
        ".snap-proximity": { "--tw-scroll-snap-strictness": "proximity" }
      });
    },
    scrollSnapAlign: ({ addUtilities }) => {
      addUtilities({
        ".snap-start": { "scroll-snap-align": "start" },
        ".snap-end": { "scroll-snap-align": "end" },
        ".snap-center": { "scroll-snap-align": "center" },
        ".snap-align-none": { "scroll-snap-align": "none" }
      });
    },
    scrollSnapStop: ({ addUtilities }) => {
      addUtilities({
        ".snap-normal": { "scroll-snap-stop": "normal" },
        ".snap-always": { "scroll-snap-stop": "always" }
      });
    },
    scrollMargin: createUtilityPlugin(
      "scrollMargin",
      [
        ["scroll-m", ["scroll-margin"]],
        [
          ["scroll-mx", ["scroll-margin-left", "scroll-margin-right"]],
          ["scroll-my", ["scroll-margin-top", "scroll-margin-bottom"]]
        ],
        [
          ["scroll-ms", ["scroll-margin-inline-start"]],
          ["scroll-me", ["scroll-margin-inline-end"]],
          ["scroll-mt", ["scroll-margin-top"]],
          ["scroll-mr", ["scroll-margin-right"]],
          ["scroll-mb", ["scroll-margin-bottom"]],
          ["scroll-ml", ["scroll-margin-left"]]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    scrollPadding: createUtilityPlugin("scrollPadding", [
      ["scroll-p", ["scroll-padding"]],
      [
        ["scroll-px", ["scroll-padding-left", "scroll-padding-right"]],
        ["scroll-py", ["scroll-padding-top", "scroll-padding-bottom"]]
      ],
      [
        ["scroll-ps", ["scroll-padding-inline-start"]],
        ["scroll-pe", ["scroll-padding-inline-end"]],
        ["scroll-pt", ["scroll-padding-top"]],
        ["scroll-pr", ["scroll-padding-right"]],
        ["scroll-pb", ["scroll-padding-bottom"]],
        ["scroll-pl", ["scroll-padding-left"]]
      ]
    ]),
    listStylePosition: ({ addUtilities }) => {
      addUtilities({
        ".list-inside": { "list-style-position": "inside" },
        ".list-outside": { "list-style-position": "outside" }
      });
    },
    listStyleType: createUtilityPlugin("listStyleType", [["list", ["listStyleType"]]]),
    listStyleImage: createUtilityPlugin("listStyleImage", [["list-image", ["listStyleImage"]]]),
    appearance: ({ addUtilities }) => {
      addUtilities({
        ".appearance-none": { appearance: "none" },
        ".appearance-auto": { appearance: "auto" }
      });
    },
    columns: createUtilityPlugin("columns", [["columns", ["columns"]]]),
    breakBefore: ({ addUtilities }) => {
      addUtilities({
        ".break-before-auto": { "break-before": "auto" },
        ".break-before-avoid": { "break-before": "avoid" },
        ".break-before-all": { "break-before": "all" },
        ".break-before-avoid-page": { "break-before": "avoid-page" },
        ".break-before-page": { "break-before": "page" },
        ".break-before-left": { "break-before": "left" },
        ".break-before-right": { "break-before": "right" },
        ".break-before-column": { "break-before": "column" }
      });
    },
    breakInside: ({ addUtilities }) => {
      addUtilities({
        ".break-inside-auto": { "break-inside": "auto" },
        ".break-inside-avoid": { "break-inside": "avoid" },
        ".break-inside-avoid-page": { "break-inside": "avoid-page" },
        ".break-inside-avoid-column": { "break-inside": "avoid-column" }
      });
    },
    breakAfter: ({ addUtilities }) => {
      addUtilities({
        ".break-after-auto": { "break-after": "auto" },
        ".break-after-avoid": { "break-after": "avoid" },
        ".break-after-all": { "break-after": "all" },
        ".break-after-avoid-page": { "break-after": "avoid-page" },
        ".break-after-page": { "break-after": "page" },
        ".break-after-left": { "break-after": "left" },
        ".break-after-right": { "break-after": "right" },
        ".break-after-column": { "break-after": "column" }
      });
    },
    gridAutoColumns: createUtilityPlugin("gridAutoColumns", [["auto-cols", ["gridAutoColumns"]]]),
    gridAutoFlow: ({ addUtilities }) => {
      addUtilities({
        ".grid-flow-row": { gridAutoFlow: "row" },
        ".grid-flow-col": { gridAutoFlow: "column" },
        ".grid-flow-dense": { gridAutoFlow: "dense" },
        ".grid-flow-row-dense": { gridAutoFlow: "row dense" },
        ".grid-flow-col-dense": { gridAutoFlow: "column dense" }
      });
    },
    gridAutoRows: createUtilityPlugin("gridAutoRows", [["auto-rows", ["gridAutoRows"]]]),
    gridTemplateColumns: createUtilityPlugin("gridTemplateColumns", [
      ["grid-cols", ["gridTemplateColumns"]]
    ]),
    gridTemplateRows: createUtilityPlugin("gridTemplateRows", [["grid-rows", ["gridTemplateRows"]]]),
    flexDirection: ({ addUtilities }) => {
      addUtilities({
        ".flex-row": { "flex-direction": "row" },
        ".flex-row-reverse": { "flex-direction": "row-reverse" },
        ".flex-col": { "flex-direction": "column" },
        ".flex-col-reverse": { "flex-direction": "column-reverse" }
      });
    },
    flexWrap: ({ addUtilities }) => {
      addUtilities({
        ".flex-wrap": { "flex-wrap": "wrap" },
        ".flex-wrap-reverse": { "flex-wrap": "wrap-reverse" },
        ".flex-nowrap": { "flex-wrap": "nowrap" }
      });
    },
    placeContent: ({ addUtilities }) => {
      addUtilities({
        ".place-content-center": { "place-content": "center" },
        ".place-content-start": { "place-content": "start" },
        ".place-content-end": { "place-content": "end" },
        ".place-content-between": { "place-content": "space-between" },
        ".place-content-around": { "place-content": "space-around" },
        ".place-content-evenly": { "place-content": "space-evenly" },
        ".place-content-baseline": { "place-content": "baseline" },
        ".place-content-stretch": { "place-content": "stretch" }
      });
    },
    placeItems: ({ addUtilities }) => {
      addUtilities({
        ".place-items-start": { "place-items": "start" },
        ".place-items-end": { "place-items": "end" },
        ".place-items-center": { "place-items": "center" },
        ".place-items-baseline": { "place-items": "baseline" },
        ".place-items-stretch": { "place-items": "stretch" }
      });
    },
    alignContent: ({ addUtilities }) => {
      addUtilities({
        ".content-normal": { "align-content": "normal" },
        ".content-center": { "align-content": "center" },
        ".content-start": { "align-content": "flex-start" },
        ".content-end": { "align-content": "flex-end" },
        ".content-between": { "align-content": "space-between" },
        ".content-around": { "align-content": "space-around" },
        ".content-evenly": { "align-content": "space-evenly" },
        ".content-baseline": { "align-content": "baseline" },
        ".content-stretch": { "align-content": "stretch" }
      });
    },
    alignItems: ({ addUtilities }) => {
      addUtilities({
        ".items-start": { "align-items": "flex-start" },
        ".items-end": { "align-items": "flex-end" },
        ".items-center": { "align-items": "center" },
        ".items-baseline": { "align-items": "baseline" },
        ".items-stretch": { "align-items": "stretch" }
      });
    },
    justifyContent: ({ addUtilities }) => {
      addUtilities({
        ".justify-normal": { "justify-content": "normal" },
        ".justify-start": { "justify-content": "flex-start" },
        ".justify-end": { "justify-content": "flex-end" },
        ".justify-center": { "justify-content": "center" },
        ".justify-between": { "justify-content": "space-between" },
        ".justify-around": { "justify-content": "space-around" },
        ".justify-evenly": { "justify-content": "space-evenly" },
        ".justify-stretch": { "justify-content": "stretch" }
      });
    },
    justifyItems: ({ addUtilities }) => {
      addUtilities({
        ".justify-items-start": { "justify-items": "start" },
        ".justify-items-end": { "justify-items": "end" },
        ".justify-items-center": { "justify-items": "center" },
        ".justify-items-stretch": { "justify-items": "stretch" }
      });
    },
    gap: createUtilityPlugin("gap", [
      ["gap", ["gap"]],
      [
        ["gap-x", ["columnGap"]],
        ["gap-y", ["rowGap"]]
      ]
    ]),
    space: ({ matchUtilities, addUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "space-x": (value2) => {
            value2 = value2 === "0" ? "0px" : value2;
            if (false) {
              return {
                "& > :not([hidden]) ~ :not([hidden])": {
                  "--tw-space-x-reverse": "0",
                  "margin-inline-end": `calc(${value2} * var(--tw-space-x-reverse))`,
                  "margin-inline-start": `calc(${value2} * calc(1 - var(--tw-space-x-reverse)))`
                }
              };
            }
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "--tw-space-x-reverse": "0",
                "margin-right": `calc(${value2} * var(--tw-space-x-reverse))`,
                "margin-left": `calc(${value2} * calc(1 - var(--tw-space-x-reverse)))`
              }
            };
          },
          "space-y": (value2) => {
            value2 = value2 === "0" ? "0px" : value2;
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "--tw-space-y-reverse": "0",
                "margin-top": `calc(${value2} * calc(1 - var(--tw-space-y-reverse)))`,
                "margin-bottom": `calc(${value2} * var(--tw-space-y-reverse))`
              }
            };
          }
        },
        { values: theme2("space"), supportsNegativeValues: true }
      );
      addUtilities({
        ".space-y-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "1" },
        ".space-x-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "1" }
      });
    },
    divideWidth: ({ matchUtilities, addUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "divide-x": (value2) => {
            value2 = value2 === "0" ? "0px" : value2;
            if (false) {
              return {
                "& > :not([hidden]) ~ :not([hidden])": {
                  "@defaults border-width": {},
                  "--tw-divide-x-reverse": "0",
                  "border-inline-end-width": `calc(${value2} * var(--tw-divide-x-reverse))`,
                  "border-inline-start-width": `calc(${value2} * calc(1 - var(--tw-divide-x-reverse)))`
                }
              };
            }
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "@defaults border-width": {},
                "--tw-divide-x-reverse": "0",
                "border-right-width": `calc(${value2} * var(--tw-divide-x-reverse))`,
                "border-left-width": `calc(${value2} * calc(1 - var(--tw-divide-x-reverse)))`
              }
            };
          },
          "divide-y": (value2) => {
            value2 = value2 === "0" ? "0px" : value2;
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "@defaults border-width": {},
                "--tw-divide-y-reverse": "0",
                "border-top-width": `calc(${value2} * calc(1 - var(--tw-divide-y-reverse)))`,
                "border-bottom-width": `calc(${value2} * var(--tw-divide-y-reverse))`
              }
            };
          }
        },
        { values: theme2("divideWidth"), type: ["line-width", "length", "any"] }
      );
      addUtilities({
        ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": {
          "@defaults border-width": {},
          "--tw-divide-y-reverse": "1"
        },
        ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": {
          "@defaults border-width": {},
          "--tw-divide-x-reverse": "1"
        }
      });
    },
    divideStyle: ({ addUtilities }) => {
      addUtilities({
        ".divide-solid > :not([hidden]) ~ :not([hidden])": { "border-style": "solid" },
        ".divide-dashed > :not([hidden]) ~ :not([hidden])": { "border-style": "dashed" },
        ".divide-dotted > :not([hidden]) ~ :not([hidden])": { "border-style": "dotted" },
        ".divide-double > :not([hidden]) ~ :not([hidden])": { "border-style": "double" },
        ".divide-none > :not([hidden]) ~ :not([hidden])": { "border-style": "none" }
      });
    },
    divideColor: ({ matchUtilities, theme: theme2, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          divide: (value2) => {
            if (!corePlugins2("divideOpacity")) {
              return {
                ["& > :not([hidden]) ~ :not([hidden])"]: {
                  "border-color": toColorValue(value2)
                }
              };
            }
            return {
              ["& > :not([hidden]) ~ :not([hidden])"]: withAlphaVariable({
                color: value2,
                property: "border-color",
                variable: "--tw-divide-opacity"
              })
            };
          }
        },
        {
          values: (({ DEFAULT: _, ...colors2 }) => colors2)(flattenColorPalette_default(theme2("divideColor"))),
          type: ["color", "any"]
        }
      );
    },
    divideOpacity: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "divide-opacity": (value2) => {
            return { [`& > :not([hidden]) ~ :not([hidden])`]: { "--tw-divide-opacity": value2 } };
          }
        },
        { values: theme2("divideOpacity") }
      );
    },
    placeSelf: ({ addUtilities }) => {
      addUtilities({
        ".place-self-auto": { "place-self": "auto" },
        ".place-self-start": { "place-self": "start" },
        ".place-self-end": { "place-self": "end" },
        ".place-self-center": { "place-self": "center" },
        ".place-self-stretch": { "place-self": "stretch" }
      });
    },
    alignSelf: ({ addUtilities }) => {
      addUtilities({
        ".self-auto": { "align-self": "auto" },
        ".self-start": { "align-self": "flex-start" },
        ".self-end": { "align-self": "flex-end" },
        ".self-center": { "align-self": "center" },
        ".self-stretch": { "align-self": "stretch" },
        ".self-baseline": { "align-self": "baseline" }
      });
    },
    justifySelf: ({ addUtilities }) => {
      addUtilities({
        ".justify-self-auto": { "justify-self": "auto" },
        ".justify-self-start": { "justify-self": "start" },
        ".justify-self-end": { "justify-self": "end" },
        ".justify-self-center": { "justify-self": "center" },
        ".justify-self-stretch": { "justify-self": "stretch" }
      });
    },
    overflow: ({ addUtilities }) => {
      addUtilities({
        ".overflow-auto": { overflow: "auto" },
        ".overflow-hidden": { overflow: "hidden" },
        ".overflow-clip": { overflow: "clip" },
        ".overflow-visible": { overflow: "visible" },
        ".overflow-scroll": { overflow: "scroll" },
        ".overflow-x-auto": { "overflow-x": "auto" },
        ".overflow-y-auto": { "overflow-y": "auto" },
        ".overflow-x-hidden": { "overflow-x": "hidden" },
        ".overflow-y-hidden": { "overflow-y": "hidden" },
        ".overflow-x-clip": { "overflow-x": "clip" },
        ".overflow-y-clip": { "overflow-y": "clip" },
        ".overflow-x-visible": { "overflow-x": "visible" },
        ".overflow-y-visible": { "overflow-y": "visible" },
        ".overflow-x-scroll": { "overflow-x": "scroll" },
        ".overflow-y-scroll": { "overflow-y": "scroll" }
      });
    },
    overscrollBehavior: ({ addUtilities }) => {
      addUtilities({
        ".overscroll-auto": { "overscroll-behavior": "auto" },
        ".overscroll-contain": { "overscroll-behavior": "contain" },
        ".overscroll-none": { "overscroll-behavior": "none" },
        ".overscroll-y-auto": { "overscroll-behavior-y": "auto" },
        ".overscroll-y-contain": { "overscroll-behavior-y": "contain" },
        ".overscroll-y-none": { "overscroll-behavior-y": "none" },
        ".overscroll-x-auto": { "overscroll-behavior-x": "auto" },
        ".overscroll-x-contain": { "overscroll-behavior-x": "contain" },
        ".overscroll-x-none": { "overscroll-behavior-x": "none" }
      });
    },
    scrollBehavior: ({ addUtilities }) => {
      addUtilities({
        ".scroll-auto": { "scroll-behavior": "auto" },
        ".scroll-smooth": { "scroll-behavior": "smooth" }
      });
    },
    textOverflow: ({ addUtilities }) => {
      addUtilities({
        ".truncate": { overflow: "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" },
        ".overflow-ellipsis": { "text-overflow": "ellipsis" },
        ".text-ellipsis": { "text-overflow": "ellipsis" },
        ".text-clip": { "text-overflow": "clip" }
      });
    },
    hyphens: ({ addUtilities }) => {
      addUtilities({
        ".hyphens-none": { hyphens: "none" },
        ".hyphens-manual": { hyphens: "manual" },
        ".hyphens-auto": { hyphens: "auto" }
      });
    },
    whitespace: ({ addUtilities }) => {
      addUtilities({
        ".whitespace-normal": { "white-space": "normal" },
        ".whitespace-nowrap": { "white-space": "nowrap" },
        ".whitespace-pre": { "white-space": "pre" },
        ".whitespace-pre-line": { "white-space": "pre-line" },
        ".whitespace-pre-wrap": { "white-space": "pre-wrap" },
        ".whitespace-break-spaces": { "white-space": "break-spaces" }
      });
    },
    textWrap: ({ addUtilities }) => {
      addUtilities({
        ".text-wrap": { "text-wrap": "wrap" },
        ".text-nowrap": { "text-wrap": "nowrap" },
        ".text-balance": { "text-wrap": "balance" },
        ".text-pretty": { "text-wrap": "pretty" }
      });
    },
    wordBreak: ({ addUtilities }) => {
      addUtilities({
        ".break-normal": { "overflow-wrap": "normal", "word-break": "normal" },
        ".break-words": { "overflow-wrap": "break-word" },
        ".break-all": { "word-break": "break-all" },
        ".break-keep": { "word-break": "keep-all" }
      });
    },
    borderRadius: createUtilityPlugin("borderRadius", [
      ["rounded", ["border-radius"]],
      [
        ["rounded-s", ["border-start-start-radius", "border-end-start-radius"]],
        ["rounded-e", ["border-start-end-radius", "border-end-end-radius"]],
        ["rounded-t", ["border-top-left-radius", "border-top-right-radius"]],
        ["rounded-r", ["border-top-right-radius", "border-bottom-right-radius"]],
        ["rounded-b", ["border-bottom-right-radius", "border-bottom-left-radius"]],
        ["rounded-l", ["border-top-left-radius", "border-bottom-left-radius"]]
      ],
      [
        ["rounded-ss", ["border-start-start-radius"]],
        ["rounded-se", ["border-start-end-radius"]],
        ["rounded-ee", ["border-end-end-radius"]],
        ["rounded-es", ["border-end-start-radius"]],
        ["rounded-tl", ["border-top-left-radius"]],
        ["rounded-tr", ["border-top-right-radius"]],
        ["rounded-br", ["border-bottom-right-radius"]],
        ["rounded-bl", ["border-bottom-left-radius"]]
      ]
    ]),
    borderWidth: createUtilityPlugin(
      "borderWidth",
      [
        ["border", [["@defaults border-width", {}], "border-width"]],
        [
          ["border-x", [["@defaults border-width", {}], "border-left-width", "border-right-width"]],
          ["border-y", [["@defaults border-width", {}], "border-top-width", "border-bottom-width"]]
        ],
        [
          ["border-s", [["@defaults border-width", {}], "border-inline-start-width"]],
          ["border-e", [["@defaults border-width", {}], "border-inline-end-width"]],
          ["border-t", [["@defaults border-width", {}], "border-top-width"]],
          ["border-r", [["@defaults border-width", {}], "border-right-width"]],
          ["border-b", [["@defaults border-width", {}], "border-bottom-width"]],
          ["border-l", [["@defaults border-width", {}], "border-left-width"]]
        ]
      ],
      { type: ["line-width", "length"] }
    ),
    borderStyle: ({ addUtilities }) => {
      addUtilities({
        ".border-solid": { "border-style": "solid" },
        ".border-dashed": { "border-style": "dashed" },
        ".border-dotted": { "border-style": "dotted" },
        ".border-double": { "border-style": "double" },
        ".border-hidden": { "border-style": "hidden" },
        ".border-none": { "border-style": "none" }
      });
    },
    borderColor: ({ matchUtilities, theme: theme2, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          border: (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-color",
              variable: "--tw-border-opacity"
            });
          }
        },
        {
          values: (({ DEFAULT: _, ...colors2 }) => colors2)(flattenColorPalette_default(theme2("borderColor"))),
          type: ["color", "any"]
        }
      );
      matchUtilities(
        {
          "border-x": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-left-color": toColorValue(value2),
                "border-right-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: ["border-left-color", "border-right-color"],
              variable: "--tw-border-opacity"
            });
          },
          "border-y": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-top-color": toColorValue(value2),
                "border-bottom-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: ["border-top-color", "border-bottom-color"],
              variable: "--tw-border-opacity"
            });
          }
        },
        {
          values: (({ DEFAULT: _, ...colors2 }) => colors2)(flattenColorPalette_default(theme2("borderColor"))),
          type: ["color", "any"]
        }
      );
      matchUtilities(
        {
          "border-s": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-inline-start-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-inline-start-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-e": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-inline-end-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-inline-end-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-t": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-top-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-top-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-r": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-right-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-right-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-b": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-bottom-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-bottom-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-l": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-left-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-left-color",
              variable: "--tw-border-opacity"
            });
          }
        },
        {
          values: (({ DEFAULT: _, ...colors2 }) => colors2)(flattenColorPalette_default(theme2("borderColor"))),
          type: ["color", "any"]
        }
      );
    },
    borderOpacity: createUtilityPlugin("borderOpacity", [
      ["border-opacity", ["--tw-border-opacity"]]
    ]),
    backgroundColor: ({ matchUtilities, theme: theme2, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          bg: (value2) => {
            if (!corePlugins2("backgroundOpacity")) {
              return {
                "background-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "background-color",
              variable: "--tw-bg-opacity"
            });
          }
        },
        { values: flattenColorPalette_default(theme2("backgroundColor")), type: ["color", "any"] }
      );
    },
    backgroundOpacity: createUtilityPlugin("backgroundOpacity", [
      ["bg-opacity", ["--tw-bg-opacity"]]
    ]),
    backgroundImage: createUtilityPlugin("backgroundImage", [["bg", ["background-image"]]], {
      type: ["lookup", "image", "url"]
    }),
    gradientColorStops: /* @__PURE__ */ (() => {
      function transparentTo(value2) {
        return withAlphaValue(value2, 0, "rgb(255 255 255 / 0)");
      }
      return function({ matchUtilities, theme: theme2, addDefaults }) {
        addDefaults("gradient-color-stops", {
          "--tw-gradient-from-position": " ",
          "--tw-gradient-via-position": " ",
          "--tw-gradient-to-position": " "
        });
        let options = {
          values: flattenColorPalette_default(theme2("gradientColorStops")),
          type: ["color", "any"]
        };
        let positionOptions = {
          values: theme2("gradientColorStopPositions"),
          type: ["length", "percentage"]
        };
        matchUtilities(
          {
            from: (value2) => {
              let transparentToValue = transparentTo(value2);
              return {
                "@defaults gradient-color-stops": {},
                "--tw-gradient-from": `${toColorValue(value2)} var(--tw-gradient-from-position)`,
                "--tw-gradient-to": `${transparentToValue} var(--tw-gradient-to-position)`,
                "--tw-gradient-stops": `var(--tw-gradient-from), var(--tw-gradient-to)`
              };
            }
          },
          options
        );
        matchUtilities(
          {
            from: (value2) => {
              return {
                "--tw-gradient-from-position": value2
              };
            }
          },
          positionOptions
        );
        matchUtilities(
          {
            via: (value2) => {
              let transparentToValue = transparentTo(value2);
              return {
                "@defaults gradient-color-stops": {},
                "--tw-gradient-to": `${transparentToValue}  var(--tw-gradient-to-position)`,
                "--tw-gradient-stops": `var(--tw-gradient-from), ${toColorValue(
                  value2
                )} var(--tw-gradient-via-position), var(--tw-gradient-to)`
              };
            }
          },
          options
        );
        matchUtilities(
          {
            via: (value2) => {
              return {
                "--tw-gradient-via-position": value2
              };
            }
          },
          positionOptions
        );
        matchUtilities(
          {
            to: (value2) => ({
              "@defaults gradient-color-stops": {},
              "--tw-gradient-to": `${toColorValue(value2)} var(--tw-gradient-to-position)`
            })
          },
          options
        );
        matchUtilities(
          {
            to: (value2) => {
              return {
                "--tw-gradient-to-position": value2
              };
            }
          },
          positionOptions
        );
      };
    })(),
    boxDecorationBreak: ({ addUtilities }) => {
      addUtilities({
        ".decoration-slice": { "box-decoration-break": "slice" },
        ".decoration-clone": { "box-decoration-break": "clone" },
        ".box-decoration-slice": { "box-decoration-break": "slice" },
        ".box-decoration-clone": { "box-decoration-break": "clone" }
      });
    },
    backgroundSize: createUtilityPlugin("backgroundSize", [["bg", ["background-size"]]], {
      type: ["lookup", "length", "percentage", "size"]
    }),
    backgroundAttachment: ({ addUtilities }) => {
      addUtilities({
        ".bg-fixed": { "background-attachment": "fixed" },
        ".bg-local": { "background-attachment": "local" },
        ".bg-scroll": { "background-attachment": "scroll" }
      });
    },
    backgroundClip: ({ addUtilities }) => {
      addUtilities({
        ".bg-clip-border": { "background-clip": "border-box" },
        ".bg-clip-padding": { "background-clip": "padding-box" },
        ".bg-clip-content": { "background-clip": "content-box" },
        ".bg-clip-text": { "background-clip": "text" }
      });
    },
    backgroundPosition: createUtilityPlugin("backgroundPosition", [["bg", ["background-position"]]], {
      type: ["lookup", ["position", { preferOnConflict: true }]]
    }),
    backgroundRepeat: ({ addUtilities }) => {
      addUtilities({
        ".bg-repeat": { "background-repeat": "repeat" },
        ".bg-no-repeat": { "background-repeat": "no-repeat" },
        ".bg-repeat-x": { "background-repeat": "repeat-x" },
        ".bg-repeat-y": { "background-repeat": "repeat-y" },
        ".bg-repeat-round": { "background-repeat": "round" },
        ".bg-repeat-space": { "background-repeat": "space" }
      });
    },
    backgroundOrigin: ({ addUtilities }) => {
      addUtilities({
        ".bg-origin-border": { "background-origin": "border-box" },
        ".bg-origin-padding": { "background-origin": "padding-box" },
        ".bg-origin-content": { "background-origin": "content-box" }
      });
    },
    fill: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          fill: (value2) => {
            return { fill: toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme2("fill")), type: ["color", "any"] }
      );
    },
    stroke: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          stroke: (value2) => {
            return { stroke: toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme2("stroke")), type: ["color", "url", "any"] }
      );
    },
    strokeWidth: createUtilityPlugin("strokeWidth", [["stroke", ["stroke-width"]]], {
      type: ["length", "number", "percentage"]
    }),
    objectFit: ({ addUtilities }) => {
      addUtilities({
        ".object-contain": { "object-fit": "contain" },
        ".object-cover": { "object-fit": "cover" },
        ".object-fill": { "object-fit": "fill" },
        ".object-none": { "object-fit": "none" },
        ".object-scale-down": { "object-fit": "scale-down" }
      });
    },
    objectPosition: createUtilityPlugin("objectPosition", [["object", ["object-position"]]]),
    padding: createUtilityPlugin("padding", [
      ["p", ["padding"]],
      [
        ["px", ["padding-left", "padding-right"]],
        ["py", ["padding-top", "padding-bottom"]]
      ],
      [
        ["ps", ["padding-inline-start"]],
        ["pe", ["padding-inline-end"]],
        ["pt", ["padding-top"]],
        ["pr", ["padding-right"]],
        ["pb", ["padding-bottom"]],
        ["pl", ["padding-left"]]
      ]
    ]),
    textAlign: ({ addUtilities }) => {
      addUtilities({
        ".text-left": { "text-align": "left" },
        ".text-center": { "text-align": "center" },
        ".text-right": { "text-align": "right" },
        ".text-justify": { "text-align": "justify" },
        ".text-start": { "text-align": "start" },
        ".text-end": { "text-align": "end" }
      });
    },
    textIndent: createUtilityPlugin("textIndent", [["indent", ["text-indent"]]], {
      supportsNegativeValues: true
    }),
    verticalAlign: ({ addUtilities, matchUtilities }) => {
      addUtilities({
        ".align-baseline": { "vertical-align": "baseline" },
        ".align-top": { "vertical-align": "top" },
        ".align-middle": { "vertical-align": "middle" },
        ".align-bottom": { "vertical-align": "bottom" },
        ".align-text-top": { "vertical-align": "text-top" },
        ".align-text-bottom": { "vertical-align": "text-bottom" },
        ".align-sub": { "vertical-align": "sub" },
        ".align-super": { "vertical-align": "super" }
      });
      matchUtilities({ align: (value2) => ({ "vertical-align": value2 }) });
    },
    fontFamily: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          font: (value2) => {
            let [families, options = {}] = Array.isArray(value2) && isPlainObject(value2[1]) ? value2 : [value2];
            let { fontFeatureSettings, fontVariationSettings } = options;
            return {
              "font-family": Array.isArray(families) ? families.join(", ") : families,
              ...fontFeatureSettings === void 0 ? {} : { "font-feature-settings": fontFeatureSettings },
              ...fontVariationSettings === void 0 ? {} : { "font-variation-settings": fontVariationSettings }
            };
          }
        },
        {
          values: theme2("fontFamily"),
          type: ["lookup", "generic-name", "family-name"]
        }
      );
    },
    fontSize: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          text: (value2, { modifier }) => {
            let [fontSize, options] = Array.isArray(value2) ? value2 : [value2];
            if (modifier) {
              return {
                "font-size": fontSize,
                "line-height": modifier
              };
            }
            let { lineHeight, letterSpacing, fontWeight } = isPlainObject(options) ? options : { lineHeight: options };
            return {
              "font-size": fontSize,
              ...lineHeight === void 0 ? {} : { "line-height": lineHeight },
              ...letterSpacing === void 0 ? {} : { "letter-spacing": letterSpacing },
              ...fontWeight === void 0 ? {} : { "font-weight": fontWeight }
            };
          }
        },
        {
          values: theme2("fontSize"),
          modifiers: theme2("lineHeight"),
          type: ["absolute-size", "relative-size", "length", "percentage"]
        }
      );
    },
    fontWeight: createUtilityPlugin("fontWeight", [["font", ["fontWeight"]]], {
      type: ["lookup", "number", "any"]
    }),
    textTransform: ({ addUtilities }) => {
      addUtilities({
        ".uppercase": { "text-transform": "uppercase" },
        ".lowercase": { "text-transform": "lowercase" },
        ".capitalize": { "text-transform": "capitalize" },
        ".normal-case": { "text-transform": "none" }
      });
    },
    fontStyle: ({ addUtilities }) => {
      addUtilities({
        ".italic": { "font-style": "italic" },
        ".not-italic": { "font-style": "normal" }
      });
    },
    fontVariantNumeric: ({ addDefaults, addUtilities }) => {
      let cssFontVariantNumericValue = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
      addDefaults("font-variant-numeric", {
        "--tw-ordinal": " ",
        "--tw-slashed-zero": " ",
        "--tw-numeric-figure": " ",
        "--tw-numeric-spacing": " ",
        "--tw-numeric-fraction": " "
      });
      addUtilities({
        ".normal-nums": { "font-variant-numeric": "normal" },
        ".ordinal": {
          "@defaults font-variant-numeric": {},
          "--tw-ordinal": "ordinal",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".slashed-zero": {
          "@defaults font-variant-numeric": {},
          "--tw-slashed-zero": "slashed-zero",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".lining-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-figure": "lining-nums",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".oldstyle-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-figure": "oldstyle-nums",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".proportional-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-spacing": "proportional-nums",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".tabular-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-spacing": "tabular-nums",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".diagonal-fractions": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-fraction": "diagonal-fractions",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".stacked-fractions": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-fraction": "stacked-fractions",
          "font-variant-numeric": cssFontVariantNumericValue
        }
      });
    },
    lineHeight: createUtilityPlugin("lineHeight", [["leading", ["lineHeight"]]]),
    letterSpacing: createUtilityPlugin("letterSpacing", [["tracking", ["letterSpacing"]]], {
      supportsNegativeValues: true
    }),
    textColor: ({ matchUtilities, theme: theme2, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          text: (value2) => {
            if (!corePlugins2("textOpacity")) {
              return { color: toColorValue(value2) };
            }
            return withAlphaVariable({
              color: value2,
              property: "color",
              variable: "--tw-text-opacity"
            });
          }
        },
        { values: flattenColorPalette_default(theme2("textColor")), type: ["color", "any"] }
      );
    },
    textOpacity: createUtilityPlugin("textOpacity", [["text-opacity", ["--tw-text-opacity"]]]),
    textDecoration: ({ addUtilities }) => {
      addUtilities({
        ".underline": { "text-decoration-line": "underline" },
        ".overline": { "text-decoration-line": "overline" },
        ".line-through": { "text-decoration-line": "line-through" },
        ".no-underline": { "text-decoration-line": "none" }
      });
    },
    textDecorationColor: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          decoration: (value2) => {
            return { "text-decoration-color": toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme2("textDecorationColor")), type: ["color", "any"] }
      );
    },
    textDecorationStyle: ({ addUtilities }) => {
      addUtilities({
        ".decoration-solid": { "text-decoration-style": "solid" },
        ".decoration-double": { "text-decoration-style": "double" },
        ".decoration-dotted": { "text-decoration-style": "dotted" },
        ".decoration-dashed": { "text-decoration-style": "dashed" },
        ".decoration-wavy": { "text-decoration-style": "wavy" }
      });
    },
    textDecorationThickness: createUtilityPlugin(
      "textDecorationThickness",
      [["decoration", ["text-decoration-thickness"]]],
      { type: ["length", "percentage"] }
    ),
    textUnderlineOffset: createUtilityPlugin(
      "textUnderlineOffset",
      [["underline-offset", ["text-underline-offset"]]],
      { type: ["length", "percentage", "any"] }
    ),
    fontSmoothing: ({ addUtilities }) => {
      addUtilities({
        ".antialiased": {
          "-webkit-font-smoothing": "antialiased",
          "-moz-osx-font-smoothing": "grayscale"
        },
        ".subpixel-antialiased": {
          "-webkit-font-smoothing": "auto",
          "-moz-osx-font-smoothing": "auto"
        }
      });
    },
    placeholderColor: ({ matchUtilities, theme: theme2, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          placeholder: (value2) => {
            if (!corePlugins2("placeholderOpacity")) {
              return {
                "&::placeholder": {
                  color: toColorValue(value2)
                }
              };
            }
            return {
              "&::placeholder": withAlphaVariable({
                color: value2,
                property: "color",
                variable: "--tw-placeholder-opacity"
              })
            };
          }
        },
        { values: flattenColorPalette_default(theme2("placeholderColor")), type: ["color", "any"] }
      );
    },
    placeholderOpacity: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "placeholder-opacity": (value2) => {
            return { ["&::placeholder"]: { "--tw-placeholder-opacity": value2 } };
          }
        },
        { values: theme2("placeholderOpacity") }
      );
    },
    caretColor: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          caret: (value2) => {
            return { "caret-color": toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme2("caretColor")), type: ["color", "any"] }
      );
    },
    accentColor: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          accent: (value2) => {
            return { "accent-color": toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme2("accentColor")), type: ["color", "any"] }
      );
    },
    opacity: createUtilityPlugin("opacity", [["opacity", ["opacity"]]]),
    backgroundBlendMode: ({ addUtilities }) => {
      addUtilities({
        ".bg-blend-normal": { "background-blend-mode": "normal" },
        ".bg-blend-multiply": { "background-blend-mode": "multiply" },
        ".bg-blend-screen": { "background-blend-mode": "screen" },
        ".bg-blend-overlay": { "background-blend-mode": "overlay" },
        ".bg-blend-darken": { "background-blend-mode": "darken" },
        ".bg-blend-lighten": { "background-blend-mode": "lighten" },
        ".bg-blend-color-dodge": { "background-blend-mode": "color-dodge" },
        ".bg-blend-color-burn": { "background-blend-mode": "color-burn" },
        ".bg-blend-hard-light": { "background-blend-mode": "hard-light" },
        ".bg-blend-soft-light": { "background-blend-mode": "soft-light" },
        ".bg-blend-difference": { "background-blend-mode": "difference" },
        ".bg-blend-exclusion": { "background-blend-mode": "exclusion" },
        ".bg-blend-hue": { "background-blend-mode": "hue" },
        ".bg-blend-saturation": { "background-blend-mode": "saturation" },
        ".bg-blend-color": { "background-blend-mode": "color" },
        ".bg-blend-luminosity": { "background-blend-mode": "luminosity" }
      });
    },
    mixBlendMode: ({ addUtilities }) => {
      addUtilities({
        ".mix-blend-normal": { "mix-blend-mode": "normal" },
        ".mix-blend-multiply": { "mix-blend-mode": "multiply" },
        ".mix-blend-screen": { "mix-blend-mode": "screen" },
        ".mix-blend-overlay": { "mix-blend-mode": "overlay" },
        ".mix-blend-darken": { "mix-blend-mode": "darken" },
        ".mix-blend-lighten": { "mix-blend-mode": "lighten" },
        ".mix-blend-color-dodge": { "mix-blend-mode": "color-dodge" },
        ".mix-blend-color-burn": { "mix-blend-mode": "color-burn" },
        ".mix-blend-hard-light": { "mix-blend-mode": "hard-light" },
        ".mix-blend-soft-light": { "mix-blend-mode": "soft-light" },
        ".mix-blend-difference": { "mix-blend-mode": "difference" },
        ".mix-blend-exclusion": { "mix-blend-mode": "exclusion" },
        ".mix-blend-hue": { "mix-blend-mode": "hue" },
        ".mix-blend-saturation": { "mix-blend-mode": "saturation" },
        ".mix-blend-color": { "mix-blend-mode": "color" },
        ".mix-blend-luminosity": { "mix-blend-mode": "luminosity" },
        ".mix-blend-plus-lighter": { "mix-blend-mode": "plus-lighter" }
      });
    },
    boxShadow: (() => {
      let transformValue = transformThemeValue("boxShadow");
      let defaultBoxShadow = [
        `var(--tw-ring-offset-shadow, 0 0 #0000)`,
        `var(--tw-ring-shadow, 0 0 #0000)`,
        `var(--tw-shadow)`
      ].join(", ");
      return function({ matchUtilities, addDefaults, theme: theme2 }) {
        addDefaults(" box-shadow", {
          "--tw-ring-offset-shadow": "0 0 #0000",
          "--tw-ring-shadow": "0 0 #0000",
          "--tw-shadow": "0 0 #0000",
          "--tw-shadow-colored": "0 0 #0000"
        });
        matchUtilities(
          {
            shadow: (value2) => {
              value2 = transformValue(value2);
              let ast = parseBoxShadowValue(value2);
              for (let shadow2 of ast) {
                if (!shadow2.valid) {
                  continue;
                }
                shadow2.color = "var(--tw-shadow-color)";
              }
              return {
                "@defaults box-shadow": {},
                "--tw-shadow": value2 === "none" ? "0 0 #0000" : value2,
                "--tw-shadow-colored": value2 === "none" ? "0 0 #0000" : formatBoxShadowValue(ast),
                "box-shadow": defaultBoxShadow
              };
            }
          },
          { values: theme2("boxShadow"), type: ["shadow"] }
        );
      };
    })(),
    boxShadowColor: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          shadow: (value2) => {
            return {
              "--tw-shadow-color": toColorValue(value2),
              "--tw-shadow": "var(--tw-shadow-colored)"
            };
          }
        },
        { values: flattenColorPalette_default(theme2("boxShadowColor")), type: ["color", "any"] }
      );
    },
    outlineStyle: ({ addUtilities }) => {
      addUtilities({
        ".outline-none": {
          outline: "2px solid transparent",
          "outline-offset": "2px"
        },
        ".outline": { "outline-style": "solid" },
        ".outline-dashed": { "outline-style": "dashed" },
        ".outline-dotted": { "outline-style": "dotted" },
        ".outline-double": { "outline-style": "double" }
      });
    },
    outlineWidth: createUtilityPlugin("outlineWidth", [["outline", ["outline-width"]]], {
      type: ["length", "number", "percentage"]
    }),
    outlineOffset: createUtilityPlugin("outlineOffset", [["outline-offset", ["outline-offset"]]], {
      type: ["length", "number", "percentage", "any"],
      supportsNegativeValues: true
    }),
    outlineColor: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          outline: (value2) => {
            return { "outline-color": toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme2("outlineColor")), type: ["color", "any"] }
      );
    },
    ringWidth: ({ matchUtilities, addDefaults, addUtilities, theme: theme2, config: config5 }) => {
      let ringColorDefault = (() => {
        if (flagEnabled(config5(), "respectDefaultRingColorOpacity")) {
          return theme2("ringColor.DEFAULT");
        }
        let ringOpacityDefault = theme2("ringOpacity.DEFAULT", "0.5");
        if (!theme2("ringColor")?.DEFAULT) {
          return `rgb(147 197 253 / ${ringOpacityDefault})`;
        }
        return withAlphaValue(
          theme2("ringColor")?.DEFAULT,
          ringOpacityDefault,
          `rgb(147 197 253 / ${ringOpacityDefault})`
        );
      })();
      addDefaults("ring-width", {
        "--tw-ring-inset": " ",
        "--tw-ring-offset-width": theme2("ringOffsetWidth.DEFAULT", "0px"),
        "--tw-ring-offset-color": theme2("ringOffsetColor.DEFAULT", "#fff"),
        "--tw-ring-color": ringColorDefault,
        "--tw-ring-offset-shadow": "0 0 #0000",
        "--tw-ring-shadow": "0 0 #0000",
        "--tw-shadow": "0 0 #0000",
        "--tw-shadow-colored": "0 0 #0000"
      });
      matchUtilities(
        {
          ring: (value2) => {
            return {
              "@defaults ring-width": {},
              "--tw-ring-offset-shadow": `var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)`,
              "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${value2} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
              "box-shadow": [
                `var(--tw-ring-offset-shadow)`,
                `var(--tw-ring-shadow)`,
                `var(--tw-shadow, 0 0 #0000)`
              ].join(", ")
            };
          }
        },
        { values: theme2("ringWidth"), type: "length" }
      );
      addUtilities({
        ".ring-inset": { "@defaults ring-width": {}, "--tw-ring-inset": "inset" }
      });
    },
    ringColor: ({ matchUtilities, theme: theme2, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          ring: (value2) => {
            if (!corePlugins2("ringOpacity")) {
              return {
                "--tw-ring-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "--tw-ring-color",
              variable: "--tw-ring-opacity"
            });
          }
        },
        {
          values: Object.fromEntries(
            Object.entries(flattenColorPalette_default(theme2("ringColor"))).filter(
              ([modifier]) => modifier !== "DEFAULT"
            )
          ),
          type: ["color", "any"]
        }
      );
    },
    ringOpacity: (helpers) => {
      let { config: config5 } = helpers;
      return createUtilityPlugin("ringOpacity", [["ring-opacity", ["--tw-ring-opacity"]]], {
        filterDefault: !flagEnabled(config5(), "respectDefaultRingColorOpacity")
      })(helpers);
    },
    ringOffsetWidth: createUtilityPlugin(
      "ringOffsetWidth",
      [["ring-offset", ["--tw-ring-offset-width"]]],
      { type: "length" }
    ),
    ringOffsetColor: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "ring-offset": (value2) => {
            return {
              "--tw-ring-offset-color": toColorValue(value2)
            };
          }
        },
        { values: flattenColorPalette_default(theme2("ringOffsetColor")), type: ["color", "any"] }
      );
    },
    blur: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          blur: (value2) => {
            return {
              "--tw-blur": `blur(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme2("blur") }
      );
    },
    brightness: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          brightness: (value2) => {
            return {
              "--tw-brightness": `brightness(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme2("brightness") }
      );
    },
    contrast: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          contrast: (value2) => {
            return {
              "--tw-contrast": `contrast(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme2("contrast") }
      );
    },
    dropShadow: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "drop-shadow": (value2) => {
            return {
              "--tw-drop-shadow": Array.isArray(value2) ? value2.map((v) => `drop-shadow(${v})`).join(" ") : `drop-shadow(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme2("dropShadow") }
      );
    },
    grayscale: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          grayscale: (value2) => {
            return {
              "--tw-grayscale": `grayscale(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme2("grayscale") }
      );
    },
    hueRotate: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "hue-rotate": (value2) => {
            return {
              "--tw-hue-rotate": `hue-rotate(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme2("hueRotate"), supportsNegativeValues: true }
      );
    },
    invert: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          invert: (value2) => {
            return {
              "--tw-invert": `invert(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme2("invert") }
      );
    },
    saturate: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          saturate: (value2) => {
            return {
              "--tw-saturate": `saturate(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme2("saturate") }
      );
    },
    sepia: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          sepia: (value2) => {
            return {
              "--tw-sepia": `sepia(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme2("sepia") }
      );
    },
    filter: ({ addDefaults, addUtilities }) => {
      addDefaults("filter", {
        "--tw-blur": " ",
        "--tw-brightness": " ",
        "--tw-contrast": " ",
        "--tw-grayscale": " ",
        "--tw-hue-rotate": " ",
        "--tw-invert": " ",
        "--tw-saturate": " ",
        "--tw-sepia": " ",
        "--tw-drop-shadow": " "
      });
      addUtilities({
        ".filter": { "@defaults filter": {}, filter: cssFilterValue },
        ".filter-none": { filter: "none" }
      });
    },
    backdropBlur: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "backdrop-blur": (value2) => {
            return {
              "--tw-backdrop-blur": `blur(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme2("backdropBlur") }
      );
    },
    backdropBrightness: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "backdrop-brightness": (value2) => {
            return {
              "--tw-backdrop-brightness": `brightness(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme2("backdropBrightness") }
      );
    },
    backdropContrast: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "backdrop-contrast": (value2) => {
            return {
              "--tw-backdrop-contrast": `contrast(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme2("backdropContrast") }
      );
    },
    backdropGrayscale: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "backdrop-grayscale": (value2) => {
            return {
              "--tw-backdrop-grayscale": `grayscale(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme2("backdropGrayscale") }
      );
    },
    backdropHueRotate: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "backdrop-hue-rotate": (value2) => {
            return {
              "--tw-backdrop-hue-rotate": `hue-rotate(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme2("backdropHueRotate"), supportsNegativeValues: true }
      );
    },
    backdropInvert: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "backdrop-invert": (value2) => {
            return {
              "--tw-backdrop-invert": `invert(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme2("backdropInvert") }
      );
    },
    backdropOpacity: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "backdrop-opacity": (value2) => {
            return {
              "--tw-backdrop-opacity": `opacity(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme2("backdropOpacity") }
      );
    },
    backdropSaturate: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "backdrop-saturate": (value2) => {
            return {
              "--tw-backdrop-saturate": `saturate(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme2("backdropSaturate") }
      );
    },
    backdropSepia: ({ matchUtilities, theme: theme2 }) => {
      matchUtilities(
        {
          "backdrop-sepia": (value2) => {
            return {
              "--tw-backdrop-sepia": `sepia(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme2("backdropSepia") }
      );
    },
    backdropFilter: ({ addDefaults, addUtilities }) => {
      addDefaults("backdrop-filter", {
        "--tw-backdrop-blur": " ",
        "--tw-backdrop-brightness": " ",
        "--tw-backdrop-contrast": " ",
        "--tw-backdrop-grayscale": " ",
        "--tw-backdrop-hue-rotate": " ",
        "--tw-backdrop-invert": " ",
        "--tw-backdrop-opacity": " ",
        "--tw-backdrop-saturate": " ",
        "--tw-backdrop-sepia": " "
      });
      addUtilities({
        ".backdrop-filter": {
          "@defaults backdrop-filter": {},
          "backdrop-filter": cssBackdropFilterValue
        },
        ".backdrop-filter-none": { "backdrop-filter": "none" }
      });
    },
    transitionProperty: ({ matchUtilities, theme: theme2 }) => {
      let defaultTimingFunction = theme2("transitionTimingFunction.DEFAULT");
      let defaultDuration = theme2("transitionDuration.DEFAULT");
      matchUtilities(
        {
          transition: (value2) => {
            return {
              "transition-property": value2,
              ...value2 === "none" ? {} : {
                "transition-timing-function": defaultTimingFunction,
                "transition-duration": defaultDuration
              }
            };
          }
        },
        { values: theme2("transitionProperty") }
      );
    },
    transitionDelay: createUtilityPlugin("transitionDelay", [["delay", ["transitionDelay"]]]),
    transitionDuration: createUtilityPlugin(
      "transitionDuration",
      [["duration", ["transitionDuration"]]],
      { filterDefault: true }
    ),
    transitionTimingFunction: createUtilityPlugin(
      "transitionTimingFunction",
      [["ease", ["transitionTimingFunction"]]],
      { filterDefault: true }
    ),
    willChange: createUtilityPlugin("willChange", [["will-change", ["will-change"]]]),
    content: createUtilityPlugin("content", [
      ["content", ["--tw-content", ["content", "var(--tw-content)"]]]
    ]),
    forcedColorAdjust: ({ addUtilities }) => {
      addUtilities({
        ".forced-color-adjust-auto": { "forced-color-adjust": "auto" },
        ".forced-color-adjust-none": { "forced-color-adjust": "none" }
      });
    }
  };
  function toPath(path) {
    if (Array.isArray(path))
      return path;
    let openBrackets = path.split("[").length - 1;
    let closedBrackets = path.split("]").length - 1;
    if (openBrackets !== closedBrackets) {
      throw new Error(`Path is invalid. Has unbalanced brackets: ${path}`);
    }
    return path.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
  }
  var matchingBrackets = /* @__PURE__ */ new Map([
    ["{", "}"],
    ["[", "]"],
    ["(", ")"]
  ]);
  var inverseMatchingBrackets = new Map(
    Array.from(matchingBrackets.entries()).map(([k, v]) => [v, k])
  );
  var quotes = /* @__PURE__ */ new Set(['"', "'", "`"]);
  function isSyntacticallyValidPropertyValue(value2) {
    let stack2 = [];
    let inQuotes = false;
    for (let i = 0; i < value2.length; i++) {
      let char = value2[i];
      if (char === ":" && !inQuotes && stack2.length === 0) {
        return false;
      }
      if (quotes.has(char) && value2[i - 1] !== "\\") {
        inQuotes = !inQuotes;
      }
      if (inQuotes)
        continue;
      if (value2[i - 1] === "\\")
        continue;
      if (matchingBrackets.has(char)) {
        stack2.push(char);
      } else if (inverseMatchingBrackets.has(char)) {
        let inverse = inverseMatchingBrackets.get(char);
        if (stack2.length <= 0) {
          return false;
        }
        if (stack2.pop() !== inverse) {
          return false;
        }
      }
    }
    if (stack2.length > 0) {
      return false;
    }
    return true;
  }
  function bigSign(bigIntValue) {
    return (bigIntValue > 0n) - (bigIntValue < 0n);
  }
  function remapBitfield(num, mapping) {
    let oldMask = 0n;
    let newMask = 0n;
    for (let [oldBit, newBit] of mapping) {
      if (num & oldBit) {
        oldMask = oldMask | oldBit;
        newMask = newMask | newBit;
      }
    }
    return num & ~oldMask | newMask;
  }
  var Offsets = class {
    constructor() {
      this.offsets = {
        defaults: 0n,
        base: 0n,
        components: 0n,
        utilities: 0n,
        variants: 0n,
        user: 0n
      };
      this.layerPositions = {
        defaults: 0n,
        base: 1n,
        components: 2n,
        utilities: 3n,
        user: 4n,
        variants: 5n
      };
      this.reservedVariantBits = 0n;
      this.variantOffsets = /* @__PURE__ */ new Map();
    }
    create(layer) {
      return {
        layer,
        parentLayer: layer,
        arbitrary: 0n,
        variants: 0n,
        parallelIndex: 0n,
        index: this.offsets[layer]++,
        options: []
      };
    }
    arbitraryProperty() {
      return {
        ...this.create("utilities"),
        arbitrary: 1n
      };
    }
    forVariant(variant, index5 = 0) {
      let offset = this.variantOffsets.get(variant);
      if (offset === void 0) {
        throw new Error(`Cannot find offset for unknown variant ${variant}`);
      }
      return {
        ...this.create("variants"),
        variants: offset << BigInt(index5)
      };
    }
    applyVariantOffset(rule2, variant, options) {
      options.variant = variant.variants;
      return {
        ...rule2,
        layer: "variants",
        parentLayer: rule2.layer === "variants" ? rule2.parentLayer : rule2.layer,
        variants: rule2.variants | variant.variants,
        options: options.sort ? [].concat(options, rule2.options) : rule2.options,
        parallelIndex: max([rule2.parallelIndex, variant.parallelIndex])
      };
    }
    applyParallelOffset(offset, parallelIndex) {
      return {
        ...offset,
        parallelIndex: BigInt(parallelIndex)
      };
    }
    recordVariants(variants, getLength) {
      for (let variant of variants) {
        this.recordVariant(variant, getLength(variant));
      }
    }
    recordVariant(variant, fnCount = 1) {
      this.variantOffsets.set(variant, 1n << this.reservedVariantBits);
      this.reservedVariantBits += BigInt(fnCount);
      return {
        ...this.create("variants"),
        variants: this.variantOffsets.get(variant)
      };
    }
    compare(a, b) {
      if (a.layer !== b.layer) {
        return this.layerPositions[a.layer] - this.layerPositions[b.layer];
      }
      if (a.parentLayer !== b.parentLayer) {
        return this.layerPositions[a.parentLayer] - this.layerPositions[b.parentLayer];
      }
      for (let aOptions of a.options) {
        for (let bOptions of b.options) {
          if (aOptions.id !== bOptions.id)
            continue;
          if (!aOptions.sort || !bOptions.sort)
            continue;
          let maxFnVariant = max([aOptions.variant, bOptions.variant]) ?? 0n;
          let mask = ~(maxFnVariant | maxFnVariant - 1n);
          let aVariantsAfterFn = a.variants & mask;
          let bVariantsAfterFn = b.variants & mask;
          if (aVariantsAfterFn !== bVariantsAfterFn) {
            continue;
          }
          let result = aOptions.sort(
            {
              value: aOptions.value,
              modifier: aOptions.modifier
            },
            {
              value: bOptions.value,
              modifier: bOptions.modifier
            }
          );
          if (result !== 0)
            return result;
        }
      }
      if (a.variants !== b.variants) {
        return a.variants - b.variants;
      }
      if (a.parallelIndex !== b.parallelIndex) {
        return a.parallelIndex - b.parallelIndex;
      }
      if (a.arbitrary !== b.arbitrary) {
        return a.arbitrary - b.arbitrary;
      }
      return a.index - b.index;
    }
    recalculateVariantOffsets() {
      let variants = Array.from(this.variantOffsets.entries()).filter(([v]) => v.startsWith("[")).sort(([a], [z]) => fastCompare(a, z));
      let newOffsets = variants.map(([, offset]) => offset).sort((a, z) => bigSign(a - z));
      let mapping = variants.map(([, oldOffset], i) => [oldOffset, newOffsets[i]]);
      return mapping.filter(([a, z]) => a !== z);
    }
    remapArbitraryVariantOffsets(list22) {
      let mapping = this.recalculateVariantOffsets();
      if (mapping.length === 0) {
        return list22;
      }
      return list22.map((item) => {
        let [offset, rule2] = item;
        offset = {
          ...offset,
          variants: remapBitfield(offset.variants, mapping)
        };
        return [offset, rule2];
      });
    }
    sort(list22) {
      list22 = this.remapArbitraryVariantOffsets(list22);
      return list22.sort(([a], [b]) => bigSign(this.compare(a, b)));
    }
  };
  function max(nums) {
    let max2 = null;
    for (const num of nums) {
      max2 = max2 ?? num;
      max2 = max2 > num ? max2 : num;
    }
    return max2;
  }
  function fastCompare(a, b) {
    let aLen = a.length;
    let bLen = b.length;
    let minLen = aLen < bLen ? aLen : bLen;
    for (let i = 0; i < minLen; i++) {
      let cmp = a.charCodeAt(i) - b.charCodeAt(i);
      if (cmp !== 0)
        return cmp;
    }
    return aLen - bLen;
  }
  var INTERNAL_FEATURES = Symbol();
  var VARIANT_TYPES = {
    AddVariant: Symbol.for("ADD_VARIANT"),
    MatchVariant: Symbol.for("MATCH_VARIANT")
  };
  var VARIANT_INFO = {
    Base: 1 << 0,
    Dynamic: 1 << 1
  };
  function prefix(context, selector) {
    let prefix3 = context.tailwindConfig.prefix;
    return typeof prefix3 === "function" ? prefix3(selector) : prefix3 + selector;
  }
  function normalizeOptionTypes({ type = "any", ...options }) {
    let types2 = [].concat(type);
    return {
      ...options,
      types: types2.map((type2) => {
        if (Array.isArray(type2)) {
          return { type: type2[0], ...type2[1] };
        }
        return { type: type2, preferOnConflict: false };
      })
    };
  }
  function parseVariantFormatString(input) {
    let parts = [];
    let current = "";
    let depth = 0;
    for (let idx = 0; idx < input.length; idx++) {
      let char = input[idx];
      if (char === "\\") {
        current += "\\" + input[++idx];
      } else if (char === "{") {
        ++depth;
        parts.push(current.trim());
        current = "";
      } else if (char === "}") {
        if (--depth < 0) {
          throw new Error(`Your { and } are unbalanced.`);
        }
        parts.push(current.trim());
        current = "";
      } else {
        current += char;
      }
    }
    if (current.length > 0) {
      parts.push(current.trim());
    }
    parts = parts.filter((part) => part !== "");
    return parts;
  }
  function insertInto(list22, value2, { before = [] } = {}) {
    before = [].concat(before);
    if (before.length <= 0) {
      list22.push(value2);
      return;
    }
    let idx = list22.length - 1;
    for (let other of before) {
      let iidx = list22.indexOf(other);
      if (iidx === -1)
        continue;
      idx = Math.min(idx, iidx);
    }
    list22.splice(idx, 0, value2);
  }
  function parseStyles(styles) {
    if (!Array.isArray(styles)) {
      return parseStyles([styles]);
    }
    return styles.flatMap((style) => {
      let isNode = !Array.isArray(style) && !isPlainObject(style);
      return isNode ? style : parseObjectStyles(style);
    });
  }
  function getClasses(selector, mutate2) {
    let parser5 = (0, import_postcss_selector_parser5.default)((selectors) => {
      let allClasses = [];
      if (mutate2) {
        mutate2(selectors);
      }
      selectors.walkClasses((classNode) => {
        allClasses.push(classNode.value);
      });
      return allClasses;
    });
    return parser5.transformSync(selector);
  }
  function ignoreNot(selectors) {
    selectors.walkPseudos((pseudo) => {
      if (pseudo.value === ":not") {
        pseudo.remove();
      }
    });
  }
  function extractCandidates(node, state2 = { containsNonOnDemandable: false }, depth = 0) {
    let classes = [];
    let selectors = [];
    if (node.type === "rule") {
      selectors.push(...node.selectors);
    } else if (node.type === "atrule") {
      node.walkRules((rule2) => selectors.push(...rule2.selectors));
    }
    for (let selector of selectors) {
      let classCandidates = getClasses(selector, ignoreNot);
      if (classCandidates.length === 0) {
        state2.containsNonOnDemandable = true;
      }
      for (let classCandidate of classCandidates) {
        classes.push(classCandidate);
      }
    }
    if (depth === 0) {
      return [state2.containsNonOnDemandable || classes.length === 0, classes];
    }
    return classes;
  }
  function withIdentifiers(styles) {
    return parseStyles(styles).flatMap((node) => {
      let nodeMap = /* @__PURE__ */ new Map();
      let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);
      if (containsNonOnDemandableSelectors) {
        candidates.unshift(NOT_ON_DEMAND);
      }
      return candidates.map((c) => {
        if (!nodeMap.has(node)) {
          nodeMap.set(node, node);
        }
        return [c, nodeMap.get(node)];
      });
    });
  }
  function isValidVariantFormatString(format) {
    return format.startsWith("@") || format.includes("&");
  }
  function parseVariant(variant) {
    variant = variant.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
    let fns = parseVariantFormatString(variant).map((str) => {
      if (!str.startsWith("@")) {
        return ({ format }) => format(str);
      }
      let [, name, params] = /@(\S*)( .+|[({].*)?/g.exec(str);
      return ({ wrap }) => wrap(postcss_default.atRule({ name, params: params?.trim() ?? "" }));
    }).reverse();
    return (api) => {
      for (let fn of fns) {
        fn(api);
      }
    };
  }
  function buildPluginApi(tailwindConfig2, context, { variantList, variantMap, offsets, classList }) {
    function getConfigValue(path, defaultValue) {
      return path ? (0, import_dlv.default)(tailwindConfig2, path, defaultValue) : tailwindConfig2;
    }
    function applyConfiguredPrefix(selector) {
      return prefixSelector_default(tailwindConfig2.prefix, selector);
    }
    function prefixIdentifier(identifier, options) {
      if (identifier === NOT_ON_DEMAND) {
        return NOT_ON_DEMAND;
      }
      if (!options.respectPrefix) {
        return identifier;
      }
      return context.tailwindConfig.prefix + identifier;
    }
    function resolveThemeValue(path, defaultValue, opts = {}) {
      let parts = toPath(path);
      let value2 = getConfigValue(["theme", ...parts], defaultValue);
      return transformThemeValue(parts[0])(value2, opts);
    }
    let variantIdentifier = 0;
    let api = {
      postcss: postcss_default,
      prefix: applyConfiguredPrefix,
      e: escapeClassName,
      config: getConfigValue,
      theme: resolveThemeValue,
      corePlugins: (path) => {
        if (Array.isArray(tailwindConfig2.corePlugins)) {
          return tailwindConfig2.corePlugins.includes(path);
        }
        return getConfigValue(["corePlugins", path], true);
      },
      variants: () => {
        return [];
      },
      addBase(base) {
        for (let [identifier, rule2] of withIdentifiers(base)) {
          let prefixedIdentifier = prefixIdentifier(identifier, {});
          let offset = offsets.create("base");
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offset, layer: "base" }, rule2]);
        }
      },
      addDefaults(group, declarations) {
        const groups = {
          [`@defaults ${group}`]: declarations
        };
        for (let [identifier, rule2] of withIdentifiers(groups)) {
          let prefixedIdentifier = prefixIdentifier(identifier, {});
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offsets.create("defaults"), layer: "defaults" }, rule2]);
        }
      },
      addComponents(components, options) {
        let defaultOptions = {
          preserveSource: false,
          respectPrefix: true,
          respectImportant: false
        };
        options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
        for (let [identifier, rule2] of withIdentifiers(components)) {
          let prefixedIdentifier = prefixIdentifier(identifier, options);
          classList.add(prefixedIdentifier);
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offsets.create("components"), layer: "components", options }, rule2]);
        }
      },
      addUtilities(utilities, options) {
        let defaultOptions = {
          preserveSource: false,
          respectPrefix: true,
          respectImportant: true
        };
        options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
        for (let [identifier, rule2] of withIdentifiers(utilities)) {
          let prefixedIdentifier = prefixIdentifier(identifier, options);
          classList.add(prefixedIdentifier);
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offsets.create("utilities"), layer: "utilities", options }, rule2]);
        }
      },
      matchUtilities: function(utilities, options) {
        let defaultOptions = {
          respectPrefix: true,
          respectImportant: true,
          modifiers: false
        };
        options = normalizeOptionTypes({ ...defaultOptions, ...options });
        let offset = offsets.create("utilities");
        for (let identifier in utilities) {
          let wrapped = function(modifier, { isOnlyPlugin }) {
            let [value2, coercedType, utilityModifier] = coerceValue(
              options.types,
              modifier,
              options,
              tailwindConfig2
            );
            if (value2 === void 0) {
              return [];
            }
            if (!options.types.some(({ type }) => type === coercedType)) {
              if (isOnlyPlugin) {
                log_default.warn([
                  `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                  `You can safely update it to \`${identifier}-${modifier.replace(
                    coercedType + ":",
                    ""
                  )}\`.`
                ]);
              } else {
                return [];
              }
            }
            if (!isSyntacticallyValidPropertyValue(value2)) {
              return [];
            }
            let extras = {
              get modifier() {
                if (!options.modifiers) {
                  log_default.warn(`modifier-used-without-options-for-${identifier}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]);
                }
                return utilityModifier;
              }
            };
            let modifiersEnabled = flagEnabled(tailwindConfig2, "generalizedModifiers");
            let ruleSets = [].concat(modifiersEnabled ? rule2(value2, extras) : rule2(value2)).filter(Boolean).map((declaration) => ({
              [nameClass(identifier, modifier)]: declaration
            }));
            return ruleSets;
          };
          let prefixedIdentifier = prefixIdentifier(identifier, options);
          let rule2 = utilities[identifier];
          classList.add([prefixedIdentifier, options]);
          let withOffsets = [{ sort: offset, layer: "utilities", options }, wrapped];
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
        }
      },
      matchComponents: function(components, options) {
        let defaultOptions = {
          respectPrefix: true,
          respectImportant: false,
          modifiers: false
        };
        options = normalizeOptionTypes({ ...defaultOptions, ...options });
        let offset = offsets.create("components");
        for (let identifier in components) {
          let wrapped = function(modifier, { isOnlyPlugin }) {
            let [value2, coercedType, utilityModifier] = coerceValue(
              options.types,
              modifier,
              options,
              tailwindConfig2
            );
            if (value2 === void 0) {
              return [];
            }
            if (!options.types.some(({ type }) => type === coercedType)) {
              if (isOnlyPlugin) {
                log_default.warn([
                  `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                  `You can safely update it to \`${identifier}-${modifier.replace(
                    coercedType + ":",
                    ""
                  )}\`.`
                ]);
              } else {
                return [];
              }
            }
            if (!isSyntacticallyValidPropertyValue(value2)) {
              return [];
            }
            let extras = {
              get modifier() {
                if (!options.modifiers) {
                  log_default.warn(`modifier-used-without-options-for-${identifier}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]);
                }
                return utilityModifier;
              }
            };
            let modifiersEnabled = flagEnabled(tailwindConfig2, "generalizedModifiers");
            let ruleSets = [].concat(modifiersEnabled ? rule2(value2, extras) : rule2(value2)).filter(Boolean).map((declaration) => ({
              [nameClass(identifier, modifier)]: declaration
            }));
            return ruleSets;
          };
          let prefixedIdentifier = prefixIdentifier(identifier, options);
          let rule2 = components[identifier];
          classList.add([prefixedIdentifier, options]);
          let withOffsets = [{ sort: offset, layer: "components", options }, wrapped];
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
        }
      },
      addVariant(variantName, variantFunctions, options = {}) {
        variantFunctions = [].concat(variantFunctions).map((variantFunction) => {
          if (typeof variantFunction !== "string") {
            return (api2 = {}) => {
              let { args, modifySelectors, container, separator, wrap, format } = api2;
              let result = variantFunction(
                Object.assign(
                  { modifySelectors, container, separator },
                  options.type === VARIANT_TYPES.MatchVariant && { args, wrap, format }
                )
              );
              if (typeof result === "string" && !isValidVariantFormatString(result)) {
                throw new Error(
                  `Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`
                );
              }
              if (Array.isArray(result)) {
                return result.filter((variant) => typeof variant === "string").map((variant) => parseVariant(variant));
              }
              return result && typeof result === "string" && parseVariant(result)(api2);
            };
          }
          if (!isValidVariantFormatString(variantFunction)) {
            throw new Error(
              `Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`
            );
          }
          return parseVariant(variantFunction);
        });
        insertInto(variantList, variantName, options);
        variantMap.set(variantName, variantFunctions);
        context.variantOptions.set(variantName, options);
      },
      matchVariant(variant, variantFn, options) {
        let id = options?.id ?? ++variantIdentifier;
        let isSpecial = variant === "@";
        let modifiersEnabled = flagEnabled(tailwindConfig2, "generalizedModifiers");
        for (let [key, value2] of Object.entries(options?.values ?? {})) {
          if (key === "DEFAULT")
            continue;
          api.addVariant(
            isSpecial ? `${variant}${key}` : `${variant}-${key}`,
            ({ args, container }) => {
              return variantFn(
                value2,
                modifiersEnabled ? { modifier: args?.modifier, container } : { container }
              );
            },
            {
              ...options,
              value: value2,
              id,
              type: VARIANT_TYPES.MatchVariant,
              variantInfo: VARIANT_INFO.Base
            }
          );
        }
        let hasDefault = "DEFAULT" in (options?.values ?? {});
        api.addVariant(
          variant,
          ({ args, container }) => {
            if (args?.value === NONE && !hasDefault) {
              return null;
            }
            return variantFn(
              args?.value === NONE ? options.values.DEFAULT : args?.value ?? (typeof args === "string" ? args : ""),
              modifiersEnabled ? { modifier: args?.modifier, container } : { container }
            );
          },
          {
            ...options,
            id,
            type: VARIANT_TYPES.MatchVariant,
            variantInfo: VARIANT_INFO.Dynamic
          }
        );
      }
    };
    return api;
  }
  function extractVariantAtRules(node) {
    node.walkAtRules((atRule2) => {
      if (["responsive", "variants"].includes(atRule2.name)) {
        extractVariantAtRules(atRule2);
        atRule2.before(atRule2.nodes);
        atRule2.remove();
      }
    });
  }
  function collectLayerPlugins(root12) {
    let layerPlugins = [];
    root12.each((node) => {
      if (node.type === "atrule" && ["responsive", "variants"].includes(node.name)) {
        node.name = "layer";
        node.params = "utilities";
      }
    });
    root12.walkAtRules("layer", (layerRule) => {
      extractVariantAtRules(layerRule);
      if (layerRule.params === "base") {
        for (let node of layerRule.nodes) {
          layerPlugins.push(function({ addBase }) {
            addBase(node, { respectPrefix: false });
          });
        }
        layerRule.remove();
      } else if (layerRule.params === "components") {
        for (let node of layerRule.nodes) {
          layerPlugins.push(function({ addComponents }) {
            addComponents(node, { respectPrefix: false, preserveSource: true });
          });
        }
        layerRule.remove();
      } else if (layerRule.params === "utilities") {
        for (let node of layerRule.nodes) {
          layerPlugins.push(function({ addUtilities }) {
            addUtilities(node, { respectPrefix: false, preserveSource: true });
          });
        }
        layerRule.remove();
      }
    });
    return layerPlugins;
  }
  function resolvePlugins(context, root12) {
    let corePluginList = Object.entries({ ...variantPlugins, ...corePlugins }).map(([name, plugin2]) => {
      if (!context.tailwindConfig.corePlugins.includes(name)) {
        return null;
      }
      return plugin2;
    }).filter(Boolean);
    let userPlugins = context.tailwindConfig.plugins.map((plugin2) => {
      if (plugin2.__isOptionsFunction) {
        plugin2 = plugin2();
      }
      return typeof plugin2 === "function" ? plugin2 : plugin2.handler;
    });
    let layerPlugins = collectLayerPlugins(root12);
    let beforeVariants = [
      variantPlugins["childVariant"],
      variantPlugins["pseudoElementVariants"],
      variantPlugins["pseudoClassVariants"],
      variantPlugins["hasVariants"],
      variantPlugins["ariaVariants"],
      variantPlugins["dataVariants"]
    ];
    let afterVariants = [
      variantPlugins["supportsVariants"],
      variantPlugins["reducedMotionVariants"],
      variantPlugins["prefersContrastVariants"],
      variantPlugins["screenVariants"],
      variantPlugins["orientationVariants"],
      variantPlugins["directionVariants"],
      variantPlugins["darkVariants"],
      variantPlugins["forcedColorsVariants"],
      variantPlugins["printVariant"]
    ];
    let isLegacyDarkMode = context.tailwindConfig.darkMode === "class" || Array.isArray(context.tailwindConfig.darkMode) && context.tailwindConfig.darkMode[0] === "class";
    if (isLegacyDarkMode) {
      afterVariants = [
        variantPlugins["supportsVariants"],
        variantPlugins["reducedMotionVariants"],
        variantPlugins["prefersContrastVariants"],
        variantPlugins["darkVariants"],
        variantPlugins["screenVariants"],
        variantPlugins["orientationVariants"],
        variantPlugins["directionVariants"],
        variantPlugins["forcedColorsVariants"],
        variantPlugins["printVariant"]
      ];
    }
    return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins];
  }
  function registerPlugins(plugins, context) {
    let variantList = [];
    let variantMap = /* @__PURE__ */ new Map();
    context.variantMap = variantMap;
    let offsets = new Offsets();
    context.offsets = offsets;
    let classList = /* @__PURE__ */ new Set();
    let pluginApi = buildPluginApi(context.tailwindConfig, context, {
      variantList,
      variantMap,
      offsets,
      classList
    });
    for (let plugin2 of plugins) {
      if (Array.isArray(plugin2)) {
        for (let pluginItem of plugin2) {
          pluginItem(pluginApi);
        }
      } else {
        plugin2?.(pluginApi);
      }
    }
    offsets.recordVariants(variantList, (variant) => variantMap.get(variant).length);
    for (let [variantName, variantFunctions] of variantMap.entries()) {
      context.variantMap.set(
        variantName,
        variantFunctions.map((variantFunction, idx) => [
          offsets.forVariant(variantName, idx),
          variantFunction
        ])
      );
    }
    let safelist = (context.tailwindConfig.safelist ?? []).filter(Boolean);
    if (safelist.length > 0) {
      let checks = [];
      for (let value2 of safelist) {
        if (typeof value2 === "string") {
          context.changedContent.push({ content: value2, extension: "html" });
          continue;
        }
        if (value2 instanceof RegExp) {
          log_default.warn("root-regex", [
            "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
            "Update your `safelist` configuration to eliminate this warning.",
            "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
          ]);
          continue;
        }
        checks.push(value2);
      }
      if (checks.length > 0) {
        let patternMatchingCount = /* @__PURE__ */ new Map();
        let prefixLength = context.tailwindConfig.prefix.length;
        let checkImportantUtils = checks.some((check) => check.pattern.source.includes("!"));
        for (let util of classList) {
          let utils = Array.isArray(util) ? (() => {
            let [utilName, options] = util;
            let values = Object.keys(options?.values ?? {});
            let classes = values.map((value2) => formatClass(utilName, value2));
            if (options?.supportsNegativeValues) {
              classes = [...classes, ...classes.map((cls) => "-" + cls)];
              classes = [
                ...classes,
                ...classes.map(
                  (cls) => cls.slice(0, prefixLength) + "-" + cls.slice(prefixLength)
                )
              ];
            }
            if (options.types.some(({ type }) => type === "color")) {
              classes = [
                ...classes,
                ...classes.flatMap(
                  (cls) => Object.keys(context.tailwindConfig.theme.opacity).map(
                    (opacity) => `${cls}/${opacity}`
                  )
                )
              ];
            }
            if (checkImportantUtils && options?.respectImportant) {
              classes = [...classes, ...classes.map((cls) => "!" + cls)];
            }
            return classes;
          })() : [util];
          for (let util2 of utils) {
            for (let { pattern: pattern2, variants = [] } of checks) {
              pattern2.lastIndex = 0;
              if (!patternMatchingCount.has(pattern2)) {
                patternMatchingCount.set(pattern2, 0);
              }
              if (!pattern2.test(util2))
                continue;
              patternMatchingCount.set(pattern2, patternMatchingCount.get(pattern2) + 1);
              context.changedContent.push({ content: util2, extension: "html" });
              for (let variant of variants) {
                context.changedContent.push({
                  content: variant + context.tailwindConfig.separator + util2,
                  extension: "html"
                });
              }
            }
          }
        }
        for (let [regex, count] of patternMatchingCount.entries()) {
          if (count !== 0)
            continue;
          log_default.warn([
            `The safelist pattern \`${regex}\` doesn't match any Tailwind CSS classes.`,
            "Fix this pattern or remove it from your `safelist` configuration.",
            "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
          ]);
        }
      }
    }
    let darkClassName = [].concat(context.tailwindConfig.darkMode ?? "media")[1] ?? "dark";
    let parasiteUtilities = [
      prefix(context, darkClassName),
      prefix(context, "group"),
      prefix(context, "peer")
    ];
    context.getClassOrder = function getClassOrder(classes) {
      let sorted = [...classes].sort((a, z) => {
        if (a === z)
          return 0;
        if (a < z)
          return -1;
        return 1;
      });
      let sortedClassNames = new Map(sorted.map((className) => [className, null]));
      let rules2 = generateRules(new Set(sorted), context, true);
      rules2 = context.offsets.sort(rules2);
      let idx = BigInt(parasiteUtilities.length);
      for (const [, rule2] of rules2) {
        let candidate = rule2.raws.tailwind.candidate;
        sortedClassNames.set(candidate, sortedClassNames.get(candidate) ?? idx++);
      }
      return classes.map((className) => {
        let order = sortedClassNames.get(className) ?? null;
        let parasiteIndex = parasiteUtilities.indexOf(className);
        if (order === null && parasiteIndex !== -1) {
          order = BigInt(parasiteIndex);
        }
        return [className, order];
      });
    };
    context.getClassList = function getClassList(options = {}) {
      let output = [];
      for (let util of classList) {
        if (Array.isArray(util)) {
          let [utilName, utilOptions] = util;
          let negativeClasses = [];
          let modifiers = Object.keys(utilOptions?.modifiers ?? {});
          if (utilOptions?.types?.some(({ type }) => type === "color")) {
            modifiers.push(...Object.keys(context.tailwindConfig.theme.opacity ?? {}));
          }
          let metadata = { modifiers };
          let includeMetadata = options.includeMetadata && modifiers.length > 0;
          for (let [key, value2] of Object.entries(utilOptions?.values ?? {})) {
            if (value2 == null) {
              continue;
            }
            let cls = formatClass(utilName, key);
            output.push(includeMetadata ? [cls, metadata] : cls);
            if (utilOptions?.supportsNegativeValues && negateValue(value2)) {
              let cls2 = formatClass(utilName, `-${key}`);
              negativeClasses.push(includeMetadata ? [cls2, metadata] : cls2);
            }
          }
          output.push(...negativeClasses);
        } else {
          output.push(util);
        }
      }
      return output;
    };
    context.getVariants = function getVariants() {
      let result = [];
      for (let [name, options] of context.variantOptions.entries()) {
        if (options.variantInfo === VARIANT_INFO.Base)
          continue;
        result.push({
          name,
          isArbitrary: options.type === Symbol.for("MATCH_VARIANT"),
          values: Object.keys(options.values ?? {}),
          hasDash: name !== "@",
          selectors({ modifier, value: value2 } = {}) {
            let candidate = "__TAILWIND_PLACEHOLDER__";
            let rule2 = postcss_default.rule({ selector: `.${candidate}` });
            let container = postcss_default.root({ nodes: [rule2.clone()] });
            let before = container.toString();
            let fns = (context.variantMap.get(name) ?? []).flatMap(([_, fn]) => fn);
            let formatStrings = [];
            for (let fn of fns) {
              let localFormatStrings = [];
              let api = {
                args: { modifier, value: options.values?.[value2] ?? value2 },
                separator: context.tailwindConfig.separator,
                modifySelectors(modifierFunction) {
                  container.each((rule22) => {
                    if (rule22.type !== "rule") {
                      return;
                    }
                    rule22.selectors = rule22.selectors.map((selector) => {
                      return modifierFunction({
                        get className() {
                          return getClassNameFromSelector(selector);
                        },
                        selector
                      });
                    });
                  });
                  return container;
                },
                format(str) {
                  localFormatStrings.push(str);
                },
                wrap(wrapper) {
                  localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);
                },
                container
              };
              let ruleWithVariant = fn(api);
              if (localFormatStrings.length > 0) {
                formatStrings.push(localFormatStrings);
              }
              if (Array.isArray(ruleWithVariant)) {
                for (let variantFunction of ruleWithVariant) {
                  localFormatStrings = [];
                  variantFunction(api);
                  formatStrings.push(localFormatStrings);
                }
              }
            }
            let manualFormatStrings = [];
            let after = container.toString();
            if (before !== after) {
              container.walkRules((rule22) => {
                let modified = rule22.selector;
                let rebuiltBase = (0, import_postcss_selector_parser5.default)((selectors) => {
                  selectors.walkClasses((classNode) => {
                    classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;
                  });
                }).processSync(modified);
                manualFormatStrings.push(modified.replace(rebuiltBase, "&").replace(candidate, "&"));
              });
              container.walkAtRules((atrule) => {
                manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);
              });
            }
            let isArbitraryVariant = !(value2 in (options.values ?? {}));
            let internalFeatures = options[INTERNAL_FEATURES] ?? {};
            let respectPrefix = (() => {
              if (isArbitraryVariant)
                return false;
              if (internalFeatures.respectPrefix === false)
                return false;
              return true;
            })();
            formatStrings = formatStrings.map(
              (format) => format.map((str) => ({
                format: str,
                respectPrefix
              }))
            );
            manualFormatStrings = manualFormatStrings.map((format) => ({
              format,
              respectPrefix
            }));
            let opts = {
              candidate,
              context
            };
            let result2 = formatStrings.map(
              (formats) => finalizeSelector(`.${candidate}`, formatVariantSelector(formats, opts), opts).replace(`.${candidate}`, "&").replace("{ & }", "").trim()
            );
            if (manualFormatStrings.length > 0) {
              result2.push(
                formatVariantSelector(manualFormatStrings, opts).toString().replace(`.${candidate}`, "&")
              );
            }
            return result2;
          }
        });
      }
      return result;
    };
  }
  function markInvalidUtilityCandidate(context, candidate) {
    if (!context.classCache.has(candidate)) {
      return;
    }
    context.notClassCache.add(candidate);
    context.classCache.delete(candidate);
    context.applyClassCache.delete(candidate);
    context.candidateRuleMap.delete(candidate);
    context.candidateRuleCache.delete(candidate);
    context.stylesheetCache = null;
  }
  function markInvalidUtilityNode(context, node) {
    let candidate = node.raws.tailwind.candidate;
    if (!candidate) {
      return;
    }
    for (const entry of context.ruleCache) {
      if (entry[1].raws.tailwind.candidate === candidate) {
        context.ruleCache.delete(entry);
      }
    }
    markInvalidUtilityCandidate(context, candidate);
  }
  function createContext(tailwindConfig2, changedContent = [], root12 = postcss_default.root()) {
    let context = {
      disposables: [],
      ruleCache: /* @__PURE__ */ new Set(),
      candidateRuleCache: /* @__PURE__ */ new Map(),
      classCache: /* @__PURE__ */ new Map(),
      applyClassCache: /* @__PURE__ */ new Map(),
      notClassCache: new Set(tailwindConfig2.blocklist ?? []),
      postCssNodeCache: /* @__PURE__ */ new Map(),
      candidateRuleMap: /* @__PURE__ */ new Map(),
      tailwindConfig: tailwindConfig2,
      changedContent,
      variantMap: /* @__PURE__ */ new Map(),
      stylesheetCache: null,
      variantOptions: /* @__PURE__ */ new Map(),
      markInvalidUtilityCandidate: (candidate) => markInvalidUtilityCandidate(context, candidate),
      markInvalidUtilityNode: (node) => markInvalidUtilityNode(context, node)
    };
    let resolvedPlugins = resolvePlugins(context, root12);
    registerPlugins(resolvedPlugins, context);
    return context;
  }
  function applyImportantSelector(selector, important) {
    let sel = (0, import_postcss_selector_parser6.default)().astSync(selector);
    sel.each((sel2) => {
      let isWrapped = sel2.nodes[0].type === "pseudo" && sel2.nodes[0].value === ":is" && sel2.nodes.every((node) => node.type !== "combinator");
      if (!isWrapped) {
        sel2.nodes = [
          import_postcss_selector_parser6.default.pseudo({
            value: ":is",
            nodes: [sel2.clone()]
          })
        ];
      }
      movePseudos(sel2);
    });
    return `${important} ${sel.toString()}`;
  }
  var classNameParser = (0, import_postcss_selector_parser.default)((selectors) => {
    return selectors.first.filter(({ type }) => type === "class").pop().value;
  });
  function getClassNameFromSelector(selector) {
    return classNameParser.transformSync(selector);
  }
  function* candidatePermutations(candidate) {
    let lastIndex = Infinity;
    while (lastIndex >= 0) {
      let dashIdx;
      let wasSlash = false;
      if (lastIndex === Infinity && candidate.endsWith("]")) {
        let bracketIdx = candidate.indexOf("[");
        if (candidate[bracketIdx - 1] === "-") {
          dashIdx = bracketIdx - 1;
        } else if (candidate[bracketIdx - 1] === "/") {
          dashIdx = bracketIdx - 1;
          wasSlash = true;
        } else {
          dashIdx = -1;
        }
      } else if (lastIndex === Infinity && candidate.includes("/")) {
        dashIdx = candidate.lastIndexOf("/");
        wasSlash = true;
      } else {
        dashIdx = candidate.lastIndexOf("-", lastIndex);
      }
      if (dashIdx < 0) {
        break;
      }
      let prefix3 = candidate.slice(0, dashIdx);
      let modifier = candidate.slice(wasSlash ? dashIdx : dashIdx + 1);
      lastIndex = dashIdx - 1;
      if (prefix3 === "" || modifier === "/") {
        continue;
      }
      yield [prefix3, modifier];
    }
  }
  function applyPrefix(matches, context) {
    if (matches.length === 0 || context.tailwindConfig.prefix === "") {
      return matches;
    }
    for (let match of matches) {
      let [meta] = match;
      if (meta.options.respectPrefix) {
        let container = postcss_default.root({ nodes: [match[1].clone()] });
        let classCandidate = match[1].raws.tailwind.classCandidate;
        container.walkRules((r2) => {
          let shouldPrependNegative = classCandidate.startsWith("-");
          r2.selector = prefixSelector_default(
            context.tailwindConfig.prefix,
            r2.selector,
            shouldPrependNegative
          );
        });
        match[1] = container.nodes[0];
      }
    }
    return matches;
  }
  function applyImportant(matches, classCandidate) {
    if (matches.length === 0) {
      return matches;
    }
    let result = [];
    function isInKeyframes(rule2) {
      return rule2.parent && rule2.parent.type === "atrule" && rule2.parent.name === "keyframes";
    }
    for (let [meta, rule2] of matches) {
      let container = postcss_default.root({ nodes: [rule2.clone()] });
      container.walkRules((r2) => {
        if (isInKeyframes(r2)) {
          return;
        }
        let ast = (0, import_postcss_selector_parser.default)().astSync(r2.selector);
        ast.each((sel) => eliminateIrrelevantSelectors(sel, classCandidate));
        updateAllClasses(
          ast,
          (className) => className === classCandidate ? `!${className}` : className
        );
        r2.selector = ast.toString();
        r2.walkDecls((d) => d.important = true);
      });
      result.push([{ ...meta, important: true }, container.nodes[0]]);
    }
    return result;
  }
  function applyVariant(variant, matches, context) {
    if (matches.length === 0) {
      return matches;
    }
    let args = { modifier: null, value: NONE };
    {
      let [baseVariant, ...modifiers] = splitAtTopLevelOnly(variant, "/");
      if (modifiers.length > 1) {
        baseVariant = baseVariant + "/" + modifiers.slice(0, -1).join("/");
        modifiers = modifiers.slice(-1);
      }
      if (modifiers.length && !context.variantMap.has(variant)) {
        variant = baseVariant;
        args.modifier = modifiers[0];
        if (!flagEnabled(context.tailwindConfig, "generalizedModifiers")) {
          return [];
        }
      }
    }
    if (variant.endsWith("]") && !variant.startsWith("[")) {
      let match = /(.)(-?)\[(.*)\]/g.exec(variant);
      if (match) {
        let [, char, separator, value2] = match;
        if (char === "@" && separator === "-")
          return [];
        if (char !== "@" && separator === "")
          return [];
        variant = variant.replace(`${separator}[${value2}]`, "");
        args.value = value2;
      }
    }
    if (isArbitraryValue2(variant) && !context.variantMap.has(variant)) {
      let sort = context.offsets.recordVariant(variant);
      let selector = normalize(variant.slice(1, -1));
      let selectors = splitAtTopLevelOnly(selector, ",");
      if (selectors.length > 1) {
        return [];
      }
      if (!selectors.every(isValidVariantFormatString)) {
        return [];
      }
      let records = selectors.map((sel, idx) => [
        context.offsets.applyParallelOffset(sort, idx),
        parseVariant(sel.trim())
      ]);
      context.variantMap.set(variant, records);
    }
    if (context.variantMap.has(variant)) {
      let isArbitraryVariant = isArbitraryValue2(variant);
      let internalFeatures = context.variantOptions.get(variant)?.[INTERNAL_FEATURES] ?? {};
      let variantFunctionTuples = context.variantMap.get(variant).slice();
      let result = [];
      let respectPrefix = (() => {
        if (isArbitraryVariant)
          return false;
        if (internalFeatures.respectPrefix === false)
          return false;
        return true;
      })();
      for (let [meta, rule2] of matches) {
        if (meta.layer === "user") {
          continue;
        }
        let container = postcss_default.root({ nodes: [rule2.clone()] });
        for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples) {
          let prepareBackup = function() {
            if (clone.raws.neededBackup) {
              return;
            }
            clone.raws.neededBackup = true;
            clone.walkRules((rule22) => rule22.raws.originalSelector = rule22.selector);
          }, modifySelectors = function(modifierFunction) {
            prepareBackup();
            clone.each((rule22) => {
              if (rule22.type !== "rule") {
                return;
              }
              rule22.selectors = rule22.selectors.map((selector) => {
                return modifierFunction({
                  get className() {
                    return getClassNameFromSelector(selector);
                  },
                  selector
                });
              });
            });
            return clone;
          };
          let clone = (containerFromArray ?? container).clone();
          let collectedFormats = [];
          let ruleWithVariant = variantFunction({
            get container() {
              prepareBackup();
              return clone;
            },
            separator: context.tailwindConfig.separator,
            modifySelectors,
            wrap(wrapper) {
              let nodes = clone.nodes;
              clone.removeAll();
              wrapper.append(nodes);
              clone.append(wrapper);
            },
            format(selectorFormat) {
              collectedFormats.push({
                format: selectorFormat,
                respectPrefix
              });
            },
            args
          });
          if (Array.isArray(ruleWithVariant)) {
            for (let [idx, variantFunction2] of ruleWithVariant.entries()) {
              variantFunctionTuples.push([
                context.offsets.applyParallelOffset(variantSort, idx),
                variantFunction2,
                clone.clone()
              ]);
            }
            continue;
          }
          if (typeof ruleWithVariant === "string") {
            collectedFormats.push({
              format: ruleWithVariant,
              respectPrefix
            });
          }
          if (ruleWithVariant === null) {
            continue;
          }
          if (clone.raws.neededBackup) {
            delete clone.raws.neededBackup;
            clone.walkRules((rule22) => {
              let before = rule22.raws.originalSelector;
              if (!before)
                return;
              delete rule22.raws.originalSelector;
              if (before === rule22.selector)
                return;
              let modified = rule22.selector;
              let rebuiltBase = (0, import_postcss_selector_parser.default)((selectors) => {
                selectors.walkClasses((classNode) => {
                  classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;
                });
              }).processSync(before);
              collectedFormats.push({
                format: modified.replace(rebuiltBase, "&"),
                respectPrefix
              });
              rule22.selector = before;
            });
          }
          clone.nodes[0].raws.tailwind = { ...clone.nodes[0].raws.tailwind, parentLayer: meta.layer };
          let withOffset = [
            {
              ...meta,
              sort: context.offsets.applyVariantOffset(
                meta.sort,
                variantSort,
                Object.assign(args, context.variantOptions.get(variant))
              ),
              collectedFormats: (meta.collectedFormats ?? []).concat(collectedFormats)
            },
            clone.nodes[0]
          ];
          result.push(withOffset);
        }
      }
      return result;
    }
    return [];
  }
  function parseRules(rule2, cache2, options = {}) {
    if (!isPlainObject(rule2) && !Array.isArray(rule2)) {
      return [[rule2], options];
    }
    if (Array.isArray(rule2)) {
      return parseRules(rule2[0], cache2, rule2[1]);
    }
    if (!cache2.has(rule2)) {
      cache2.set(rule2, parseObjectStyles(rule2));
    }
    return [cache2.get(rule2), options];
  }
  var IS_VALID_PROPERTY_NAME = /^[a-z_-]/;
  function isValidPropName(name) {
    return IS_VALID_PROPERTY_NAME.test(name);
  }
  function looksLikeUri(declaration) {
    if (!declaration.includes("://")) {
      return false;
    }
    try {
      const url2 = new URL(declaration);
      return url2.scheme !== "" && url2.host !== "";
    } catch (err) {
      return false;
    }
  }
  function isParsableNode(node) {
    let isParsable = true;
    node.walkDecls((decl2) => {
      if (!isParsableCssValue(decl2.prop, decl2.value)) {
        isParsable = false;
        return false;
      }
    });
    return isParsable;
  }
  function isParsableCssValue(property, value2) {
    if (looksLikeUri(`${property}:${value2}`)) {
      return false;
    }
    try {
      postcss_default.parse(`a{${property}:${value2}}`).toResult();
      return true;
    } catch (err) {
      return false;
    }
  }
  function extractArbitraryProperty(classCandidate, context) {
    let [, property, value2] = classCandidate.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/) ?? [];
    if (value2 === void 0) {
      return null;
    }
    if (!isValidPropName(property)) {
      return null;
    }
    if (!isSyntacticallyValidPropertyValue(value2)) {
      return null;
    }
    let normalized = normalize(value2, { property });
    if (!isParsableCssValue(property, normalized)) {
      return null;
    }
    let sort = context.offsets.arbitraryProperty();
    return [
      [
        { sort, layer: "utilities" },
        () => ({
          [asClass(classCandidate)]: {
            [property]: normalized
          }
        })
      ]
    ];
  }
  function* resolveMatchedPlugins(classCandidate, context) {
    if (context.candidateRuleMap.has(classCandidate)) {
      yield [context.candidateRuleMap.get(classCandidate), "DEFAULT"];
    }
    yield* function* (arbitraryPropertyRule) {
      if (arbitraryPropertyRule !== null) {
        yield [arbitraryPropertyRule, "DEFAULT"];
      }
    }(extractArbitraryProperty(classCandidate, context));
    let candidatePrefix = classCandidate;
    let negative = false;
    const twConfigPrefix = context.tailwindConfig.prefix;
    const twConfigPrefixLen = twConfigPrefix.length;
    const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);
    if (candidatePrefix[twConfigPrefixLen] === "-" && hasMatchingPrefix) {
      negative = true;
      candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);
    }
    if (negative && context.candidateRuleMap.has(candidatePrefix)) {
      yield [context.candidateRuleMap.get(candidatePrefix), "-DEFAULT"];
    }
    for (let [prefix3, modifier] of candidatePermutations(candidatePrefix)) {
      if (context.candidateRuleMap.has(prefix3)) {
        yield [context.candidateRuleMap.get(prefix3), negative ? `-${modifier}` : modifier];
      }
    }
  }
  function splitWithSeparator(input, separator) {
    if (input === NOT_ON_DEMAND) {
      return [NOT_ON_DEMAND];
    }
    return splitAtTopLevelOnly(input, separator);
  }
  function* recordCandidates(matches, classCandidate) {
    for (const match of matches) {
      match[1].raws.tailwind = {
        ...match[1].raws.tailwind,
        classCandidate,
        preserveSource: match[0].options?.preserveSource ?? false
      };
      yield match;
    }
  }
  function* resolveMatches(candidate, context) {
    let separator = context.tailwindConfig.separator;
    let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();
    let important = false;
    if (classCandidate.startsWith("!")) {
      important = true;
      classCandidate = classCandidate.slice(1);
    }
    for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {
      let matches = [];
      let typesByMatches = /* @__PURE__ */ new Map();
      let [plugins, modifier] = matchedPlugins;
      let isOnlyPlugin = plugins.length === 1;
      for (let [sort, plugin2] of plugins) {
        let matchesPerPlugin = [];
        if (typeof plugin2 === "function") {
          for (let ruleSet of [].concat(plugin2(modifier, { isOnlyPlugin }))) {
            let [rules2, options] = parseRules(ruleSet, context.postCssNodeCache);
            for (let rule2 of rules2) {
              matchesPerPlugin.push([{ ...sort, options: { ...sort.options, ...options } }, rule2]);
            }
          }
        } else if (modifier === "DEFAULT" || modifier === "-DEFAULT") {
          let ruleSet = plugin2;
          let [rules2, options] = parseRules(ruleSet, context.postCssNodeCache);
          for (let rule2 of rules2) {
            matchesPerPlugin.push([{ ...sort, options: { ...sort.options, ...options } }, rule2]);
          }
        }
        if (matchesPerPlugin.length > 0) {
          let matchingTypes = Array.from(
            getMatchingTypes(
              sort.options?.types ?? [],
              modifier,
              sort.options ?? {},
              context.tailwindConfig
            )
          ).map(([_, type]) => type);
          if (matchingTypes.length > 0) {
            typesByMatches.set(matchesPerPlugin, matchingTypes);
          }
          matches.push(matchesPerPlugin);
        }
      }
      if (isArbitraryValue2(modifier)) {
        if (matches.length > 1) {
          let findFallback = function(matches2) {
            if (matches2.length === 1) {
              return matches2[0];
            }
            return matches2.find((rules2) => {
              let matchingTypes = typesByMatches.get(rules2);
              return rules2.some(([{ options }, rule2]) => {
                if (!isParsableNode(rule2)) {
                  return false;
                }
                return options.types.some(
                  ({ type, preferOnConflict }) => matchingTypes.includes(type) && preferOnConflict
                );
              });
            });
          };
          let [withAny, withoutAny] = matches.reduce(
            (group, plugin2) => {
              let hasAnyType = plugin2.some(
                ([{ options }]) => options.types.some(({ type }) => type === "any")
              );
              if (hasAnyType) {
                group[0].push(plugin2);
              } else {
                group[1].push(plugin2);
              }
              return group;
            },
            [[], []]
          );
          let fallback2 = findFallback(withoutAny) ?? findFallback(withAny);
          if (fallback2) {
            matches = [fallback2];
          } else {
            let typesPerPlugin = matches.map(
              (match) => /* @__PURE__ */ new Set([...typesByMatches.get(match) ?? []])
            );
            for (let pluginTypes of typesPerPlugin) {
              for (let type of pluginTypes) {
                let removeFromOwnGroup = false;
                for (let otherGroup of typesPerPlugin) {
                  if (pluginTypes === otherGroup)
                    continue;
                  if (otherGroup.has(type)) {
                    otherGroup.delete(type);
                    removeFromOwnGroup = true;
                  }
                }
                if (removeFromOwnGroup)
                  pluginTypes.delete(type);
              }
            }
            let messages = [];
            for (let [idx, group] of typesPerPlugin.entries()) {
              for (let type of group) {
                let rules2 = matches[idx].map(([, rule2]) => rule2).flat().map(
                  (rule2) => rule2.toString().split("\n").slice(1, -1).map((line) => line.trim()).map((x) => `      ${x}`).join("\n")
                ).join("\n\n");
                messages.push(
                  `  Use \`${candidate.replace("[", `[${type}:`)}\` for \`${rules2.trim()}\``
                );
                break;
              }
            }
            log_default.warn([
              `The class \`${candidate}\` is ambiguous and matches multiple utilities.`,
              ...messages,
              `If this is content and not a class, replace it with \`${candidate.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`
            ]);
            continue;
          }
        }
        matches = matches.map((list22) => list22.filter((match) => isParsableNode(match[1])));
      }
      matches = matches.flat();
      matches = Array.from(recordCandidates(matches, classCandidate));
      matches = applyPrefix(matches, context);
      if (important) {
        matches = applyImportant(matches, classCandidate);
      }
      for (let variant of variants) {
        matches = applyVariant(variant, matches, context);
      }
      for (let match of matches) {
        match[1].raws.tailwind = { ...match[1].raws.tailwind, candidate };
        match = applyFinalFormat(match, { context, candidate });
        if (match === null) {
          continue;
        }
        yield match;
      }
    }
  }
  function applyFinalFormat(match, { context, candidate }) {
    if (!match[0].collectedFormats) {
      return match;
    }
    let isValid = true;
    let finalFormat;
    try {
      finalFormat = formatVariantSelector(match[0].collectedFormats, {
        context,
        candidate
      });
    } catch {
      return null;
    }
    let container = postcss_default.root({ nodes: [match[1].clone()] });
    container.walkRules((rule2) => {
      if (inKeyframes(rule2)) {
        return;
      }
      try {
        let selector = finalizeSelector(rule2.selector, finalFormat, {
          candidate,
          context
        });
        if (selector === null) {
          rule2.remove();
          return;
        }
        rule2.selector = selector;
      } catch {
        isValid = false;
        return false;
      }
    });
    if (!isValid) {
      return null;
    }
    if (container.nodes.length === 0) {
      return null;
    }
    match[1] = container.nodes[0];
    return match;
  }
  function inKeyframes(rule2) {
    return rule2.parent && rule2.parent.type === "atrule" && rule2.parent.name === "keyframes";
  }
  function getImportantStrategy(important) {
    if (important === true) {
      return (rule2) => {
        if (inKeyframes(rule2)) {
          return;
        }
        rule2.walkDecls((d) => {
          if (d.parent.type === "rule" && !inKeyframes(d.parent)) {
            d.important = true;
          }
        });
      };
    }
    if (typeof important === "string") {
      return (rule2) => {
        if (inKeyframes(rule2)) {
          return;
        }
        rule2.selectors = rule2.selectors.map((selector) => {
          return applyImportantSelector(selector, important);
        });
      };
    }
  }
  function generateRules(candidates, context, isSorting = false) {
    let allRules = [];
    let strategy = getImportantStrategy(context.tailwindConfig.important);
    for (let candidate of candidates) {
      if (context.notClassCache.has(candidate)) {
        continue;
      }
      if (context.candidateRuleCache.has(candidate)) {
        allRules = allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));
        continue;
      }
      let matches = Array.from(resolveMatches(candidate, context));
      if (matches.length === 0) {
        context.notClassCache.add(candidate);
        continue;
      }
      context.classCache.set(candidate, matches);
      let rules2 = context.candidateRuleCache.get(candidate) ?? /* @__PURE__ */ new Set();
      context.candidateRuleCache.set(candidate, rules2);
      for (const match of matches) {
        let [{ sort, options }, rule2] = match;
        if (options.respectImportant && strategy) {
          let container = postcss_default.root({ nodes: [rule2.clone()] });
          container.walkRules(strategy);
          rule2 = container.nodes[0];
        }
        let newEntry = [sort, isSorting ? rule2.clone() : rule2];
        rules2.add(newEntry);
        context.ruleCache.add(newEntry);
        allRules.push(newEntry);
      }
    }
    return allRules;
  }
  function isArbitraryValue2(input) {
    return input.startsWith("[") && input.endsWith("]");
  }
  function cloneNodes(nodes, source2 = void 0, raws = void 0) {
    return nodes.map((node) => {
      let cloned = node.clone();
      if (raws !== void 0) {
        cloned.raws.tailwind = {
          ...cloned.raws.tailwind,
          ...raws
        };
      }
      if (source2 !== void 0) {
        traverse(cloned, (node2) => {
          let shouldPreserveSource = node2.raws.tailwind?.preserveSource === true && node2.source;
          if (shouldPreserveSource) {
            return false;
          }
          node2.source = source2;
        });
      }
      return cloned;
    });
  }
  function traverse(node, onNode) {
    if (onNode(node) !== false) {
      node.each?.((child2) => traverse(child2, onNode));
    }
  }
  var REGEX_SPECIAL = /[\\^$.*+?()[\]{}|]/g;
  var REGEX_HAS_SPECIAL = RegExp(REGEX_SPECIAL.source);
  function toSource(source2) {
    source2 = Array.isArray(source2) ? source2 : [source2];
    source2 = source2.map((item) => item instanceof RegExp ? item.source : item);
    return source2.join("");
  }
  function pattern(source2) {
    return new RegExp(toSource(source2), "g");
  }
  function any(sources) {
    return `(?:${sources.map(toSource).join("|")})`;
  }
  function optional(source2) {
    return `(?:${toSource(source2)})?`;
  }
  function escape(string) {
    return string && REGEX_HAS_SPECIAL.test(string) ? string.replace(REGEX_SPECIAL, "\\$&") : string || "";
  }
  function defaultExtractor(context) {
    let patterns = Array.from(buildRegExps(context));
    return (content) => {
      let results = [];
      for (let pattern2 of patterns) {
        for (let result of content.match(pattern2) ?? []) {
          results.push(clipAtBalancedParens(result));
        }
      }
      return results;
    };
  }
  function* buildRegExps(context) {
    let separator = context.tailwindConfig.separator;
    let prefix3 = context.tailwindConfig.prefix !== "" ? optional(pattern([/-?/, escape(context.tailwindConfig.prefix)])) : "";
    let utility = any([
      /\[[^\s:'"`]+:[^\s\[\]]+\]/,
      /\[[^\s:'"`\]]+:[^\s]+?\[[^\s]+\][^\s]+?\]/,
      pattern([
        any([
          /-?(?:\w+)/,
          /@(?:\w+)/
        ]),
        optional(
          any([
            pattern([
              any([
                /-(?:\w+-)*\['[^\s]+'\]/,
                /-(?:\w+-)*\["[^\s]+"\]/,
                /-(?:\w+-)*\[`[^\s]+`\]/,
                /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s:\[\]]+\]/
              ]),
              /(?![{([]])/,
              /(?:\/[^\s'"`\\><$]*)?/
            ]),
            pattern([
              any([
                /-(?:\w+-)*\['[^\s]+'\]/,
                /-(?:\w+-)*\["[^\s]+"\]/,
                /-(?:\w+-)*\[`[^\s]+`\]/,
                /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s\[\]]+\]/
              ]),
              /(?![{([]])/,
              /(?:\/[^\s'"`\\$]*)?/
            ]),
            /[-\/][^\s'"`\\$={><]*/
          ])
        )
      ])
    ]);
    let variantPatterns = [
      any([
        pattern([/@\[[^\s"'`]+\](\/[^\s"'`]+)?/, separator]),
        pattern([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]\/\w+/, separator]),
        pattern([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, separator]),
        pattern([/[^\s"'`\[\\]+/, separator])
      ]),
      any([
        pattern([/([^\s"'`\[\\]+-)?\[[^\s`]+\]\/\w+/, separator]),
        pattern([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, separator]),
        pattern([/[^\s`\[\\]+/, separator])
      ])
    ];
    for (const variantPattern of variantPatterns) {
      yield pattern([
        "((?=((",
        variantPattern,
        ")+))\\2)?",
        /!?/,
        prefix3,
        utility
      ]);
    }
    yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
  }
  var SPECIALS = /([\[\]'"`])([^\[\]'"`])?/g;
  var ALLOWED_CLASS_CHARACTERS = /[^"'`\s<>\]]+/;
  function clipAtBalancedParens(input) {
    if (!input.includes("-[")) {
      return input;
    }
    let depth = 0;
    let openStringTypes = [];
    let matches = input.matchAll(SPECIALS);
    matches = Array.from(matches).flatMap((match) => {
      const [, ...groups] = match;
      return groups.map(
        (group, idx) => Object.assign([], match, {
          index: match.index + idx,
          0: group
        })
      );
    });
    for (let match of matches) {
      let char = match[0];
      let inStringType = openStringTypes[openStringTypes.length - 1];
      if (char === inStringType) {
        openStringTypes.pop();
      } else if (char === "'" || char === '"' || char === "`") {
        openStringTypes.push(char);
      }
      if (inStringType) {
        continue;
      } else if (char === "[") {
        depth++;
        continue;
      } else if (char === "]") {
        depth--;
        continue;
      }
      if (depth < 0) {
        return input.substring(0, match.index - 1);
      }
      if (depth === 0 && !ALLOWED_CLASS_CHARACTERS.test(char)) {
        return input.substring(0, match.index);
      }
    }
    return input;
  }
  var env2 = env;
  var builtInExtractors = {
    DEFAULT: defaultExtractor
  };
  var builtInTransformers = {
    DEFAULT: (content) => content,
    svelte: (content) => content.replace(/(?:^|\s)class:/g, " ")
  };
  function getExtractor(context, fileExtension) {
    let extractors = context.tailwindConfig.content.extract;
    return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);
  }
  function getTransformer(tailwindConfig2, fileExtension) {
    let transformers = tailwindConfig2.content.transform;
    return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;
  }
  var extractorCache = /* @__PURE__ */ new WeakMap();
  function getClassCandidates(content, extractor, candidates, seen) {
    if (!extractorCache.has(extractor)) {
      extractorCache.set(extractor, new import_quick_lru.default({ maxSize: 25e3 }));
    }
    for (let line of content.split("\n")) {
      line = line.trim();
      if (seen.has(line)) {
        continue;
      }
      seen.add(line);
      if (extractorCache.get(extractor).has(line)) {
        for (let match of extractorCache.get(extractor).get(line)) {
          candidates.add(match);
        }
      } else {
        let extractorMatches = extractor(line).filter((s) => s !== "!*");
        let lineMatchesSet = new Set(extractorMatches);
        for (let match of lineMatchesSet) {
          candidates.add(match);
        }
        extractorCache.get(extractor).set(line, lineMatchesSet);
      }
    }
  }
  function buildStylesheet(rules2, context) {
    let sortedRules = context.offsets.sort(rules2);
    let returnValue = {
      base: /* @__PURE__ */ new Set(),
      defaults: /* @__PURE__ */ new Set(),
      components: /* @__PURE__ */ new Set(),
      utilities: /* @__PURE__ */ new Set(),
      variants: /* @__PURE__ */ new Set()
    };
    for (let [sort, rule2] of sortedRules) {
      returnValue[sort.layer].add(rule2);
    }
    return returnValue;
  }
  function expandTailwindAtRules(context) {
    return async (root12) => {
      let layerNodes = {
        base: null,
        components: null,
        utilities: null,
        variants: null
      };
      root12.walkAtRules((rule2) => {
        if (rule2.name === "tailwind") {
          if (Object.keys(layerNodes).includes(rule2.params)) {
            layerNodes[rule2.params] = rule2;
          }
        }
      });
      if (Object.values(layerNodes).every((n) => n === null)) {
        return root12;
      }
      let candidates = /* @__PURE__ */ new Set([...context.candidates ?? [], NOT_ON_DEMAND]);
      let seen = /* @__PURE__ */ new Set();
      env2.DEBUG && console.time("Reading changed files");
      if (false) {
        for (let candidate of null.parseCandidateStringsFromFiles(
          context.changedContent
        )) {
          candidates.add(candidate);
        }
      } else {
        let regexParserContent = [];
        for (let item of context.changedContent) {
          let transformer = getTransformer(context.tailwindConfig, item.extension);
          let extractor = getExtractor(context, item.extension);
          regexParserContent.push([item, { transformer, extractor }]);
        }
        const BATCH_SIZE = 500;
        for (let i = 0; i < regexParserContent.length; i += BATCH_SIZE) {
          let batch = regexParserContent.slice(i, i + BATCH_SIZE);
          await Promise.all(
            batch.map(async ([{ file, content }, { transformer, extractor }]) => {
              content = file ? await fs_default.promises.readFile(file, "utf8") : content;
              getClassCandidates(transformer(content), extractor, candidates, seen);
            })
          );
        }
      }
      env2.DEBUG && console.timeEnd("Reading changed files");
      let classCacheCount = context.classCache.size;
      env2.DEBUG && console.time("Generate rules");
      env2.DEBUG && console.time("Sorting candidates");
      let sortedCandidates = false ? candidates : new Set(
        [...candidates].sort((a, z) => {
          if (a === z)
            return 0;
          if (a < z)
            return -1;
          return 1;
        })
      );
      env2.DEBUG && console.timeEnd("Sorting candidates");
      generateRules(sortedCandidates, context);
      env2.DEBUG && console.timeEnd("Generate rules");
      env2.DEBUG && console.time("Build stylesheet");
      if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {
        context.stylesheetCache = buildStylesheet([...context.ruleCache], context);
      }
      env2.DEBUG && console.timeEnd("Build stylesheet");
      let {
        defaults: defaultNodes,
        base: baseNodes,
        components: componentNodes,
        utilities: utilityNodes,
        variants: screenNodes
      } = context.stylesheetCache;
      if (layerNodes.base) {
        layerNodes.base.before(
          cloneNodes([...baseNodes, ...defaultNodes], layerNodes.base.source, {
            layer: "base"
          })
        );
        layerNodes.base.remove();
      }
      if (layerNodes.components) {
        layerNodes.components.before(
          cloneNodes([...componentNodes], layerNodes.components.source, {
            layer: "components"
          })
        );
        layerNodes.components.remove();
      }
      if (layerNodes.utilities) {
        layerNodes.utilities.before(
          cloneNodes([...utilityNodes], layerNodes.utilities.source, {
            layer: "utilities"
          })
        );
        layerNodes.utilities.remove();
      }
      const variantNodes = Array.from(screenNodes).filter((node) => {
        const parentLayer = node.raws.tailwind?.parentLayer;
        if (parentLayer === "components") {
          return layerNodes.components !== null;
        }
        if (parentLayer === "utilities") {
          return layerNodes.utilities !== null;
        }
        return true;
      });
      if (layerNodes.variants) {
        layerNodes.variants.before(
          cloneNodes(variantNodes, layerNodes.variants.source, {
            layer: "variants"
          })
        );
        layerNodes.variants.remove();
      } else if (variantNodes.length > 0) {
        root12.append(
          cloneNodes(variantNodes, root12.source, {
            layer: "variants"
          })
        );
      }
      root12.source.end = root12.source.end ?? root12.source.start;
      const hasUtilityVariants = variantNodes.some(
        (node) => node.raws.tailwind?.parentLayer === "utilities"
      );
      if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {
        log_default.warn("content-problems", [
          "No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.",
          "https://tailwindcss.com/docs/content-configuration"
        ]);
      }
      if (env2.DEBUG) {
        console.log("Potential classes: ", candidates.size);
        console.log("Active contexts: ", contextSourcesMap.size);
      }
      context.changedContent = [];
      root12.walkAtRules("layer", (rule2) => {
        if (Object.keys(layerNodes).includes(rule2.params)) {
          rule2.remove();
        }
      });
    };
  }
  function extractClasses(node) {
    let groups = /* @__PURE__ */ new Map();
    let container = postcss_default.root({ nodes: [node.clone()] });
    container.walkRules((rule2) => {
      (0, import_postcss_selector_parser7.default)((selectors) => {
        selectors.walkClasses((classSelector) => {
          let parentSelector = classSelector.parent.toString();
          let classes2 = groups.get(parentSelector);
          if (!classes2) {
            groups.set(parentSelector, classes2 = /* @__PURE__ */ new Set());
          }
          classes2.add(classSelector.value);
        });
      }).processSync(rule2.selector);
    });
    let normalizedGroups = Array.from(groups.values(), (classes2) => Array.from(classes2));
    let classes = normalizedGroups.flat();
    return Object.assign(classes, { groups: normalizedGroups });
  }
  var selectorExtractor = (0, import_postcss_selector_parser7.default)();
  function extractSelectors(ruleSelectors) {
    return selectorExtractor.astSync(ruleSelectors);
  }
  function extractBaseCandidates(candidates, separator) {
    let baseClasses = /* @__PURE__ */ new Set();
    for (let candidate of candidates) {
      baseClasses.add(candidate.split(separator).pop());
    }
    return Array.from(baseClasses);
  }
  function prefix2(context, selector) {
    let prefix3 = context.tailwindConfig.prefix;
    return typeof prefix3 === "function" ? prefix3(selector) : prefix3 + selector;
  }
  function* pathToRoot(node) {
    yield node;
    while (node.parent) {
      yield node.parent;
      node = node.parent;
    }
  }
  function shallowClone(node, overrides = {}) {
    let children = node.nodes;
    node.nodes = [];
    let tmp = node.clone(overrides);
    node.nodes = children;
    return tmp;
  }
  function nestedClone(node) {
    for (let parent of pathToRoot(node)) {
      if (node === parent) {
        continue;
      }
      if (parent.type === "root") {
        break;
      }
      node = shallowClone(parent, {
        nodes: [node]
      });
    }
    return node;
  }
  function buildLocalApplyCache(root12, context) {
    let cache2 = /* @__PURE__ */ new Map();
    root12.walkRules((rule2) => {
      for (let node of pathToRoot(rule2)) {
        if (node.raws.tailwind?.layer !== void 0) {
          return;
        }
      }
      let container = nestedClone(rule2);
      let sort = context.offsets.create("user");
      for (let className of extractClasses(rule2)) {
        let list22 = cache2.get(className) || [];
        cache2.set(className, list22);
        list22.push([
          {
            layer: "user",
            sort,
            important: false
          },
          container
        ]);
      }
    });
    return cache2;
  }
  function buildApplyCache(applyCandidates, context) {
    for (let candidate of applyCandidates) {
      if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {
        continue;
      }
      if (context.classCache.has(candidate)) {
        context.applyClassCache.set(
          candidate,
          context.classCache.get(candidate).map(([meta, rule2]) => [meta, rule2.clone()])
        );
        continue;
      }
      let matches = Array.from(resolveMatches(candidate, context));
      if (matches.length === 0) {
        context.notClassCache.add(candidate);
        continue;
      }
      context.applyClassCache.set(candidate, matches);
    }
    return context.applyClassCache;
  }
  function lazyCache(buildCacheFn) {
    let cache2 = null;
    return {
      get: (name) => {
        cache2 = cache2 || buildCacheFn();
        return cache2.get(name);
      },
      has: (name) => {
        cache2 = cache2 || buildCacheFn();
        return cache2.has(name);
      }
    };
  }
  function combineCaches(caches) {
    return {
      get: (name) => caches.flatMap((cache2) => cache2.get(name) || []),
      has: (name) => caches.some((cache2) => cache2.has(name))
    };
  }
  function extractApplyCandidates(params) {
    let candidates = params.split(/[\s\t\n]+/g);
    if (candidates[candidates.length - 1] === "!important") {
      return [candidates.slice(0, -1), true];
    }
    return [candidates, false];
  }
  function processApply(root12, context, localCache) {
    let applyCandidates = /* @__PURE__ */ new Set();
    let applies = [];
    root12.walkAtRules("apply", (rule2) => {
      let [candidates] = extractApplyCandidates(rule2.params);
      for (let util of candidates) {
        applyCandidates.add(util);
      }
      applies.push(rule2);
    });
    if (applies.length === 0) {
      return;
    }
    let applyClassCache = combineCaches([localCache, buildApplyCache(applyCandidates, context)]);
    function replaceSelector(selector, utilitySelectors, candidate) {
      let selectorList = extractSelectors(selector);
      let utilitySelectorsList = extractSelectors(utilitySelectors);
      let candidateList = extractSelectors(`.${escapeClassName(candidate)}`);
      let candidateClass = candidateList.nodes[0].nodes[0];
      selectorList.each((sel) => {
        let replaced = /* @__PURE__ */ new Set();
        utilitySelectorsList.each((utilitySelector) => {
          let hasReplaced = false;
          utilitySelector = utilitySelector.clone();
          utilitySelector.walkClasses((node) => {
            if (node.value !== candidateClass.value) {
              return;
            }
            if (hasReplaced) {
              return;
            }
            node.replaceWith(...sel.nodes.map((node2) => node2.clone()));
            replaced.add(utilitySelector);
            hasReplaced = true;
          });
        });
        for (let sel2 of replaced) {
          let groups = [[]];
          for (let node of sel2.nodes) {
            if (node.type === "combinator") {
              groups.push(node);
              groups.push([]);
            } else {
              let last = groups[groups.length - 1];
              last.push(node);
            }
          }
          sel2.nodes = [];
          for (let group of groups) {
            if (Array.isArray(group)) {
              group.sort((a, b) => {
                if (a.type === "tag" && b.type === "class") {
                  return -1;
                } else if (a.type === "class" && b.type === "tag") {
                  return 1;
                } else if (a.type === "class" && b.type === "pseudo" && b.value.startsWith("::")) {
                  return -1;
                } else if (a.type === "pseudo" && a.value.startsWith("::") && b.type === "class") {
                  return 1;
                }
                return 0;
              });
            }
            sel2.nodes = sel2.nodes.concat(group);
          }
        }
        sel.replaceWith(...replaced);
      });
      return selectorList.toString();
    }
    let perParentApplies = /* @__PURE__ */ new Map();
    for (let apply2 of applies) {
      let [candidates] = perParentApplies.get(apply2.parent) || [[], apply2.source];
      perParentApplies.set(apply2.parent, [candidates, apply2.source]);
      let [applyCandidates2, important] = extractApplyCandidates(apply2.params);
      if (apply2.parent.type === "atrule") {
        if (apply2.parent.name === "screen") {
          let screenType = apply2.parent.params;
          throw apply2.error(
            `@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates2.map((c) => `${screenType}:${c}`).join(" ")} instead.`
          );
        }
        throw apply2.error(
          `@apply is not supported within nested at-rules like @${apply2.parent.name}. You can fix this by un-nesting @${apply2.parent.name}.`
        );
      }
      for (let applyCandidate of applyCandidates2) {
        if ([prefix2(context, "group"), prefix2(context, "peer")].includes(applyCandidate)) {
          throw apply2.error(`@apply should not be used with the '${applyCandidate}' utility`);
        }
        if (!applyClassCache.has(applyCandidate)) {
          throw apply2.error(
            `The \`${applyCandidate}\` class does not exist. If \`${applyCandidate}\` is a custom class, make sure it is defined within a \`@layer\` directive.`
          );
        }
        let rules2 = applyClassCache.get(applyCandidate);
        candidates.push([applyCandidate, important, rules2]);
      }
    }
    for (let [parent, [candidates, atApplySource]] of perParentApplies) {
      let siblings = [];
      for (let [applyCandidate, important, rules2] of candidates) {
        let potentialApplyCandidates = [
          applyCandidate,
          ...extractBaseCandidates([applyCandidate], context.tailwindConfig.separator)
        ];
        for (let [meta, node] of rules2) {
          let parentClasses = extractClasses(parent);
          let nodeClasses = extractClasses(node);
          nodeClasses = nodeClasses.groups.filter(
            (classList) => classList.some((className) => potentialApplyCandidates.includes(className))
          ).flat();
          nodeClasses = nodeClasses.concat(
            extractBaseCandidates(nodeClasses, context.tailwindConfig.separator)
          );
          let intersects = parentClasses.some((selector) => nodeClasses.includes(selector));
          if (intersects) {
            throw node.error(
              `You cannot \`@apply\` the \`${applyCandidate}\` utility here because it creates a circular dependency.`
            );
          }
          let root22 = postcss_default.root({ nodes: [node.clone()] });
          root22.walk((node2) => {
            node2.source = atApplySource;
          });
          let canRewriteSelector = node.type !== "atrule" || node.type === "atrule" && node.name !== "keyframes";
          if (canRewriteSelector) {
            root22.walkRules((rule2) => {
              if (!extractClasses(rule2).some((candidate) => candidate === applyCandidate)) {
                rule2.remove();
                return;
              }
              let importantSelector = typeof context.tailwindConfig.important === "string" ? context.tailwindConfig.important : null;
              let isGenerated = parent.raws.tailwind !== void 0;
              let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;
              if (parentSelector === "") {
                parentSelector = parent.selector;
              }
              rule2.selector = replaceSelector(parentSelector, rule2.selector, applyCandidate);
              if (importantSelector && parentSelector !== parent.selector) {
                rule2.selector = applyImportantSelector(rule2.selector, importantSelector);
              }
              rule2.walkDecls((d) => {
                d.important = meta.important || important;
              });
              let selector = (0, import_postcss_selector_parser7.default)().astSync(rule2.selector);
              selector.each((sel) => movePseudos(sel));
              rule2.selector = selector.toString();
            });
          }
          if (!root22.nodes[0]) {
            continue;
          }
          siblings.push([meta.sort, root22.nodes[0]]);
        }
      }
      let nodes = context.offsets.sort(siblings).map((s) => s[1]);
      parent.after(nodes);
    }
    for (let apply2 of applies) {
      if (apply2.parent.nodes.length > 1) {
        apply2.remove();
      } else {
        apply2.parent.remove();
      }
    }
    processApply(root12, context, localCache);
  }
  function expandApplyAtRules(context) {
    return (root12) => {
      let localCache = lazyCache(() => buildLocalApplyCache(root12, context));
      processApply(root12, context, localCache);
    };
  }
  var import_value_parser = __toESM2(require_value_parser());
  function isObject5(input) {
    return typeof input === "object" && input !== null;
  }
  function findClosestExistingPath(theme2, path) {
    let parts = toPath(path);
    do {
      parts.pop();
      if ((0, import_dlv2.default)(theme2, parts) !== void 0)
        break;
    } while (parts.length);
    return parts.length ? parts : void 0;
  }
  function pathToString(path) {
    if (typeof path === "string")
      return path;
    return path.reduce((acc, cur, i) => {
      if (cur.includes("."))
        return `${acc}[${cur}]`;
      return i === 0 ? cur : `${acc}.${cur}`;
    }, "");
  }
  function list2(items) {
    return items.map((key) => `'${key}'`).join(", ");
  }
  function listKeys(obj) {
    return list2(Object.keys(obj));
  }
  function validatePath(config5, path, defaultValue, themeOpts = {}) {
    const pathString = Array.isArray(path) ? pathToString(path) : path.replace(/^['"]+|['"]+$/g, "");
    const pathSegments = Array.isArray(path) ? path : toPath(pathString);
    const value2 = (0, import_dlv2.default)(config5.theme, pathSegments, defaultValue);
    if (value2 === void 0) {
      let error = `'${pathString}' does not exist in your theme config.`;
      const parentSegments = pathSegments.slice(0, -1);
      const parentValue = (0, import_dlv2.default)(config5.theme, parentSegments);
      if (isObject5(parentValue)) {
        const validKeys = Object.keys(parentValue).filter(
          (key) => validatePath(config5, [...parentSegments, key]).isValid
        );
        const suggestion = (0, import_didyoumean.default)(pathSegments[pathSegments.length - 1], validKeys);
        if (suggestion) {
          error += ` Did you mean '${pathToString([...parentSegments, suggestion])}'?`;
        } else if (validKeys.length > 0) {
          error += ` '${pathToString(parentSegments)}' has the following valid keys: ${list2(
            validKeys
          )}`;
        }
      } else {
        const closestPath = findClosestExistingPath(config5.theme, pathString);
        if (closestPath) {
          const closestValue = (0, import_dlv2.default)(config5.theme, closestPath);
          if (isObject5(closestValue)) {
            error += ` '${pathToString(closestPath)}' has the following keys: ${listKeys(
              closestValue
            )}`;
          } else {
            error += ` '${pathToString(closestPath)}' is not an object.`;
          }
        } else {
          error += ` Your theme has the following top-level keys: ${listKeys(config5.theme)}`;
        }
      }
      return {
        isValid: false,
        error
      };
    }
    if (!(typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "function" || value2 instanceof String || value2 instanceof Number || Array.isArray(value2))) {
      let error = `'${pathString}' was found but does not resolve to a string.`;
      if (isObject5(value2)) {
        let validKeys = Object.keys(value2).filter(
          (key) => validatePath(config5, [...pathSegments, key]).isValid
        );
        if (validKeys.length) {
          error += ` Did you mean something like '${pathToString([...pathSegments, validKeys[0]])}'?`;
        }
      }
      return {
        isValid: false,
        error
      };
    }
    const [themeSection] = pathSegments;
    return {
      isValid: true,
      value: transformThemeValue(themeSection)(value2, themeOpts)
    };
  }
  function extractArgs(node, vNodes, functions) {
    vNodes = vNodes.map((vNode) => resolveVNode(node, vNode, functions));
    let args = [""];
    for (let vNode of vNodes) {
      if (vNode.type === "div" && vNode.value === ",") {
        args.push("");
      } else {
        args[args.length - 1] += import_value_parser.default.stringify(vNode);
      }
    }
    return args;
  }
  function resolveVNode(node, vNode, functions) {
    if (vNode.type === "function" && functions[vNode.value] !== void 0) {
      let args = extractArgs(node, vNode.nodes, functions);
      vNode.type = "word";
      vNode.value = functions[vNode.value](node, ...args);
    }
    return vNode;
  }
  function resolveFunctions(node, input, functions) {
    let hasAnyFn = Object.keys(functions).some((fn) => input.includes(`${fn}(`));
    if (!hasAnyFn)
      return input;
    return (0, import_value_parser.default)(input).walk((vNode) => {
      resolveVNode(node, vNode, functions);
    }).toString();
  }
  var nodeTypePropertyMap = {
    atrule: "params",
    decl: "value"
  };
  function* toPaths(path) {
    path = path.replace(/^['"]+|['"]+$/g, "");
    let matches = path.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/);
    let alpha = void 0;
    yield [path, void 0];
    if (matches) {
      path = matches[1];
      alpha = matches[2];
      yield [path, alpha];
    }
  }
  function resolvePath(config5, path, defaultValue) {
    const results = Array.from(toPaths(path)).map(([path2, alpha]) => {
      return Object.assign(validatePath(config5, path2, defaultValue, { opacityValue: alpha }), {
        resolvedPath: path2,
        alpha
      });
    });
    return results.find((result) => result.isValid) ?? results[0];
  }
  function evaluateTailwindFunctions_default(context) {
    let config5 = context.tailwindConfig;
    let functions = {
      theme: (node, path, ...defaultValue) => {
        let { isValid, value: value2, error, alpha } = resolvePath(
          config5,
          path,
          defaultValue.length ? defaultValue : void 0
        );
        if (!isValid) {
          let parentNode = node.parent;
          let candidate = parentNode?.raws.tailwind?.candidate;
          if (parentNode && candidate !== void 0) {
            context.markInvalidUtilityNode(parentNode);
            parentNode.remove();
            log_default.warn("invalid-theme-key-in-class", [
              `The utility \`${candidate}\` contains an invalid theme value and was not generated.`
            ]);
            return;
          }
          throw node.error(error);
        }
        let maybeColor = parseColorFormat(value2);
        let isColorFunction = maybeColor !== void 0 && typeof maybeColor === "function";
        if (alpha !== void 0 || isColorFunction) {
          if (alpha === void 0) {
            alpha = 1;
          }
          value2 = withAlphaValue(maybeColor, alpha, maybeColor);
        }
        return value2;
      },
      screen: (node, screen) => {
        screen = screen.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
        let screens = normalizeScreens(config5.theme.screens);
        let screenDefinition = screens.find(({ name }) => name === screen);
        if (!screenDefinition) {
          throw node.error(`The '${screen}' screen does not exist in your theme.`);
        }
        return buildMediaQuery(screenDefinition);
      }
    };
    return (root12) => {
      root12.walk((node) => {
        let property = nodeTypePropertyMap[node.type];
        if (property === void 0) {
          return;
        }
        node[property] = resolveFunctions(node, node[property], functions);
      });
    };
  }
  function substituteScreenAtRules_default({ tailwindConfig: { theme: theme2 } }) {
    return function(css) {
      css.walkAtRules("screen", (atRule2) => {
        let screen = atRule2.params;
        let screens = normalizeScreens(theme2.screens);
        let screenDefinition = screens.find(({ name }) => name === screen);
        if (!screenDefinition) {
          throw atRule2.error(`No \`${screen}\` screen found.`);
        }
        atRule2.name = "media";
        atRule2.params = buildMediaQuery(screenDefinition);
      });
    };
  }
  var getNode = {
    id(node) {
      return import_postcss_selector_parser8.default.attribute({
        attribute: "id",
        operator: "=",
        value: node.value,
        quoteMark: '"'
      });
    }
  };
  function minimumImpactSelector(nodes) {
    let rest = nodes.filter((node2) => {
      if (node2.type !== "pseudo")
        return true;
      if (node2.nodes.length > 0)
        return true;
      return node2.value.startsWith("::") || [":before", ":after", ":first-line", ":first-letter"].includes(node2.value);
    }).reverse();
    let searchFor = /* @__PURE__ */ new Set(["tag", "class", "id", "attribute"]);
    let splitPointIdx = rest.findIndex((n) => searchFor.has(n.type));
    if (splitPointIdx === -1)
      return rest.reverse().join("").trim();
    let node = rest[splitPointIdx];
    let bestNode = getNode[node.type] ? getNode[node.type](node) : node;
    rest = rest.slice(0, splitPointIdx);
    let combinatorIdx = rest.findIndex((n) => n.type === "combinator" && n.value === ">");
    if (combinatorIdx !== -1) {
      rest.splice(0, combinatorIdx);
      rest.unshift(import_postcss_selector_parser8.default.universal());
    }
    return [bestNode, ...rest.reverse()].join("").trim();
  }
  var elementSelectorParser = (0, import_postcss_selector_parser8.default)((selectors) => {
    return selectors.map((s) => {
      let nodes = s.split((n) => n.type === "combinator" && n.value === " ").pop();
      return minimumImpactSelector(nodes);
    });
  });
  var cache = /* @__PURE__ */ new Map();
  function extractElementSelector(selector) {
    if (!cache.has(selector)) {
      cache.set(selector, elementSelectorParser.transformSync(selector));
    }
    return cache.get(selector);
  }
  function resolveDefaultsAtRules({ tailwindConfig: tailwindConfig2 }) {
    return (root12) => {
      let variableNodeMap = /* @__PURE__ */ new Map();
      let universals = /* @__PURE__ */ new Set();
      root12.walkAtRules("defaults", (rule2) => {
        if (rule2.nodes && rule2.nodes.length > 0) {
          universals.add(rule2);
          return;
        }
        let variable = rule2.params;
        if (!variableNodeMap.has(variable)) {
          variableNodeMap.set(variable, /* @__PURE__ */ new Set());
        }
        variableNodeMap.get(variable).add(rule2.parent);
        rule2.remove();
      });
      if (flagEnabled(tailwindConfig2, "optimizeUniversalDefaults")) {
        for (let universal of universals) {
          let selectorGroups = /* @__PURE__ */ new Map();
          let rules2 = variableNodeMap.get(universal.params) ?? [];
          for (let rule2 of rules2) {
            for (let selector of extractElementSelector(rule2.selector)) {
              let selectorGroupName = selector.includes(":-") || selector.includes("::-") ? selector : "__DEFAULT__";
              let selectors = selectorGroups.get(selectorGroupName) ?? /* @__PURE__ */ new Set();
              selectorGroups.set(selectorGroupName, selectors);
              selectors.add(selector);
            }
          }
          if (flagEnabled(tailwindConfig2, "optimizeUniversalDefaults")) {
            if (selectorGroups.size === 0) {
              universal.remove();
              continue;
            }
            for (let [, selectors] of selectorGroups) {
              let universalRule = postcss_default.rule({
                source: universal.source
              });
              universalRule.selectors = [...selectors];
              universalRule.append(universal.nodes.map((node) => node.clone()));
              universal.before(universalRule);
            }
          }
          universal.remove();
        }
      } else if (universals.size) {
        let universalRule = postcss_default.rule({
          selectors: ["*", "::before", "::after"]
        });
        for (let universal of universals) {
          universalRule.append(universal.nodes);
          if (!universalRule.parent) {
            universal.before(universalRule);
          }
          if (!universalRule.source) {
            universalRule.source = universal.source;
          }
          universal.remove();
        }
        let backdropRule = universalRule.clone({
          selectors: ["::backdrop"]
        });
        universalRule.after(backdropRule);
      }
    };
  }
  var comparisonMap = {
    atrule: ["name", "params"],
    rule: ["selector"]
  };
  var types = new Set(Object.keys(comparisonMap));
  function collapseAdjacentRules() {
    function collapseRulesIn(root12) {
      let currentRule = null;
      root12.each((node) => {
        if (!types.has(node.type)) {
          currentRule = null;
          return;
        }
        if (currentRule === null) {
          currentRule = node;
          return;
        }
        let properties = comparisonMap[node.type];
        if (node.type === "atrule" && node.name === "font-face") {
          currentRule = node;
        } else if (properties.every(
          (property) => (node[property] ?? "").replace(/\s+/g, " ") === (currentRule[property] ?? "").replace(/\s+/g, " ")
        )) {
          if (node.nodes) {
            currentRule.append(node.nodes);
          }
          node.remove();
        } else {
          currentRule = node;
        }
      });
      root12.each((node) => {
        if (node.type === "atrule") {
          collapseRulesIn(node);
        }
      });
    }
    return (root12) => {
      collapseRulesIn(root12);
    };
  }
  function collapseDuplicateDeclarations() {
    return (root12) => {
      root12.walkRules((node) => {
        let seen = /* @__PURE__ */ new Map();
        let droppable = /* @__PURE__ */ new Set([]);
        let byProperty = /* @__PURE__ */ new Map();
        node.walkDecls((decl2) => {
          if (decl2.parent !== node) {
            return;
          }
          if (seen.has(decl2.prop)) {
            if (seen.get(decl2.prop).value === decl2.value) {
              droppable.add(seen.get(decl2.prop));
              seen.set(decl2.prop, decl2);
              return;
            }
            if (!byProperty.has(decl2.prop)) {
              byProperty.set(decl2.prop, /* @__PURE__ */ new Set());
            }
            byProperty.get(decl2.prop).add(seen.get(decl2.prop));
            byProperty.get(decl2.prop).add(decl2);
          }
          seen.set(decl2.prop, decl2);
        });
        for (let decl2 of droppable) {
          decl2.remove();
        }
        for (let declarations of byProperty.values()) {
          let byUnit = /* @__PURE__ */ new Map();
          for (let decl2 of declarations) {
            let unit = resolveUnit(decl2.value);
            if (unit === null) {
              continue;
            }
            if (!byUnit.has(unit)) {
              byUnit.set(unit, /* @__PURE__ */ new Set());
            }
            byUnit.get(unit).add(decl2);
          }
          for (let declarations2 of byUnit.values()) {
            let removableDeclarations = Array.from(declarations2).slice(0, -1);
            for (let decl2 of removableDeclarations) {
              decl2.remove();
            }
          }
        }
      });
    };
  }
  var UNITLESS_NUMBER = Symbol("unitless-number");
  function resolveUnit(input) {
    let result = /^-?\d*.?\d+([\w%]+)?$/g.exec(input);
    if (result) {
      return result[1] ?? UNITLESS_NUMBER;
    }
    return null;
  }
  function partitionRules(root12) {
    if (!root12.walkAtRules)
      return;
    let applyParents = /* @__PURE__ */ new Set();
    root12.walkAtRules("apply", (rule2) => {
      applyParents.add(rule2.parent);
    });
    if (applyParents.size === 0) {
      return;
    }
    for (let rule2 of applyParents) {
      let nodeGroups = [];
      let lastGroup = [];
      for (let node of rule2.nodes) {
        if (node.type === "atrule" && node.name === "apply") {
          if (lastGroup.length > 0) {
            nodeGroups.push(lastGroup);
            lastGroup = [];
          }
          nodeGroups.push([node]);
        } else {
          lastGroup.push(node);
        }
      }
      if (lastGroup.length > 0) {
        nodeGroups.push(lastGroup);
      }
      if (nodeGroups.length === 1) {
        continue;
      }
      for (let group of [...nodeGroups].reverse()) {
        let clone = rule2.clone({ nodes: [] });
        clone.append(group);
        rule2.after(clone);
      }
      rule2.remove();
    }
  }
  function expandApplyAtRules2() {
    return (root12) => {
      partitionRules(root12);
    };
  }
  function isRoot(node) {
    return node.type === "root";
  }
  function isAtLayer(node) {
    return node.type === "atrule" && node.name === "layer";
  }
  function detectNesting_default(_context) {
    return (root12, result) => {
      let found = false;
      root12.walkAtRules("tailwind", (node) => {
        if (found)
          return false;
        if (node.parent && !(isRoot(node.parent) || isAtLayer(node.parent))) {
          found = true;
          node.warn(
            result,
            [
              "Nested @tailwind rules were detected, but are not supported.",
              "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix",
              "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"
            ].join("\n")
          );
          return false;
        }
      });
      root12.walkRules((rule2) => {
        if (found)
          return false;
        rule2.walkRules((nestedRule) => {
          found = true;
          nestedRule.warn(
            result,
            [
              "Nested CSS was detected, but CSS nesting has not been configured correctly.",
              "Please enable a CSS nesting plugin *before* Tailwind in your configuration.",
              "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"
            ].join("\n")
          );
          return false;
        });
      });
    };
  }
  function processTailwindFeatures(setupContext) {
    return async function(root12, result) {
      let { tailwindDirectives, applyDirectives } = normalizeTailwindDirectives(root12);
      detectNesting_default()(root12, result);
      expandApplyAtRules2()(root12, result);
      let context = setupContext({
        tailwindDirectives,
        applyDirectives,
        registerDependency(dependency) {
          result.messages.push({
            plugin: "tailwindcss",
            parent: result.opts.from,
            ...dependency
          });
        },
        createContext(tailwindConfig2, changedContent) {
          return createContext(tailwindConfig2, changedContent, root12);
        }
      })(root12, result);
      if (context.tailwindConfig.separator === "-") {
        throw new Error(
          "The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead."
        );
      }
      issueFlagNotices(context.tailwindConfig);
      await expandTailwindAtRules(context)(root12, result);
      expandApplyAtRules2()(root12, result);
      expandApplyAtRules(context)(root12, result);
      evaluateTailwindFunctions_default(context)(root12, result);
      substituteScreenAtRules_default(context)(root12, result);
      resolveDefaultsAtRules(context)(root12, result);
      collapseAdjacentRules(context)(root12, result);
      collapseDuplicateDeclarations(context)(root12, result);
    };
  }
  var corePluginList_default = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "lineClamp", "display", "aspectRatio", "size", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "captionSide", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "listStyleImage", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "hyphens", "whitespace", "textWrap", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "content", "forcedColorAdjust"];
  function configurePlugins_default(pluginConfig, plugins) {
    if (pluginConfig === void 0) {
      return plugins;
    }
    const pluginNames = Array.isArray(pluginConfig) ? pluginConfig : [
      ...new Set(
        plugins.filter((pluginName) => {
          return pluginConfig !== false && pluginConfig[pluginName] !== false;
        }).concat(
          Object.keys(pluginConfig).filter((pluginName) => {
            return pluginConfig[pluginName] !== false;
          })
        )
      )
    ];
    return pluginNames;
  }
  function warn({ version: version2, from, to }) {
    log_default.warn(`${from}-color-renamed`, [
      `As of Tailwind CSS ${version2}, \`${from}\` has been renamed to \`${to}\`.`,
      "Update your configuration file to silence this warning."
    ]);
  }
  var colors_default = {
    inherit: "inherit",
    current: "currentColor",
    transparent: "transparent",
    black: "#000",
    white: "#fff",
    slate: {
      50: "#f8fafc",
      100: "#f1f5f9",
      200: "#e2e8f0",
      300: "#cbd5e1",
      400: "#94a3b8",
      500: "#64748b",
      600: "#475569",
      700: "#334155",
      800: "#1e293b",
      900: "#0f172a",
      950: "#020617"
    },
    gray: {
      50: "#f9fafb",
      100: "#f3f4f6",
      200: "#e5e7eb",
      300: "#d1d5db",
      400: "#9ca3af",
      500: "#6b7280",
      600: "#4b5563",
      700: "#374151",
      800: "#1f2937",
      900: "#111827",
      950: "#030712"
    },
    zinc: {
      50: "#fafafa",
      100: "#f4f4f5",
      200: "#e4e4e7",
      300: "#d4d4d8",
      400: "#a1a1aa",
      500: "#71717a",
      600: "#52525b",
      700: "#3f3f46",
      800: "#27272a",
      900: "#18181b",
      950: "#09090b"
    },
    neutral: {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#e5e5e5",
      300: "#d4d4d4",
      400: "#a3a3a3",
      500: "#737373",
      600: "#525252",
      700: "#404040",
      800: "#262626",
      900: "#171717",
      950: "#0a0a0a"
    },
    stone: {
      50: "#fafaf9",
      100: "#f5f5f4",
      200: "#e7e5e4",
      300: "#d6d3d1",
      400: "#a8a29e",
      500: "#78716c",
      600: "#57534e",
      700: "#44403c",
      800: "#292524",
      900: "#1c1917",
      950: "#0c0a09"
    },
    red: {
      50: "#fef2f2",
      100: "#fee2e2",
      200: "#fecaca",
      300: "#fca5a5",
      400: "#f87171",
      500: "#ef4444",
      600: "#dc2626",
      700: "#b91c1c",
      800: "#991b1b",
      900: "#7f1d1d",
      950: "#450a0a"
    },
    orange: {
      50: "#fff7ed",
      100: "#ffedd5",
      200: "#fed7aa",
      300: "#fdba74",
      400: "#fb923c",
      500: "#f97316",
      600: "#ea580c",
      700: "#c2410c",
      800: "#9a3412",
      900: "#7c2d12",
      950: "#431407"
    },
    amber: {
      50: "#fffbeb",
      100: "#fef3c7",
      200: "#fde68a",
      300: "#fcd34d",
      400: "#fbbf24",
      500: "#f59e0b",
      600: "#d97706",
      700: "#b45309",
      800: "#92400e",
      900: "#78350f",
      950: "#451a03"
    },
    yellow: {
      50: "#fefce8",
      100: "#fef9c3",
      200: "#fef08a",
      300: "#fde047",
      400: "#facc15",
      500: "#eab308",
      600: "#ca8a04",
      700: "#a16207",
      800: "#854d0e",
      900: "#713f12",
      950: "#422006"
    },
    lime: {
      50: "#f7fee7",
      100: "#ecfccb",
      200: "#d9f99d",
      300: "#bef264",
      400: "#a3e635",
      500: "#84cc16",
      600: "#65a30d",
      700: "#4d7c0f",
      800: "#3f6212",
      900: "#365314",
      950: "#1a2e05"
    },
    green: {
      50: "#f0fdf4",
      100: "#dcfce7",
      200: "#bbf7d0",
      300: "#86efac",
      400: "#4ade80",
      500: "#22c55e",
      600: "#16a34a",
      700: "#15803d",
      800: "#166534",
      900: "#14532d",
      950: "#052e16"
    },
    emerald: {
      50: "#ecfdf5",
      100: "#d1fae5",
      200: "#a7f3d0",
      300: "#6ee7b7",
      400: "#34d399",
      500: "#10b981",
      600: "#059669",
      700: "#047857",
      800: "#065f46",
      900: "#064e3b",
      950: "#022c22"
    },
    teal: {
      50: "#f0fdfa",
      100: "#ccfbf1",
      200: "#99f6e4",
      300: "#5eead4",
      400: "#2dd4bf",
      500: "#14b8a6",
      600: "#0d9488",
      700: "#0f766e",
      800: "#115e59",
      900: "#134e4a",
      950: "#042f2e"
    },
    cyan: {
      50: "#ecfeff",
      100: "#cffafe",
      200: "#a5f3fc",
      300: "#67e8f9",
      400: "#22d3ee",
      500: "#06b6d4",
      600: "#0891b2",
      700: "#0e7490",
      800: "#155e75",
      900: "#164e63",
      950: "#083344"
    },
    sky: {
      50: "#f0f9ff",
      100: "#e0f2fe",
      200: "#bae6fd",
      300: "#7dd3fc",
      400: "#38bdf8",
      500: "#0ea5e9",
      600: "#0284c7",
      700: "#0369a1",
      800: "#075985",
      900: "#0c4a6e",
      950: "#082f49"
    },
    blue: {
      50: "#eff6ff",
      100: "#dbeafe",
      200: "#bfdbfe",
      300: "#93c5fd",
      400: "#60a5fa",
      500: "#3b82f6",
      600: "#2563eb",
      700: "#1d4ed8",
      800: "#1e40af",
      900: "#1e3a8a",
      950: "#172554"
    },
    indigo: {
      50: "#eef2ff",
      100: "#e0e7ff",
      200: "#c7d2fe",
      300: "#a5b4fc",
      400: "#818cf8",
      500: "#6366f1",
      600: "#4f46e5",
      700: "#4338ca",
      800: "#3730a3",
      900: "#312e81",
      950: "#1e1b4b"
    },
    violet: {
      50: "#f5f3ff",
      100: "#ede9fe",
      200: "#ddd6fe",
      300: "#c4b5fd",
      400: "#a78bfa",
      500: "#8b5cf6",
      600: "#7c3aed",
      700: "#6d28d9",
      800: "#5b21b6",
      900: "#4c1d95",
      950: "#2e1065"
    },
    purple: {
      50: "#faf5ff",
      100: "#f3e8ff",
      200: "#e9d5ff",
      300: "#d8b4fe",
      400: "#c084fc",
      500: "#a855f7",
      600: "#9333ea",
      700: "#7e22ce",
      800: "#6b21a8",
      900: "#581c87",
      950: "#3b0764"
    },
    fuchsia: {
      50: "#fdf4ff",
      100: "#fae8ff",
      200: "#f5d0fe",
      300: "#f0abfc",
      400: "#e879f9",
      500: "#d946ef",
      600: "#c026d3",
      700: "#a21caf",
      800: "#86198f",
      900: "#701a75",
      950: "#4a044e"
    },
    pink: {
      50: "#fdf2f8",
      100: "#fce7f3",
      200: "#fbcfe8",
      300: "#f9a8d4",
      400: "#f472b6",
      500: "#ec4899",
      600: "#db2777",
      700: "#be185d",
      800: "#9d174d",
      900: "#831843",
      950: "#500724"
    },
    rose: {
      50: "#fff1f2",
      100: "#ffe4e6",
      200: "#fecdd3",
      300: "#fda4af",
      400: "#fb7185",
      500: "#f43f5e",
      600: "#e11d48",
      700: "#be123c",
      800: "#9f1239",
      900: "#881337",
      950: "#4c0519"
    },
    get lightBlue() {
      warn({ version: "v2.2", from: "lightBlue", to: "sky" });
      return this.sky;
    },
    get warmGray() {
      warn({ version: "v3.0", from: "warmGray", to: "stone" });
      return this.stone;
    },
    get trueGray() {
      warn({ version: "v3.0", from: "trueGray", to: "neutral" });
      return this.neutral;
    },
    get coolGray() {
      warn({ version: "v3.0", from: "coolGray", to: "gray" });
      return this.gray;
    },
    get blueGray() {
      warn({ version: "v3.0", from: "blueGray", to: "slate" });
      return this.slate;
    }
  };
  function defaults2(target, ...sources) {
    for (let source2 of sources) {
      for (let k in source2) {
        if (!target?.hasOwnProperty?.(k)) {
          target[k] = source2[k];
        }
      }
      for (let k of Object.getOwnPropertySymbols(source2)) {
        if (!target?.hasOwnProperty?.(k)) {
          target[k] = source2[k];
        }
      }
    }
    return target;
  }
  function normalizeConfig(config5) {
    let valid = (() => {
      if (config5.purge) {
        return false;
      }
      if (!config5.content) {
        return false;
      }
      if (!Array.isArray(config5.content) && !(typeof config5.content === "object" && config5.content !== null)) {
        return false;
      }
      if (Array.isArray(config5.content)) {
        return config5.content.every((path) => {
          if (typeof path === "string")
            return true;
          if (typeof path?.raw !== "string")
            return false;
          if (path?.extension && typeof path?.extension !== "string") {
            return false;
          }
          return true;
        });
      }
      if (typeof config5.content === "object" && config5.content !== null) {
        if (Object.keys(config5.content).some(
          (key) => !["files", "relative", "extract", "transform"].includes(key)
        )) {
          return false;
        }
        if (Array.isArray(config5.content.files)) {
          if (!config5.content.files.every((path) => {
            if (typeof path === "string")
              return true;
            if (typeof path?.raw !== "string")
              return false;
            if (path?.extension && typeof path?.extension !== "string") {
              return false;
            }
            return true;
          })) {
            return false;
          }
          if (typeof config5.content.extract === "object") {
            for (let value2 of Object.values(config5.content.extract)) {
              if (typeof value2 !== "function") {
                return false;
              }
            }
          } else if (!(config5.content.extract === void 0 || typeof config5.content.extract === "function")) {
            return false;
          }
          if (typeof config5.content.transform === "object") {
            for (let value2 of Object.values(config5.content.transform)) {
              if (typeof value2 !== "function") {
                return false;
              }
            }
          } else if (!(config5.content.transform === void 0 || typeof config5.content.transform === "function")) {
            return false;
          }
          if (typeof config5.content.relative !== "boolean" && typeof config5.content.relative !== "undefined") {
            return false;
          }
        }
        return true;
      }
      return false;
    })();
    if (!valid) {
      log_default.warn("purge-deprecation", [
        "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
        "Update your configuration file to eliminate this warning.",
        "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
      ]);
    }
    config5.safelist = (() => {
      let { content, purge, safelist } = config5;
      if (Array.isArray(safelist))
        return safelist;
      if (Array.isArray(content?.safelist))
        return content.safelist;
      if (Array.isArray(purge?.safelist))
        return purge.safelist;
      if (Array.isArray(purge?.options?.safelist))
        return purge.options.safelist;
      return [];
    })();
    config5.blocklist = (() => {
      let { blocklist } = config5;
      if (Array.isArray(blocklist)) {
        if (blocklist.every((item) => typeof item === "string")) {
          return blocklist;
        }
        log_default.warn("blocklist-invalid", [
          "The `blocklist` option must be an array of strings.",
          "https://tailwindcss.com/docs/content-configuration#discarding-classes"
        ]);
      }
      return [];
    })();
    if (typeof config5.prefix === "function") {
      log_default.warn("prefix-function", [
        "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
        "Update `prefix` in your configuration to be a string to eliminate this warning.",
        "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
      ]);
      config5.prefix = "";
    } else {
      config5.prefix = config5.prefix ?? "";
    }
    config5.content = {
      relative: (() => {
        let { content } = config5;
        if (content?.relative) {
          return content.relative;
        }
        return flagEnabled(config5, "relativeContentPathsByDefault");
      })(),
      files: (() => {
        let { content, purge } = config5;
        if (Array.isArray(purge))
          return purge;
        if (Array.isArray(purge?.content))
          return purge.content;
        if (Array.isArray(content))
          return content;
        if (Array.isArray(content?.content))
          return content.content;
        if (Array.isArray(content?.files))
          return content.files;
        return [];
      })(),
      extract: (() => {
        let extract = (() => {
          if (config5.purge?.extract)
            return config5.purge.extract;
          if (config5.content?.extract)
            return config5.content.extract;
          if (config5.purge?.extract?.DEFAULT)
            return config5.purge.extract.DEFAULT;
          if (config5.content?.extract?.DEFAULT)
            return config5.content.extract.DEFAULT;
          if (config5.purge?.options?.extractors)
            return config5.purge.options.extractors;
          if (config5.content?.options?.extractors)
            return config5.content.options.extractors;
          return {};
        })();
        let extractors = {};
        let defaultExtractor2 = (() => {
          if (config5.purge?.options?.defaultExtractor) {
            return config5.purge.options.defaultExtractor;
          }
          if (config5.content?.options?.defaultExtractor) {
            return config5.content.options.defaultExtractor;
          }
          return void 0;
        })();
        if (defaultExtractor2 !== void 0) {
          extractors.DEFAULT = defaultExtractor2;
        }
        if (typeof extract === "function") {
          extractors.DEFAULT = extract;
        } else if (Array.isArray(extract)) {
          for (let { extensions, extractor } of extract ?? []) {
            for (let extension of extensions) {
              extractors[extension] = extractor;
            }
          }
        } else if (typeof extract === "object" && extract !== null) {
          Object.assign(extractors, extract);
        }
        return extractors;
      })(),
      transform: (() => {
        let transform = (() => {
          if (config5.purge?.transform)
            return config5.purge.transform;
          if (config5.content?.transform)
            return config5.content.transform;
          if (config5.purge?.transform?.DEFAULT)
            return config5.purge.transform.DEFAULT;
          if (config5.content?.transform?.DEFAULT)
            return config5.content.transform.DEFAULT;
          return {};
        })();
        let transformers = {};
        if (typeof transform === "function") {
          transformers.DEFAULT = transform;
        }
        if (typeof transform === "object" && transform !== null) {
          Object.assign(transformers, transform);
        }
        return transformers;
      })()
    };
    for (let file of config5.content.files) {
      if (typeof file === "string" && /{([^,]*?)}/g.test(file)) {
        log_default.warn("invalid-glob-braces", [
          `The glob pattern ${dim(file)} in your Tailwind CSS configuration is invalid.`,
          `Update it to ${dim(file.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
        ]);
        break;
      }
    }
    return config5;
  }
  function cloneDeep(value2) {
    if (Array.isArray(value2)) {
      return value2.map((child2) => cloneDeep(child2));
    }
    if (typeof value2 === "object" && value2 !== null) {
      return Object.fromEntries(Object.entries(value2).map(([k, v]) => [k, cloneDeep(v)]));
    }
    return value2;
  }
  function isFunction3(input) {
    return typeof input === "function";
  }
  function mergeWith(target, ...sources) {
    let customizer = sources.pop();
    for (let source2 of sources) {
      for (let k in source2) {
        let merged = customizer(target[k], source2[k]);
        if (merged === void 0) {
          if (isPlainObject(target[k]) && isPlainObject(source2[k])) {
            target[k] = mergeWith({}, target[k], source2[k], customizer);
          } else {
            target[k] = source2[k];
          }
        } else {
          target[k] = merged;
        }
      }
    }
    return target;
  }
  var configUtils = {
    colors: colors_default,
    negative(scale) {
      return Object.keys(scale).filter((key) => scale[key] !== "0").reduce((negativeScale, key) => {
        let negativeValue = negateValue(scale[key]);
        if (negativeValue !== void 0) {
          negativeScale[`-${key}`] = negativeValue;
        }
        return negativeScale;
      }, {});
    },
    breakpoints(screens) {
      return Object.keys(screens).filter((key) => typeof screens[key] === "string").reduce(
        (breakpoints, key) => ({
          ...breakpoints,
          [`screen-${key}`]: screens[key]
        }),
        {}
      );
    }
  };
  function value(valueToResolve, ...args) {
    return isFunction3(valueToResolve) ? valueToResolve(...args) : valueToResolve;
  }
  function collectExtends(items) {
    return items.reduce((merged, { extend }) => {
      return mergeWith(merged, extend, (mergedValue, extendValue) => {
        if (mergedValue === void 0) {
          return [extendValue];
        }
        if (Array.isArray(mergedValue)) {
          return [extendValue, ...mergedValue];
        }
        return [extendValue, mergedValue];
      });
    }, {});
  }
  function mergeThemes(themes) {
    return {
      ...themes.reduce((merged, theme2) => defaults2(merged, theme2), {}),
      extend: collectExtends(themes)
    };
  }
  function mergeExtensionCustomizer(merged, value2) {
    if (Array.isArray(merged) && isPlainObject(merged[0])) {
      return merged.concat(value2);
    }
    if (Array.isArray(value2) && isPlainObject(value2[0]) && isPlainObject(merged)) {
      return [merged, ...value2];
    }
    if (Array.isArray(value2)) {
      return value2;
    }
    return void 0;
  }
  function mergeExtensions({ extend, ...theme2 }) {
    return mergeWith(theme2, extend, (themeValue, extensions) => {
      if (!isFunction3(themeValue) && !extensions.some(isFunction3)) {
        return mergeWith({}, themeValue, ...extensions, mergeExtensionCustomizer);
      }
      return (resolveThemePath, utils) => mergeWith(
        {},
        ...[themeValue, ...extensions].map((e) => value(e, resolveThemePath, utils)),
        mergeExtensionCustomizer
      );
    });
  }
  function* toPaths2(key) {
    let path = toPath(key);
    if (path.length === 0) {
      return;
    }
    yield path;
    if (Array.isArray(key)) {
      return;
    }
    let pattern2 = /^(.*?)\s*\/\s*([^/]+)$/;
    let matches = key.match(pattern2);
    if (matches !== null) {
      let [, prefix3, alpha] = matches;
      let newPath = toPath(prefix3);
      newPath.alpha = alpha;
      yield newPath;
    }
  }
  function resolveFunctionKeys(object) {
    const resolvePath2 = (key, defaultValue) => {
      for (const path of toPaths2(key)) {
        let index5 = 0;
        let val = object;
        while (val !== void 0 && val !== null && index5 < path.length) {
          val = val[path[index5++]];
          let shouldResolveAsFn = isFunction3(val) && (path.alpha === void 0 || index5 <= path.length - 1);
          val = shouldResolveAsFn ? val(resolvePath2, configUtils) : val;
        }
        if (val !== void 0) {
          if (path.alpha !== void 0) {
            let normalized = parseColorFormat(val);
            return withAlphaValue(normalized, path.alpha, toColorValue(normalized));
          }
          if (isPlainObject(val)) {
            return cloneDeep(val);
          }
          return val;
        }
      }
      return defaultValue;
    };
    Object.assign(resolvePath2, {
      theme: resolvePath2,
      ...configUtils
    });
    return Object.keys(object).reduce((resolved, key) => {
      resolved[key] = isFunction3(object[key]) ? object[key](resolvePath2, configUtils) : object[key];
      return resolved;
    }, {});
  }
  function extractPluginConfigs(configs) {
    let allConfigs = [];
    configs.forEach((config5) => {
      allConfigs = [...allConfigs, config5];
      const plugins = config5?.plugins ?? [];
      if (plugins.length === 0) {
        return;
      }
      plugins.forEach((plugin2) => {
        if (plugin2.__isOptionsFunction) {
          plugin2 = plugin2();
        }
        allConfigs = [...allConfigs, ...extractPluginConfigs([plugin2?.config ?? {}])];
      });
    });
    return allConfigs;
  }
  function resolveCorePlugins(corePluginConfigs) {
    const result = [...corePluginConfigs].reduceRight((resolved, corePluginConfig) => {
      if (isFunction3(corePluginConfig)) {
        return corePluginConfig({ corePlugins: resolved });
      }
      return configurePlugins_default(corePluginConfig, resolved);
    }, corePluginList_default);
    return result;
  }
  function resolvePluginLists(pluginLists) {
    const result = [...pluginLists].reduceRight((resolved, pluginList) => {
      return [...resolved, ...pluginList];
    }, []);
    return result;
  }
  function resolveConfig(configs) {
    let allConfigs = [
      ...extractPluginConfigs(configs),
      {
        prefix: "",
        important: false,
        separator: ":"
      }
    ];
    return normalizeConfig(
      defaults2(
        {
          theme: resolveFunctionKeys(
            mergeExtensions(mergeThemes(allConfigs.map((t) => t?.theme ?? {})))
          ),
          corePlugins: resolveCorePlugins(allConfigs.map((c) => c.corePlugins)),
          plugins: resolvePluginLists(configs.map((c) => c?.plugins ?? []))
        },
        ...allConfigs
      )
    );
  }
  var import_config_full = __toESM2(require_config_full());
  function getAllConfigs(config5) {
    const configs = (config5?.presets ?? [import_config_full.default]).slice().reverse().flatMap((preset) => getAllConfigs(preset instanceof Function ? preset() : preset));
    const features = {
      respectDefaultRingColorOpacity: {
        theme: {
          ringColor: ({ theme: theme2 }) => ({
            DEFAULT: "#3b82f67f",
            ...theme2("colors")
          })
        }
      },
      disableColorOpacityUtilitiesByDefault: {
        corePlugins: {
          backgroundOpacity: false,
          borderOpacity: false,
          divideOpacity: false,
          placeholderOpacity: false,
          ringOpacity: false,
          textOpacity: false
        }
      }
    };
    const experimentals = Object.keys(features).filter((feature) => flagEnabled(config5, feature)).map((feature) => features[feature]);
    return [config5, ...experimentals, ...configs];
  }
  function resolveConfig2(...configs) {
    let [, ...defaultConfigs] = getAllConfigs(configs[0]);
    return resolveConfig([...configs, ...defaultConfigs]);
  }
  function bigSign2(bigIntValue) {
    return Number(bigIntValue > 0n) - Number(bigIntValue < 0n);
  }
  function defaultSort(arrayOfTuples) {
    return arrayOfTuples.sort(([, a], [, z]) => {
      if (a === z)
        return 0;
      if (a === null)
        return -1;
      if (z === null)
        return 1;
      return bigSign2(a - z);
    }).map(([className]) => className);
  }
  var createTailwindcss = ({ tailwindConfig: tailwindConfig2 } = {}) => {
    let currentTailwindConfig = tailwindConfig2;
    return {
      setTailwindConfig(newTailwindConfig) {
        currentTailwindConfig = newTailwindConfig;
      },
      async generateStylesFromContent(css, content) {
        const tailwindcssPlugin = createTailwindcssPlugin({ tailwindConfig: currentTailwindConfig, content });
        const processor = postcss_default([tailwindcssPlugin]);
        const result = await processor.process(css, { from: void 0 });
        return result.css;
      },
      getClassOrder: (classList) => {
        const context = createContext(resolveConfig2(tailwindConfig2 ?? {}));
        return defaultSort(context.getClassOrder(classList));
      }
    };
  };
  var createTailwindcssPlugin = ({ tailwindConfig: tailwindConfig2, content: contentCollection }) => {
    const config5 = resolveConfig2(tailwindConfig2 ?? {});
    const tailwindcssPlugin = processTailwindFeatures(
      (processOptions) => () => processOptions.createContext(
        config5,
        contentCollection.map((content) => typeof content === "string" ? { content } : content)
      )
    );
    return tailwindcssPlugin;
  };

  // svelte/components/PageWrapper.svelte
  var import_html_entities = __toESM(require_lib());
  mark_module_start();
  PageWrapper[FILENAME] = "svelte/components/PageWrapper.svelte";
  var root_24 = add_locations(template(`<div class="contents"></div>`), PageWrapper[FILENAME], [[72, 6]]);
  var root7 = add_locations(template(`<span></span> <div></div>`, 1), PageWrapper[FILENAME], [[61, 0], [63, 0]]);
  var $$css4 = {
    hash: "svelte-9t6pvg",
    code: '\n  [data-selected="true"], [data-selected-parent="true"] {\n    outline-color: #06b6d4;\n    outline-width: 1px;\n    outline-style: solid;\n  }\n  [data-selected="true"].contents > *, [data-selected-parent="true"].contents > * {\n    outline-color: #06b6d4;\n    outline-width: 1px;\n    outline-style: solid;\n  }\n  /* TODO: Apply this styles to [data-selected-parent="true"] once dragging of the parent element is allowed */\n  [data-highlighted="true"] {\n    outline-color: #06b6d4;\n    outline-width: 2px;\n    outline-style: dashed;\n  }\n\n  :before, :after {\n    pointer-events: none;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFnZVdyYXBwZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiI7QUF1RkEsRUFBVSxxREFBc0QsQ0FBQztBQUNqRSxJQUFJLHNCQUFzQjtBQUMxQixJQUFJLGtCQUFrQjtBQUN0QixJQUFJLG9CQUFvQjtBQUN4QjtBQUNBLEVBQVUsK0VBQWdGLENBQUM7QUFDM0YsSUFBSSxzQkFBc0I7QUFDMUIsSUFBSSxrQkFBa0I7QUFDdEIsSUFBSSxvQkFBb0I7QUFDeEI7QUFDQTtBQUNBLEVBQVUseUJBQTBCLENBQUM7QUFDckMsSUFBSSxzQkFBc0I7QUFDMUIsSUFBSSxrQkFBa0I7QUFDdEIsSUFBSSxxQkFBcUI7QUFDekI7O0FBRUEsRUFBVSxlQUFnQixDQUFDO0FBQzNCLElBQUksb0JBQW9CO0FBQ3hCIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJQYWdlV3JhcHBlci5zdmVsdGUiXX0= */'
  };
  function PageWrapper($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, PageWrapper);
    append_styles2($$anchor, $$css4);
    const [$$stores, $$cleanup] = setup_stores();
    const $tailwindConfig = () => (validate_store(tailwindConfig, "tailwindConfig"), store_get(tailwindConfig, "$tailwindConfig", $$stores));
    const $tailwindInput = () => (validate_store(tailwindInput, "tailwindInput"), store_get(tailwindInput, "$tailwindInput", $$stores));
    const $layoutAst = () => (validate_store(layoutAst, "layoutAst"), store_get(layoutAst, "$layoutAst", $$stores));
    const $pageAst = () => (validate_store(pageAst, "pageAst"), store_get(pageAst, "$pageAst", $$stores));
    let wrapper = mutable_source();
    let styleWrapper = mutable_source();
    let contentWrapper = mutable_source();
    let twConfig = $tailwindConfig();
    let configPromise = import(twConfig);
    onMount(async () => {
      const { default: tailwindConfig2 } = await configPromise;
      const tailwind = createTailwindcss({ tailwindConfig: tailwindConfig2 });
      const reloadStylesheet = async () => {
        if (!get(wrapper)) return;
        const content = (0, import_html_entities.decode)(get(wrapper).outerHTML);
        const css = await tailwind.generateStylesFromContent($tailwindInput(), [content]);
        let styleEl = document.createElement("style");
        styleEl.textContent = css;
        get(styleWrapper).appendChild(styleEl);
      };
      window.reloadStylesheet = reloadStylesheet;
      reloadStylesheet();
    });
    pageAst.subscribe(async () => {
      await tick();
      window.reloadStylesheet && window.reloadStylesheet();
    });
    function preventLinkNavigation(event2) {
      if (event2.target instanceof HTMLAnchorElement) {
        event2.preventDefault();
      }
    }
    function handleKeydown(event2) {
      if (strict_equals(event2.key, "Enter") && event2.target instanceof HTMLAnchorElement) {
        event2.preventDefault();
      }
    }
    function handleDragDrop(e) {
      const target = e.target;
      if (!get(contentWrapper).contains(target)) {
        if (target.compareDocumentPosition(get(contentWrapper)) & Node.DOCUMENT_POSITION_PRECEDING) {
          e.dataTransfer.layoutZone = "epilogue";
        } else if (target.compareDocumentPosition(get(contentWrapper)) & Node.DOCUMENT_POSITION_FOLLOWING) {
          e.dataTransfer.layoutZone = "preamble";
        }
      }
    }
    init2();
    var fragment = root7();
    var span = first_child(fragment);
    bind_this(span, ($$value) => set(styleWrapper, $$value), () => get(styleWrapper));
    var div = sibling(span, 2);
    each(div, 5, $layoutAst, index2, ($$anchor2, layoutAstNode) => {
      LayoutAstNode($$anchor2, {
        get node() {
          return get(layoutAstNode);
        },
        children: wrap_snippet(PageWrapper, ($$anchor3, $$slotProps) => {
          var div_1 = root_24();
          each(div_1, 5, $pageAst, index2, ($$anchor4, astNode, index5) => {
            const expression = derived_safe_equal(() => String(index5));
            PageAstNode($$anchor4, {
              get node() {
                return get(astNode);
              },
              get nodeId() {
                return get(expression);
              }
            });
          });
          reset(div_1);
          bind_this(div_1, ($$value) => set(contentWrapper, $$value), () => get(contentWrapper));
          append($$anchor3, div_1);
        }),
        $$slots: { default: true }
      });
    });
    reset(div);
    bind_this(div, ($$value) => set(wrapper, $$value), () => get(wrapper));
    event("click", div, preventLinkNavigation);
    event("drop", div, handleDragDrop);
    event("keydown", div, handleKeydown);
    append($$anchor, fragment);
    var $$pop = pop({ ...legacy_api() });
    $$cleanup();
    return $$pop;
  }
  mark_module_end(PageWrapper);
  customElements.define("page-wrapper", create_custom_element(PageWrapper, {}, [], [], true));

  // svelte/components/Pill.svelte
  var Pill_exports = {};
  __export(Pill_exports, {
    default: () => Pill
  });
  mark_module_start();
  Pill[FILENAME] = "svelte/components/Pill.svelte";
  var root8 = add_locations(template(`<div class="inline-flex items-center rounded-full bg-slate-700 text-white text-xs px-3 pr-0 m-1 leading-4"><!> <button class="p-2 rounded-full inline-block bg-slate-700 text-white hover:text-blue-400 active:text-blue-500" type="button"><span class="sr-only">Delete class: <!></span> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3 h-3"><path fill-rule="evenodd" d="M5.47 5.47a.75.75 0 0 1 1.06 0L12 10.94l5.47-5.47a.75.75 0 1 1 1.06 1.06L13.06 12l5.47 5.47a.75.75 0 1 1-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 0 1-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"></path></svg></button></div>`), Pill[FILENAME], [
    [
      5,
      0,
      [
        [
          7,
          2,
          [[12, 4], [13, 4, [[14, 6]]]]
        ]
      ]
    ]
  ]);
  function Pill($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, Pill);
    const dispatch = createEventDispatcher();
    init2();
    var div = root8();
    var node = child(div);
    slot(node, $$props, "default", {}, null);
    var button = sibling(node, 2);
    var span = child(button);
    var node_1 = sibling(child(span));
    slot(node_1, $$props, "default", {}, null);
    reset(span);
    next(2);
    reset(button);
    reset(div);
    event("click", button, preventDefault(() => dispatch("delete")));
    append($$anchor, div);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Pill);
  create_custom_element(Pill, {}, ["default"], [], true);

  // svelte/components/ResetSelectionButton.svelte
  var ResetSelectionButton_exports = {};
  __export(ResetSelectionButton_exports, {
    default: () => ResetSelectionButton
  });
  mark_module_start();
  ResetSelectionButton[FILENAME] = "svelte/components/ResetSelectionButton.svelte";
  var root9 = add_locations(template(`<button type="button" class="absolute p-2 top-2 right-1"><span class="sr-only">Close</span> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 hover:text-blue-700 active:text-blue-900"><path fill-rule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25Zm-1.72 6.97a.75.75 0 1 0-1.06 1.06L10.94 12l-1.72 1.72a.75.75 0 1 0 1.06 1.06L12 13.06l1.72 1.72a.75.75 0 1 0 1.06-1.06L13.06 12l1.72-1.72a.75.75 0 1 0-1.06-1.06L12 10.94l-1.72-1.72Z" clip-rule="evenodd"></path></svg></button>`), ResetSelectionButton[FILENAME], [
    [
      4,
      0,
      [[5, 2], [6, 2, [[12, 4]]]]
    ]
  ]);
  function ResetSelectionButton($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, ResetSelectionButton);
    var button = root9();
    event("click", button, function(...$$args) {
      apply(() => resetSelection, this, $$args, ResetSelectionButton, [4, 67]);
    });
    append($$anchor, button);
    return pop({ ...legacy_api() });
  }
  mark_module_end(ResetSelectionButton);
  create_custom_element(ResetSelectionButton, {}, [], [], true);

  // svelte/components/SelectedElementFloatingMenu.svelte
  var SelectedElementFloatingMenu_exports = {};
  __export(SelectedElementFloatingMenu_exports, {
    default: () => SelectedElementFloatingMenu
  });
  mark_module_start();
  SelectedElementFloatingMenu[FILENAME] = "svelte/components/SelectedElementFloatingMenu.svelte";
  var root_25 = add_locations(template(`<button class="absolute top-0 -m-3 w-6 h-6 rounded-full flex justify-center items-center bg-red-500 text-white hover:bg-red-700 focus:outline-none focus-visible:ring-4 focus-visible:ring-blue-200 active:bg-red-800" aria-label="Delete component" data-testid="element-delete-button"><span class="hero-trash"></span></button>`), SelectedElementFloatingMenu[FILENAME], [[41, 6, [[48, 8]]]]);
  var root_14 = add_locations(template(`<div class="selected-element-menu absolute"><!></div> <!> <!>`, 1), SelectedElementFloatingMenu[FILENAME], [[35, 2]]);
  function SelectedElementFloatingMenu($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, SelectedElementFloatingMenu);
    const [$$stores, $$cleanup] = setup_stores();
    const $selectedDomElement = () => (validate_store(selectedDomElement, "selectedDomElement"), store_get(selectedDomElement, "$selectedDomElement", $$stores));
    const $isDragging = () => (validate_store(isDragging, "isDragging"), store_get(isDragging, "$isDragging", $$stores));
    const $selectedAstElementId = () => (validate_store(selectedAstElementId, "selectedAstElementId"), store_get(selectedAstElementId, "$selectedAstElementId", $$stores));
    const $selectedAstElement = () => (validate_store(selectedAstElement, "selectedAstElement"), store_get(selectedAstElement, "$selectedAstElement", $$stores));
    const showMenu = mutable_source();
    let menuDOMElement = mutable_source();
    let menuPosition = mutable_source();
    async function deleteComponent() {
      if (!$selectedAstElementId()) return;
      if (confirm("Are you sure you want to delete this component?")) {
        deleteAstNode($selectedAstElementId());
        resetSelection();
      }
    }
    legacy_pre_effect(() => ($selectedDomElement(), $isDragging()), () => {
      set(showMenu, !!$selectedDomElement() && !$isDragging());
    });
    legacy_pre_effect(
      () => (get(showMenu), get(menuDOMElement), $selectedDomElement(), getBoundingRect),
      () => {
        set(menuPosition, (() => {
          if (!(get(showMenu) && document && get(menuDOMElement) && $selectedDomElement())) {
            return { x: 0, y: 0, width: 0, height: 0 };
          }
          let relativeWrapperRect = getBoundingRect(get(menuDOMElement).closest(".relative"));
          let currentRect = getBoundingRect($selectedDomElement());
          return {
            x: currentRect.x - relativeWrapperRect.x,
            y: currentRect.y - relativeWrapperRect.y,
            width: currentRect.width,
            height: currentRect.height
          };
        })());
      }
    );
    legacy_pre_effect_reset();
    init2();
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent_2 = ($$anchor2) => {
        var fragment_1 = root_14();
        var div = first_child(fragment_1);
        var node_1 = child(div);
        {
          var consequent = ($$anchor3) => {
            var button = root_25();
            template_effect(() => set_style(button, `left: ${get(menuPosition).width}px;`));
            event("click", button, deleteComponent);
            append($$anchor3, button);
          };
          if_block(node_1, ($$render) => {
            if (get(showMenu)) $$render(consequent);
          });
        }
        reset(div);
        bind_this(div, ($$value) => set(menuDOMElement, $$value), () => get(menuDOMElement));
        var node_2 = sibling(div, 2);
        DragMenuOption(node_2, {
          get element() {
            return $selectedDomElement();
          }
        });
        var node_3 = sibling(node_2, 2);
        {
          var consequent_1 = ($$anchor3) => {
            DragMenuOption($$anchor3, {
              get element() {
                return $selectedDomElement().parentElement;
              },
              isParent: true
            });
          };
          if_block(node_3, ($$render) => {
            if ($selectedDomElement()?.parentElement) $$render(consequent_1);
          });
        }
        template_effect(() => set_style(div, `top: ${get(menuPosition).y}px; left: ${get(menuPosition).x}px;`));
        append($$anchor2, fragment_1);
      };
      if_block(node, ($$render) => {
        if ($selectedAstElement()) $$render(consequent_2);
      });
    }
    append($$anchor, fragment);
    var $$pop = pop({ ...legacy_api() });
    $$cleanup();
    return $$pop;
  }
  mark_module_end(SelectedElementFloatingMenu);
  create_custom_element(SelectedElementFloatingMenu, {}, [], [], true);

  // svelte/components/SidebarSection.svelte
  var SidebarSection_exports = {};
  __export(SidebarSection_exports, {
    default: () => SidebarSection
  });
  mark_module_start();
  SidebarSection[FILENAME] = "svelte/components/SidebarSection.svelte";
  var root_15 = add_locations(template(`<span class="ml-4 inline-block cursor-pointer" title="Delete attribute" role="button" tabindex="0"><span class="hero-trash text-red hover:text-red"></span></span>`), SidebarSection[FILENAME], [[85, 10, [[92, 11]]]]);
  var root_32 = add_locations(template(`<input type="text" class="w-full py-1 px-2 bg-gray-100 border-gray-100 rounded-md leading-6 text-sm">`), SidebarSection[FILENAME], [[114, 6]]);
  var root_26 = add_locations(template(`<!> <div class="pt-3"><!></div>`, 1), SidebarSection[FILENAME], [[123, 4]]);
  var root_82 = add_locations(template(`<textarea class="w-full py-1 px-2 bg-slate-100 border-slate-100 rounded-md leading-6 text-sm"></textarea>`), SidebarSection[FILENAME], [[129, 10]]);
  var root_9 = add_locations(template(`<input type="text" class="w-full py-1 px-2 bg-slate-100 border-slate-100 rounded-md leading-6 text-sm">`), SidebarSection[FILENAME], [[138, 10]]);
  var root_10 = add_locations(template(`<div class="pt-3"><!></div>`), SidebarSection[FILENAME], [[148, 10]]);
  var root_7 = add_locations(template(`<!> <!>`, 1), SidebarSection[FILENAME], []);
  var root_142 = add_locations(template(`<div class="mt-5"><div class="flex items-center justify-between"><span><code> </code></span> <button class="flex items-center justify-center gap-x-0.5 px-2 py-1 bg-cyan-300 font-bold text-xs uppercase tracking-wide rounded transition-colors hover:bg-cyan-900 active:bg-cyan-700 hover:text-white">Edit <span class="sr-only"> </span> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3 h-3"><path d="M21.731 2.269a2.625 2.625 0 0 0-3.712 0l-1.157 1.157 3.712 3.712 1.157-1.157a2.625 2.625 0 0 0 0-3.712ZM19.513 8.199l-3.712-3.712-8.4 8.4a5.25 5.25 0 0 0-1.32 2.214l-.8 2.685a.75.75 0 0 0 .933.933l2.685-.8a5.25 5.25 0 0 0 2.214-1.32l8.4-8.4Z"></path><path d="M5.25 5.25a3 3 0 0 0-3 3v10.5a3 3 0 0 0 3 3h10.5a3 3 0 0 0 3-3V13.5a.75.75 0 0 0-1.5 0v5.25a1.5 1.5 0 0 1-1.5 1.5H5.25a1.5 1.5 0 0 1-1.5-1.5V8.25a1.5 1.5 0 0 1 1.5-1.5h5.25a.75.75 0 0 0 0-1.5H5.25Z"></path></svg></button></div> <div class="mt-2 grid grid-cols-2 gap-x-1"><button class="flex items-center justify-center gap-x-0.5 px-1.5 py-1 bg-cyan-800 font-bold text-xs uppercase tracking-wide rounded hover:bg-cyan-950 active:bg-cyan-700 disabled:bg-gray-300 disabled:cursor-not-allowed text-white"><span>Move <span class="sr-only"> </span> up</span> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3 h-3"><path fill-rule="evenodd" d="M11.47 2.47a.75.75 0 0 1 1.06 0l7.5 7.5a.75.75 0 1 1-1.06 1.06l-6.22-6.22V21a.75.75 0 0 1-1.5 0V4.81l-6.22 6.22a.75.75 0 1 1-1.06-1.06l7.5-7.5Z" clip-rule="evenodd"></path></svg></button> <button class="flex items-center justify-center gap-x-0.5 px-1.5 py-1 bg-cyan-800 font-bold text-xs uppercase tracking-wide rounded hover:bg-cyan-950 active:bg-cyan-700 disabled:bg-gray-300 disabled:cursor-not-allowed text-white"><span>Move <span class="sr-only"> </span> down</span> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3 h-3"><path fill-rule="evenodd" d="M12 2.25a.75.75 0 0 1 .75.75v16.19l6.22-6.22a.75.75 0 1 1 1.06 1.06l-7.5 7.5a.75.75 0 0 1-1.06 0l-7.5-7.5a.75.75 0 1 1 1.06-1.06l6.22 6.22V3a.75.75 0 0 1 .75-.75Z" clip-rule="evenodd"></path></svg></button></div></div>`), SidebarSection[FILENAME], [
    [
      154,
      12,
      [
        [
          159,
          14,
          [
            [160, 16, [[160, 22]]],
            [
              161,
              16,
              [
                [165, 23],
                [166, 18, [[167, 20], [170, 20]]]
              ]
            ]
          ]
        ],
        [
          176,
          14,
          [
            [
              177,
              16,
              [
                [182, 18, [[182, 29]]],
                [183, 18, [[184, 20]]]
              ]
            ],
            [
              191,
              16,
              [
                [196, 18, [[196, 29]]],
                [197, 18, [[198, 20]]]
              ]
            ]
          ]
        ]
      ]
    ]
  ]);
  var root_16 = add_locations(template(`<textarea class="w-full py-1 px-2 bg-slate-100 border-slate-100 rounded-md leading-6 text-sm"></textarea>`), SidebarSection[FILENAME], [[208, 12]]);
  var root_17 = add_locations(template(`<input type="text" class="w-full py-1 px-2 mt-5 bg-slate-100 border-slate-100 rounded-md leading-6 text-sm">`), SidebarSection[FILENAME], [[216, 12]]);
  var root10 = add_locations(template(`<section class="p-4 border-b border-b-gray-100 border-solid"><header class="flex items-center text-sm mb-2 font-medium"><button type="button" class="w-full flex items-center justify-between gap-x-1 p-1 font-semibold group"><span><span class="hover:text-blue-700 active:text-blue-900"><!></span> <!></span> <span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 stroke-slate-500 fill-slate-500 group-hover:stroke-current group-hover:fill-current"><path fill-rule="evenodd" d="M11.47 7.72a.75.75 0 0 1 1.06 0l7.5 7.5a.75.75 0 1 1-1.06 1.06L12 9.31l-6.97 6.97a.75.75 0 0 1-1.06-1.06l7.5-7.5Z" clip-rule="evenodd"></path></svg></span></button></header> <!></section>`), SidebarSection[FILENAME], [
    [
      74,
      0,
      [
        [
          75,
          2,
          [
            [
              76,
              4,
              [
                [82, 6, [[83, 8]]],
                [
                  95,
                  6,
                  [[96, 8, [[102, 10]]]]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]);
  function SidebarSection($$anchor, $$props) {
    check_target(new.target);
    const $$slots = sanitize_slots($$props);
    push($$props, false, SidebarSection);
    const [$$stores, $$cleanup] = setup_stores();
    const $highlightedAstElement = () => (validate_store(highlightedAstElement, "highlightedAstElement"), store_get(highlightedAstElement, "$highlightedAstElement", $$stores));
    const $selectedAstElementId = () => (validate_store(selectedAstElementId, "selectedAstElementId"), store_get(selectedAstElementId, "$selectedAstElementId", $$stores));
    const astElements = mutable_source();
    const dispatch = createEventDispatcher();
    let value2 = prop($$props, "value", 12, "");
    let astNodes = prop($$props, "astNodes", 12, null);
    let clearOnUpdate = prop($$props, "clearOnUpdate", 12, false);
    let expanded = prop($$props, "expanded", 12, true);
    let placeholder = prop($$props, "placeholder", 12, "");
    let large = prop($$props, "large", 12, false);
    let disableDelete = prop($$props, "disableDelete", 12, false);
    let disabled = prop($$props, "disabled", 12, false);
    function highlightAstElement(astElement) {
      store_set(highlightedAstElement, astElement);
    }
    function unhighlightAstElement() {
      store_set(highlightedAstElement, void 0);
    }
    function deleteAttribute() {
      if (confirm("Are you sure you want to delete this attribute?")) {
        dispatch("delete");
      }
    }
    let internalValue = mutable_source(get(astElements) ? null : value2());
    function handleKeydown(e) {
      if (!(e.target instanceof HTMLInputElement)) return;
      let text2 = e.target.value;
      if (strict_equals(e.key, "Enter") && text2 && text2.length > 0 && strict_equals(text2, value2(), false)) {
        dispatch("update", text2);
        if (clearOnUpdate()) {
          set(internalValue, null);
          e.target.value = "";
        }
      }
    }
    function handleTextChange(e) {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        dispatch("textChange", e.target.value);
      }
    }
    function select(astElement) {
      let id = findAstElementId(astElement);
      store_set(selectedAstElementId, id);
    }
    function moveAstElement(movement, astElement) {
      if (!astNodes()) return;
      let astNodesCopy = Array.from(astNodes());
      let index5 = astNodesCopy.indexOf(astElement);
      astNodesCopy.splice(index5, 1);
      astNodesCopy.splice(index5 + movement, 0, astElement);
      dispatch("nodesChange", astNodesCopy);
    }
    function updateNodeContents(e, idx) {
      let astNodesCopy = [...astNodes()];
      astNodesCopy[idx] = e.target.value;
      dispatch("nodesChange", astNodesCopy);
    }
    legacy_pre_effect(
      () => (deep_read_state(astNodes()), isAstElement),
      () => {
        set(astElements, (astNodes() || []).filter(isAstElement));
      }
    );
    legacy_pre_effect(
      () => (deep_read_state(astNodes()), isAstElement),
      () => {
        if (strict_equals(astNodes()?.length, 1)) {
          let first = astNodes()[0];
          if (!isAstElement(first)) {
            set(internalValue, first);
          }
        } else if (astNodes()) {
          set(internalValue, null);
        }
      }
    );
    legacy_pre_effect_reset();
    init2();
    var section = root10();
    var header = child(section);
    var button = child(header);
    var span = child(button);
    var span_1 = child(span);
    var node = child(span_1);
    slot(node, $$props, "heading", {}, null);
    reset(span_1);
    var node_1 = sibling(span_1, 2);
    {
      var consequent = ($$anchor2) => {
        var span_2 = root_15();
        event("click", span_2, stopPropagation(deleteAttribute));
        event("keydown", span_2, (e) => strict_equals(e.key, "Enter") && deleteAttribute());
        append($$anchor2, span_2);
      };
      if_block(node_1, ($$render) => {
        if (!disableDelete()) $$render(consequent);
      });
    }
    reset(span);
    var span_3 = sibling(span, 2);
    reset(button);
    reset(header);
    var node_2 = sibling(header, 2);
    {
      var consequent_1 = ($$anchor2) => {
        var fragment = root_26();
        var node_3 = first_child(fragment);
        slot(node_3, $$props, "input", {}, ($$anchor3) => {
          var input = root_32();
          remove_input_defaults(input);
          template_effect(() => {
            set_attribute(input, "placeholder", placeholder());
            set_value(input, get(internalValue));
          });
          event("keydown", input, handleKeydown);
          event("change", input, handleTextChange);
          append($$anchor3, input);
        });
        var div = sibling(node_3, 2);
        var node_4 = child(div);
        slot(node_4, $$props, "value", {}, null);
        reset(div);
        append($$anchor2, fragment);
      };
      var alternate = ($$anchor2, $$elseif) => {
        {
          var consequent_8 = ($$anchor3) => {
            var fragment_1 = comment();
            var node_5 = first_child(fragment_1);
            slot(node_5, $$props, "input", {}, ($$anchor4) => {
              var fragment_2 = comment();
              var node_6 = first_child(fragment_2);
              {
                var consequent_4 = ($$anchor5) => {
                  var fragment_3 = root_7();
                  var node_7 = first_child(fragment_3);
                  {
                    var consequent_2 = ($$anchor6) => {
                      var textarea = root_82();
                      remove_textarea_child(textarea);
                      template_effect(() => {
                        set_attribute(textarea, "placeholder", placeholder());
                        set_value(textarea, get(internalValue));
                        textarea.disabled = disabled();
                      });
                      event("keydown", textarea, handleKeydown);
                      event("change", textarea, handleTextChange);
                      append($$anchor6, textarea);
                    };
                    var alternate_1 = ($$anchor6) => {
                      var input_1 = root_9();
                      remove_input_defaults(input_1);
                      template_effect(() => {
                        set_attribute(input_1, "placeholder", placeholder());
                        set_value(input_1, get(internalValue));
                      });
                      event("keydown", input_1, handleKeydown);
                      event("change", input_1, handleTextChange);
                      append($$anchor6, input_1);
                    };
                    if_block(node_7, ($$render) => {
                      if (large()) $$render(consequent_2);
                      else $$render(alternate_1, false);
                    });
                  }
                  var node_8 = sibling(node_7, 2);
                  {
                    var consequent_3 = ($$anchor6) => {
                      var div_1 = root_10();
                      var node_9 = child(div_1);
                      slot(node_9, $$props, "value", {}, null);
                      reset(div_1);
                      append($$anchor6, div_1);
                    };
                    if_block(node_8, ($$render) => {
                      if ($$slots["value"]) $$render(consequent_3);
                    });
                  }
                  append($$anchor5, fragment_3);
                };
                var alternate_2 = ($$anchor5, $$elseif2) => {
                  {
                    var consequent_7 = ($$anchor6) => {
                      var fragment_4 = comment();
                      var node_10 = first_child(fragment_4);
                      each(node_10, 1, astNodes, index2, ($$anchor7, astNode, idx) => {
                        var fragment_5 = comment();
                        var node_11 = first_child(fragment_5);
                        {
                          var consequent_5 = ($$anchor8) => {
                            var div_2 = root_142();
                            var div_3 = child(div_2);
                            var span_4 = child(div_3);
                            var code = child(span_4);
                            var text_1 = child(code);
                            reset(code);
                            reset(span_4);
                            var button_1 = sibling(span_4, 2);
                            var span_5 = sibling(child(button_1));
                            var text_2 = child(span_5);
                            reset(span_5);
                            next(2);
                            reset(button_1);
                            reset(div_3);
                            var div_4 = sibling(div_3, 2);
                            var button_2 = child(div_4);
                            button_2.disabled = strict_equals(idx, 0);
                            var span_6 = child(button_2);
                            var span_7 = sibling(child(span_6));
                            var text_3 = child(span_7);
                            reset(span_7);
                            next();
                            reset(span_6);
                            next(2);
                            reset(button_2);
                            var button_3 = sibling(button_2, 2);
                            var span_8 = child(button_3);
                            var span_9 = sibling(child(span_8));
                            var text_4 = child(span_9);
                            reset(span_9);
                            next();
                            reset(span_8);
                            next(2);
                            reset(button_3);
                            reset(div_4);
                            reset(div_2);
                            template_effect(() => {
                              set_text(text_1, `<${get(astNode).tag ?? ""}>`);
                              set_text(text_2, `${get(astNode).tag ?? ""} element`);
                              set_text(text_3, `${get(astNode).tag ?? ""} element`);
                              button_3.disabled = strict_equals(idx, astNodes().length - 1);
                              set_text(text_4, `${get(astNode).tag ?? ""} element`);
                            });
                            event("click", button_1, () => select(get(astNode)));
                            event("click", button_2, () => moveAstElement(-1, get(astNode)));
                            event("click", button_3, () => moveAstElement(1, get(astNode)));
                            event("mouseenter", div_2, () => highlightAstElement(get(astNode)));
                            event("mouseleave", div_2, () => unhighlightAstElement());
                            append($$anchor8, div_2);
                          };
                          var alternate_3 = ($$anchor8, $$elseif3) => {
                            {
                              var consequent_6 = ($$anchor9) => {
                                var textarea_1 = root_16();
                                remove_textarea_child(textarea_1);
                                template_effect(() => {
                                  set_attribute(textarea_1, "placeholder", placeholder());
                                  set_value(textarea_1, get(astNode));
                                });
                                event("keydown", textarea_1, handleKeydown);
                                event("change", textarea_1, (e) => updateNodeContents(e, idx));
                                append($$anchor9, textarea_1);
                              };
                              var alternate_4 = ($$anchor9) => {
                                var input_2 = root_17();
                                remove_input_defaults(input_2);
                                template_effect(() => {
                                  set_attribute(input_2, "placeholder", placeholder());
                                  set_value(input_2, get(astNode));
                                });
                                event("keydown", input_2, handleKeydown);
                                event("change", input_2, (e) => updateNodeContents(e, idx));
                                append($$anchor9, input_2);
                              };
                              if_block(
                                $$anchor8,
                                ($$render) => {
                                  if (large()) $$render(consequent_6);
                                  else $$render(alternate_4, false);
                                },
                                $$elseif3
                              );
                            }
                          };
                          if_block(node_11, ($$render) => {
                            if (isAstElement(get(astNode))) $$render(consequent_5);
                            else $$render(alternate_3, false);
                          });
                        }
                        append($$anchor7, fragment_5);
                      });
                      append($$anchor6, fragment_4);
                    };
                    if_block(
                      $$anchor5,
                      ($$render) => {
                        if (astNodes()) $$render(consequent_7);
                      },
                      $$elseif2
                    );
                  }
                };
                if_block(node_6, ($$render) => {
                  if (get(internalValue)) $$render(consequent_4);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_2);
            });
            append($$anchor3, fragment_1);
          };
          if_block(
            $$anchor2,
            ($$render) => {
              if (expanded()) $$render(consequent_8);
            },
            $$elseif
          );
        }
      };
      if_block(node_2, ($$render) => {
        if ($$slots["value"]) $$render(consequent_1);
        else $$render(alternate, false);
      });
    }
    reset(section);
    template_effect(() => {
      set_attribute(button, "aria-expanded", expanded());
      set_class(span_3, 1, clsx2(expanded() ? "" : " [&_path]:origin-center [&_path]:rotate-180"));
    });
    event("click", button, () => expanded(!expanded()));
    append($$anchor, section);
    var $$pop = pop({
      get value() {
        return value2();
      },
      set value($$value) {
        value2($$value);
        flushSync();
      },
      get astNodes() {
        return astNodes();
      },
      set astNodes($$value) {
        astNodes($$value);
        flushSync();
      },
      get clearOnUpdate() {
        return clearOnUpdate();
      },
      set clearOnUpdate($$value) {
        clearOnUpdate($$value);
        flushSync();
      },
      get expanded() {
        return expanded();
      },
      set expanded($$value) {
        expanded($$value);
        flushSync();
      },
      get placeholder() {
        return placeholder();
      },
      set placeholder($$value) {
        placeholder($$value);
        flushSync();
      },
      get large() {
        return large();
      },
      set large($$value) {
        large($$value);
        flushSync();
      },
      get disableDelete() {
        return disableDelete();
      },
      set disableDelete($$value) {
        disableDelete($$value);
        flushSync();
      },
      get disabled() {
        return disabled();
      },
      set disabled($$value) {
        disabled($$value);
        flushSync();
      },
      ...legacy_api()
    });
    $$cleanup();
    return $$pop;
  }
  mark_module_end(SidebarSection);
  create_custom_element(
    SidebarSection,
    {
      value: {},
      astNodes: {},
      clearOnUpdate: {},
      expanded: {},
      placeholder: {},
      large: {},
      disableDelete: {},
      disabled: {}
    },
    ["heading", "input", "value"],
    [],
    true
  );

  // svelte/components/UiBuilder.svelte
  var UiBuilder_exports = {};
  __export(UiBuilder_exports, {
    default: () => UiBuilder
  });
  mark_module_start();
  UiBuilder[FILENAME] = "svelte/components/UiBuilder.svelte";
  var root11 = add_locations(template(`<div class="flex min-h-screen bg-gray-100" id="ui-builder-app-container" data-testid="app-container"><!> <!> <!> <!></div>`), UiBuilder[FILENAME], [[26, 0]]);
  function UiBuilder($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, UiBuilder);
    const [$$stores, $$cleanup] = setup_stores();
    const $pageAstStore = () => (validate_store(pageAst, "pageAstStore"), store_get(pageAst, "$pageAstStore", $$stores));
    const $layoutAstStore = () => (validate_store(layoutAst, "layoutAstStore"), store_get(layoutAst, "$layoutAstStore", $$stores));
    const $tailwindConfigStore = () => (validate_store(tailwindConfig, "tailwindConfigStore"), store_get(tailwindConfig, "$tailwindConfigStore", $$stores));
    const $tailwindInputStore = () => (validate_store(tailwindInput, "tailwindInputStore"), store_get(tailwindInput, "$tailwindInputStore", $$stores));
    const $liveStore = () => (validate_store(live, "liveStore"), store_get(live, "$liveStore", $$stores));
    let components = prop($$props, "components", 12);
    let pageAst2 = prop($$props, "pageAst", 12);
    let layoutAst2 = prop($$props, "layoutAst", 12);
    let tailwindConfig2 = prop($$props, "tailwindConfig", 12);
    let tailwindInput2 = prop($$props, "tailwindInput", 12);
    let live2 = prop($$props, "live", 12);
    onDestroy(() => {
      resetStores();
    });
    legacy_pre_effect(() => deep_read_state(pageAst2()), () => {
      store_set(pageAst, pageAst2());
    });
    legacy_pre_effect(() => deep_read_state(layoutAst2()), () => {
      store_set(layoutAst, layoutAst2());
    });
    legacy_pre_effect(() => deep_read_state(tailwindConfig2()), () => {
      store_set(tailwindConfig, tailwindConfig2());
    });
    legacy_pre_effect(() => deep_read_state(tailwindInput2()), () => {
      store_set(tailwindInput, tailwindInput2());
    });
    legacy_pre_effect(() => deep_read_state(live2()), () => {
      store_set(live, live2());
    });
    legacy_pre_effect_reset();
    init2();
    var div = root11();
    var node = child(div);
    Backdrop(node, {});
    var node_1 = sibling(node, 2);
    ComponentsSidebar(node_1, {
      get components() {
        return components();
      }
    });
    var node_2 = sibling(node_1, 2);
    PagePreview(node_2, {});
    var node_3 = sibling(node_2, 2);
    SelectedElementFloatingMenu(node_3, {});
    reset(div);
    append($$anchor, div);
    var $$pop = pop({
      get components() {
        return components();
      },
      set components($$value) {
        components($$value);
        flushSync();
      },
      get pageAst() {
        return pageAst2();
      },
      set pageAst($$value) {
        pageAst2($$value);
        flushSync();
      },
      get layoutAst() {
        return layoutAst2();
      },
      set layoutAst($$value) {
        layoutAst2($$value);
        flushSync();
      },
      get tailwindConfig() {
        return tailwindConfig2();
      },
      set tailwindConfig($$value) {
        tailwindConfig2($$value);
        flushSync();
      },
      get tailwindInput() {
        return tailwindInput2();
      },
      set tailwindInput($$value) {
        tailwindInput2($$value);
        flushSync();
      },
      get live() {
        return live2();
      },
      set live($$value) {
        live2($$value);
        flushSync();
      },
      ...legacy_api()
    });
    $$cleanup();
    return $$pop;
  }
  mark_module_end(UiBuilder);
  create_custom_element(
    UiBuilder,
    {
      components: {},
      pageAst: {},
      layoutAst: {},
      tailwindConfig: {},
      tailwindInput: {},
      live: {}
    },
    [],
    [],
    true
  );

  // import-glob:../svelte/**/*.svelte
  var modules = [Backdrop_exports, BrowserFrame_exports, CodeEditor_exports, ComponentsSidebar_exports, GoToParentButton_exports, LayoutAstNode_exports, PageAstNode_exports, PagePreview_exports, PageWrapper_exports, Pill_exports, ResetSelectionButton_exports, SelectedElementFloatingMenu_exports, DragMenuOption_exports, SidebarSection_exports, UiBuilder_exports];
  var __default = modules;
  var filenames = ["../svelte/components/Backdrop.svelte", "../svelte/components/BrowserFrame.svelte", "../svelte/components/CodeEditor.svelte", "../svelte/components/ComponentsSidebar.svelte", "../svelte/components/GoToParentButton.svelte", "../svelte/components/LayoutAstNode.svelte", "../svelte/components/PageAstNode.svelte", "../svelte/components/PagePreview.svelte", "../svelte/components/PageWrapper.svelte", "../svelte/components/Pill.svelte", "../svelte/components/ResetSelectionButton.svelte", "../svelte/components/SelectedElementFloatingMenu.svelte", "../svelte/components/SelectedElementFloatingMenu/DragMenuOption.svelte", "../svelte/components/SidebarSection.svelte", "../svelte/components/UiBuilder.svelte"];

  // js/beacon_live_admin.js
  var Hooks = {};
  Hooks.CodeEditorHook = CodeEditorHook;
  import_topbar.default.config({ barColors: { 0: "#29d" }, shadowColor: "rgba(0, 0, 0, .3)" });
  window.addEventListener("phx:page-loading-start", (_info) => import_topbar.default.show(300));
  window.addEventListener("phx:page-loading-stop", (_info) => import_topbar.default.hide());
  window.addEventListener("beacon_admin:clipcopy", (event2) => {
    const result_id = `${event2.target.id}-copy-to-clipboard-result`;
    const el = document.getElementById(result_id);
    if ("clipboard" in navigator) {
      if (event2.target.tagName === "INPUT") {
        txt = event2.target.value;
      } else {
        txt = event2.target.textContent;
      }
      navigator.clipboard.writeText(txt).then(() => {
        el.innerText = "Copied to clipboard";
        el.classList.remove("invisible", "text-red-500", "opacity-0");
        el.classList.add("text-green-500", "opacity-100", "-translate-y-2");
        setTimeout(function() {
          el.classList.remove("text-green-500", "opacity-100", "-translate-y-2");
          el.classList.add("invisible", "text-red-500", "opacity-0");
        }, 2e3);
      }).catch(() => {
        el.innerText = "Could not copy";
        el.classList.remove("invisible", "text-green-500", "opacity-0");
        el.classList.add("text-red-500", "opacity-100", "-translate-y-2");
      });
    } else {
      alert("Sorry, your browser does not support clipboard copy.");
    }
  });
  var socketPath = document.querySelector("html").getAttribute("phx-socket") || "/live";
  var csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");
  var liveSocket = new LiveView.LiveSocket(socketPath, Phoenix.Socket, {
    hooks: { ...getHooks(__exports), ...hooks_default, ...Hooks },
    params: { _csrf_token: csrfToken }
  });
  liveSocket.connect();
  window.liveSocket = liveSocket;
})();
/**
 * @license MIT
 * topbar 2.0.0, 2023-02-04
 * https://buunguyen.github.io/topbar
 * Copyright (c) 2021 Buu Nguyen
 */
/*! Bundled license information:

cssesc/cssesc.js:
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)
*/
